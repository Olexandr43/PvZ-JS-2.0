<!DOCTYPE html>
<!-- MIT License
Copyright (c) 2025 Olexandr_43
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<meta name="description" content="Plants vs Zombies">
    <link rel="icon" type="image/x-icon" href="favicon.ico"/>
    <title>Plants vs Zombies</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
		
		:root {
			--game-speed: 1;
		}
		
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            max-height: 700px;
            position: relative;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 40%, #90EE90 40%, #228B22 100%);
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            border-radius: 15px;
            overflow: hidden;
        }

        /* Fullscreen mode adjustments */
        body:fullscreen #gameContainer,
        body:-webkit-full-screen #gameContainer,
        body:-moz-full-screen #gameContainer,
        body:-ms-fullscreen #gameContainer {
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
        }

        #gameBoard {
            position: absolute;
            top: 150px;
            left: 100px;
            right: 20px;
            bottom: 50px;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            background: rgba(0,0,0,0.1);
            padding: 10px;
            border-radius: 10px;
        }

        .cell {
            background: linear-gradient(135deg, rgba(144, 238, 144, 0.3), rgba(34, 139, 34, 0.3));
            border: 2px solid rgba(34, 139, 34, 0.5);
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
        }
        
        .cell.crater {
            background: radial-gradient(circle, #3b2a1a 0%, #5c422a 50%, #2e1e10 100%);
            border: 2px solid #1a1a1a;
            cursor: not-allowed;
            pointer-events: none;
        }

        .cell.iced {
            background: linear-gradient(135deg, rgba(173, 216, 230, 0.8), rgba(100, 149, 237, 0.8));
            border: 2px solid rgba(173, 216, 230, 1);
            cursor: not-allowed;
            pointer-events: none;
            animation: iceGlimmer calc(2s / var(--game-speed)) infinite alternate;
        }

        @keyframes iceGlimmer {
            from { box-shadow: 0 0 2px rgba(255,255,255,0); }
            to { box-shadow: 0 0 8px rgba(255,255,255,0.7); }
        }


        .cell.crater::after {
            content: 'üî•';
            position: absolute;
            font-size: 1.5em;
            opacity: 0.3;
            animation: smoke calc(3s / var(--game-speed)) infinite alternate;
        }

        .cell.grave {
            cursor: not-allowed;
            position: relative;
        }
        .cell.grave::before {
            content: '‚ö∞Ô∏è';
            font-size: 2.5em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .cell.grave.grave-spawn::before {
            animation: graveRise calc(0.5s / var(--game-speed)) ease-out;
        }

        @keyframes graveRise {
            0% {
                transform: translate(-50%, -30%) scale(0.8);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }
        }
		
        #gameBoard:not(.shovel-mode) .cell.grave {
            cursor: pointer;
        }
        #gameBoard:not(.shovel-mode) .cell.grave:hover {
            background: rgba(144, 238, 144, 0.5);
        }
        
        @keyframes smoke {
            from { transform: translateY(0) scale(1); opacity: 0.3; }
            to { transform: translateY(-10px) scale(1.2); opacity: 0.1; }
        }

        .cell:hover {
            background: rgba(144, 238, 144, 0.5);
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .plant {
            font-size: 2.5em;
            animation: plantGrow calc(0.5s / var(--game-speed)) ease;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            z-index: 2;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .plant.imitated {
            filter: grayscale(100%) drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .plant.arming {
            transform: translate(-50%, -50%) scale(0.6);
            opacity: 0.7;
            transition: transform calc(0.3s / var(--game-speed)) ease, opacity calc(0.3s / var(--game-speed)) ease;
        }

        .plant.armed {
            animation: mineArm calc(0.3s / var(--game-speed)) ease-out;
        }

        @keyframes mineArm {
            0% { transform: translate(-50%, -50%) scale(0.6); }
            50% { transform: translate(-50%, -60%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .plant-health-bar {
            position: absolute;
            width: 40px;
            height: 3px;
            background: rgba(0,0,0,0.3);
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            overflow: hidden;
        }

        .plant-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width calc(0.3s / var(--game-speed)) ease;
            box-shadow: 0 0 3px rgba(76,175,80,0.5);
        }

        .plant.shooting {
            animation: shootAnimation calc(0.3s / var(--game-speed)) ease;
        }

        .plant.chewing {
            animation: chewAnimation calc(1s / var(--game-speed)) infinite ease-in-out;
        }

        .plant.eating-grave {
            animation: eatGraveAnimation calc(0.5s / var(--game-speed)) infinite ease-in-out;
        }

        @keyframes eatGraveAnimation {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(-2deg); }
            50% { transform: translate(-50%, -50%) scale(1.15) rotate(2deg); }
        }

        @keyframes shootAnimation {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes chewAnimation {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
        }

        @keyframes plantGrow {
            0% { transform: translate(-50%, -50%) scale(0) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }

        .zombie {
            position: absolute;
            font-size: 2.5em;
            z-index: 3;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
            transition: filter calc(0.3s / var(--game-speed)) ease;
            will-change: transform;
            transform: scaleX(-1);
            pointer-events: none;
        }

        .zombie.dancing {
            animation: moonwalk calc(1s / var(--game-speed)) infinite alternate ease-in-out;
        }
        .zombie.dancing.eating {
             animation: zombieEat calc(0.5s / var(--game-speed)) infinite; /* Override moonwalk when eating */
        }
        
        @keyframes moonwalk {
            0% { transform: scaleX(-1) translateX(-5px); }
            100% { transform: scaleX(-1) translateX(5px); }
        }

        .zombie.zomboni {
            font-size: 3.35em;
        }
		.zombie.gargantuar {
			font-size: 3.5em;
		}
        
        .zombie.frozen {
            filter: drop-shadow(2px 2px 8px rgba(173, 216, 230, 0.9)) brightness(1.4) saturate(0);
            animation: frozenWiggle calc(0.5s / var(--game-speed)) infinite ease-in-out;
        }

        @keyframes frozenWiggle {
            0%, 100% { transform: scaleX(-1) rotate(-1deg); }
            50% { transform: scaleX(-1) rotate(1deg); }
        }

        .zombie-health-bar {
            position: absolute;
            width: 40px;
            height: 4px;
            background: rgba(255,0,0,0.8);
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            overflow: hidden;
        }

        .zombie-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width calc(0.3s / var(--game-speed)) ease;
            box-shadow: 0 0 5px rgba(255,0,0,0.5);
        }

        .zombie.slowed {
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5)) hue-rotate(200deg) brightness(1.5);
        }

        .zombie.eating {
            animation: zombieEat calc(0.5s / var(--game-speed)) infinite;
        }

        @keyframes zombieEat {
            0%, 100% { transform: scaleX(-1) translateY(0); }
            50% { transform: scaleX(-1) translateY(-5px); }
        }

        .projectile {
            position: absolute;
            font-size: 1.5em;
            z-index: 4;
            filter: drop-shadow(0 0 5px rgba(255,255,0,0.8));
            will-change: transform;
            pointer-events: none;
        }

        .projectile.fire {
            filter: drop-shadow(0 0 10px rgba(255,100,0,1));
            animation: fireGlow calc(0.3s / var(--game-speed)) infinite alternate;
        }

        @keyframes fireGlow {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
        
        @keyframes windBlow {
            0% { transform: translateX(0) scale(1); opacity: 0.7; }
            100% { transform: translateX(1000px) scale(1.5); opacity: 0; }
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 130px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,240,240,0.95));
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex;
            gap: 10px;
            align-items: center;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        #leftPanel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 140px;
        }

        #plantSelection {
            display: flex;
            gap: 8px;
            flex: 1;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 5px;
            scrollbar-width: thin;
            scrollbar-color: rgba(0,0,0,0.2) transparent;
        }

        #plantSelection::-webkit-scrollbar {
            height: 6px;
        }

        #plantSelection::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
        }

        #plantSelection::-webkit-scrollbar-thumb {
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
        }

        .plantCard {
            min-width: 70px;
            width: 70px;
            height: 95px;
            background: linear-gradient(135deg, #fff, #f0f0f0);
            border: 3px solid #4CAF50;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .plantCard.imitated {
            filter: grayscale(1);
        }

        .plantCard[data-upgrade="true"] {
            border-color: #9b59b6;
            background: linear-gradient(135deg, #e8daef, #d5b4e0);
        }

        .plantCard[data-upgrade="true"].selected {
             background: linear-gradient(135deg, #9b59b6, #8e44ad);
             box-shadow: 0 0 20px rgba(155, 89, 182, 0.5);
        }


        .plantCard::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s ease;
            opacity: 0;
        }

        .plantCard:hover::before {
            animation: shine calc(0.5s / var(--game-speed)) ease;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }

        .plantCard:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border-color: #45a049;
        }

        .plantCard.selected {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        .plantCard.imitated.selected {
            filter: grayscale(0.5);
        }

        .plantCard.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        .plantCard.imitated.disabled {
            filter: grayscale(1) opacity(0.5);
        }

        .plantCard .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0; /* Starts at 0, animates from 100% to 0 */
            background: rgba(25, 25, 25, 0.7);
            z-index: 1;
            pointer-events: none;
            border-radius: 0 0 9px 9px;
        }

        .plantCard.on-cooldown {
            cursor: not-allowed;
            filter: grayscale(80%);
            opacity: 0.7;
        }

        .plantCard.imitated.on-cooldown {
            filter: grayscale(1) opacity(0.7);
        }
        
        .plantCard .emoji,
        .plantCard .cost,
        .plantCard .name {
            position: relative;
            z-index: 2;
        }

        .plantCard .emoji {
            font-size: 1.6em;
            margin-bottom: 2px;
        }

        .plantCard .cost {
            font-size: 0.75em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .plantCard .name {
            font-size: 0.55em;
            color: #333;
            text-align: center;
        }

        #sunCounter, #scoreCounter {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1em;
            font-weight: bold;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
            transition: transform 0.1s ease;
        }

        #sunCounter {
            background: linear-gradient(135deg, #FFD700, #FFA500);
        }

        #scoreCounter {
            background: linear-gradient(135deg, #9C27B0, #E91E63);
        }

        #controlButtons {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 140px;
        }

        .controlRow {
            display: flex;
            gap: 5px;
        }

        .controlBtn {
            padding: 8px 12px;
            font-size: 1em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            white-space: nowrap;
            flex: 1;
        }

        .controlBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .controlBtn.active {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .sun {
            position: absolute;
            font-size: 2em;
            cursor: pointer;
            z-index: 5;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));
            transition: transform calc(0.3s / var(--game-speed)) ease, filter calc(0.3s / var(--game-speed)) ease;
            display: flex;
            align-items: center;
            gap: 5px;
            will-change: transform, opacity, top, left;
        }

        .sun-value {
            font-size: 0.6em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .sun:hover {
            transform: scale(1.2);
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 1));
        }

        .points-popup {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
            pointer-events: none;
            animation: pointsFloat calc(1.5s / var(--game-speed)) ease-out forwards;
        }

        @keyframes pointsFloat {
            0% { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% { 
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }

        #gameOver, #pauseMenu, #leaderboard, #victoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(240,240,240,0.98));
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            display: none;
            max-width: 500px;
            width: 90%;
        }
        
        /* Make leaderboard highest z-index */
        #leaderboard {
            z-index: 1000;
            max-height: 70vh;
            overflow-y: auto;
        }

        #gameOver, #pauseMenu, #victoryScreen {
            z-index: 100;
        }

        #gameOver h2, #pauseMenu h2, #leaderboard h2, #victoryScreen h2 {
            font-size: 2.2em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #victoryScreen h2 {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.8), rgba(240,240,240,0.8));
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        .leaderboard-entry:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .leaderboard-entry.gold {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            font-weight: bold;
        }

        .leaderboard-entry.silver {
            background: linear-gradient(135deg, #C0C0C0, #A0A0A0);
            color: white;
            font-weight: bold;
        }

        .leaderboard-entry.bronze {
            background: linear-gradient(135deg, #CD7F32, #B87333);
            color: white;
            font-weight: bold;
        }

        .leaderboard-rank {
            font-size: 1.2em;
            font-weight: bold;
            min-width: 30px;
        }

        .leaderboard-datetime {
            flex: 1;
            text-align: left;
            margin: 0 15px;
            display: flex;
            flex-direction: column;
        }

        .leaderboard-date {
            font-size: 0.9em;
        }

        .leaderboard-time {
            font-size: 0.75em;
            opacity: 0.8;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #764ba2;
        }

        .leaderboard-entry.gold .leaderboard-score,
        .leaderboard-entry.silver .leaderboard-score,
        .leaderboard-entry.bronze .leaderboard-score {
            color: rgba(255,255,255,0.9);
        }

        .stats {
            margin: 20px 0;
            font-size: 1.1em;
            color: #333;
        }

        .btn {
            padding: 12px 25px;
            margin: 8px;
            font-size: 1em;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .btn.restart {
            background: linear-gradient(135deg, #FF9800, #FB8C00);
        }

        .btn.gold {
			margin: 0px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
        }

        #wave {
            position: absolute;
            bottom: 10px;
            right: 20px;
            font-size: 1.2em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(135deg, #FF6B6B, #FF8E53);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 9;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #wave .damage-bonus {
            font-size: 0.7em;
            margin-top: 3px;
            opacity: 0.9;
            display: none;
        }

        #wave.final-wave {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            animation: pulse calc(1s / var(--game-speed)) infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .zombie.damage-effect {
            animation: damage calc(0.3s / var(--game-speed)) ease;
        }

        @keyframes damage {
            0%, 100% { transform: scaleX(-1); filter: brightness(1); }
            50% { transform: scaleX(-1) scale(0.9); filter: brightness(1.5) hue-rotate(180deg); }
        }

        .plant-damage-effect {
            animation: plantDamage calc(0.3s / var(--game-speed)) ease;
        }

        @keyframes plantDamage {
            0%, 100% { transform: translate(-50%, -50%) scale(1); filter: brightness(1); }
            50% { transform: translate(-50%, -50%) scale(0.9); filter: brightness(1.5) hue-rotate(90deg); }
        }

        .collect-effect {
            animation: collect calc(0.5s / var(--game-speed)) ease;
        }

        @keyframes collect {
            0% { transform: scale(1) rotate(0deg); }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }
        
        @keyframes freezeFlash {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .particle {
            position: absolute;
            pointer-events: none;
            animation: particle calc(1s / var(--game-speed)) ease-out forwards;
            font-size: 1.5em;
            z-index: 10;
        }

        @keyframes particle {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; }
        }

        #debugInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 0.8em;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 5px;
            display: none;
        }

        /* Force landscape message */
        #landscapeMessage {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            z-index: 2000;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        #landscapeMessage h2 {
            font-size: 2em;
            margin-bottom: 20px;
        }

        #landscapeMessage p {
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        @media (orientation: portrait) and (max-width: 768px) {
            #landscapeMessage {
                display: flex;
            }
            
            #gameContainer {
                display: none;
            }
        }

        .save-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 200;
            animation: saveNotification calc(2s / var(--game-speed)) ease forwards;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        @keyframes saveNotification {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            40% { transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        .lawnmower {
            position: absolute;
            font-size: 2.5em;
            z-index: 3;
            will-change: left;
            transform: scaleX(-1); /* Face right */
        }

        /* Shovel Styles */
        #gameBoard.shovel-mode .cell {
            cursor: crosshair;
        }

        #gameBoard.shovel-mode .cell:hover {
            background: rgba(255, 0, 0, 0.3);
            outline: 2px solid red;
        }
		
		#shovelCard {
			background: linear-gradient(135deg, #c0c0c0, #a9a9a9);
			border-color: #808080;
		}

        #shovelCard.selected {
            background: linear-gradient(135deg, #A9A9A9, #808080);
            border-color: #696969;
            box-shadow: 0 0 20px rgba(128, 128, 128, 0.5);
        }
        
        #zombieSpawner {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: rgba(50, 50, 50, 0.8);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            padding: 10px;
            gap: 10px;
            z-index: 200;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }

        #zombieSpawner::-webkit-scrollbar {
            height: 6px;
        }

        #zombieSpawner::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
        }

        #zombieSpawner::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .zombieCard {
            min-width: 70px;
            width: 70px;
            height: 85px;
            background: linear-gradient(135deg, #f0f0f0, #ddd);
            border: 3px solid #b22222;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .zombieCard:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border-color: #ff0000;
        }

        .zombieCard.selected {
            background: linear-gradient(135deg, #b22222, #8b0000);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(178, 34, 34, 0.5);
        }

        .zombieCard .emoji {
            font-size: 1.6em;
            transform: scaleX(-1); /* Face right */
            margin-bottom: 2px;
        }
        
        .zombieCard .name {
            font-size: 0.6em;
            color: #333;
            text-align: center;
            font-weight: bold;
        }
        
        .zombieCard.selected .name {
            color: white;
        }

        #gameBoard.zombie-spawn-mode .cell {
            cursor: crosshair;
        }

        #gameBoard.zombie-spawn-mode .cell:hover {
            background: rgba(255, 0, 0, 0.3);
            outline: 2px solid red;
        }

        #plantSelectionScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(15px);
            z-index: 150;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            color: white;
        }
        
        #deckContainer {
            width: 100%;
            text-align: center;
        }

        #deckContainer h2 {
            font-size: 2.2em;
            text-shadow: 3px 3px 5px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        
        #deckBar {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-start;
            height: 130px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            overflow-x: auto;
            flex-wrap: nowrap;
        }

        #deckBar .plantCard {
            opacity: 1;
            transition: opacity 0.2s ease-in;
        }

        #deckBar .plantCard.hiding {
            opacity: 0;
            pointer-events: none;
        }
        
        #plantLibrary {
            max-width: 950px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            flex-grow: 1;
            overflow-y: auto;
        }

        #plantLibraryGrid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
			gap: 10px;
			max-width: calc(8 * 70px + 7 * 10px);
			margin: 0 auto;
        }
        
        #plantLibrary .plantCard {
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        #plantLibrary .plantCard.in-library-hidden {
            opacity: 0.4;
            pointer-events: none;
            filter: grayscale(80%);
        }

        .plant-card-clone {
            position: fixed;
            z-index: 2000;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #plantSelectionFooter {
            text-align: center;
            width: 100%;
            position: relative;
        }

        #plantSelectionFooter > div:first-child {
            position: absolute;
            left: 25px;
        }

        #selectedPlantCount {
            font-size: 1.2em;
            font-weight: bold;
        }

                /* Custom Dialog Styles */
                .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            z-index: 2000;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            padding: 15px;
        }

        .dialog-box {
            background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(240,240,240,0.98));
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 450px;
            width: 100%;
            animation: dialogAppear calc(0.3s / var(--game-speed)) ease-out;
        }

        @keyframes dialogAppear {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .dialog-box h2 {
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #333;
        }

        .dialog-box p {
            font-size: 1.1em;
            margin-bottom: 25px;
            color: #555;
            line-height: 1.6;
        }
		
		/* Landscape mode optimizations */
        @media (orientation: landscape) and (max-height: 600px) {
            #ui {
                height: 100px;
            }
            
            #gameBoard {
                top: 110px;
                bottom: 20px;
            }
            
            #wave {
                bottom: 5px;
            }
            
            .plantCard {
                min-width: 55px;
                width: 55px;
                height: 75px;
            }
            
            .plantCard .emoji {
                font-size: 1.3em;
            }
            
            .controlBtn {
                padding: 5px 8px;
                font-size: 0.85em;
            }
            
            #sunCounter, #scoreCounter {
                font-size: 0.95em;
                padding: 6px 12px;
            }
			
			#deckBar {
                height: 100px;
                padding: 8px;
            }
            #deckBar .plantCard {
                min-width: 60px;
                width: 60px;
                height: 80px;
            }
            #deckBar .plantCard .emoji {
                font-size: 1.4em;
            }
            #plantLibrary {
                padding: 10px;
            }
        }

        @media (max-width: 768px) {
            #gameBoard {
                left: 10px;
                right: 10px;
                top: 140px;
            }
            
            #wave {
                bottom: 5px;
                right: 10px;
                font-size: 1em;
                padding: 8px 15px;
            }
            
            .plantCard {
                min-width: 60px;
                width: 60px;
                height: 80px;
            }
            
            .plantCard .emoji {
                font-size: 1.4em;
            }
            
            .plant, .zombie {
                font-size: 2em;
            }

            #ui {
                padding: 8px;
                gap: 8px;
            }

            #leftPanel, #controlButtons {
                min-width: 120px;
            }

            .controlBtn {
                font-size: 0.9em;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body>
    <div id="landscapeMessage">
        <h2>üì± Rotate Your Device</h2>
        <p>Please rotate your device to landscape mode for the best gaming experience!</p>
        <div style="font-size: 4em;">‚Üª</div>
    </div>

    <div id="gameContainer">
        <div id="plantSelectionScreen" style="display: none;">
            <div id="deckContainer">
                <h2>Choose Your Plants</h2>
                <div id="deckBar">
                    <!-- Selected plants go here -->
                </div>
            </div>
            
            <div id="plantLibrary">
                <div id="plantLibraryGrid">
                    <!-- All available plants go here -->
                </div>
            </div>

            <div id="plantSelectionFooter">
                <div style="margin-bottom: 15px;">Selected: <span id="selectedPlantCount">0</span></div>
                <button id="startGameBtn" class="btn gold">Let's Rock!</button>
            </div>
        </div>

        <div id="ui" style="visibility: hidden;">
            <div id="leftPanel">
                <div id="sunCounter">‚òÄÔ∏è <span id="sunCount">200</span></div>
                <div id="scoreCounter">‚≠ê <span id="scoreCount">0</span></div>
            </div>
            
            <div id="plantSelection">
                <!-- Selected plant cards will be populated here -->
            </div>
            
            <div id="controlButtons">
                <div class="controlRow">
                    <button class="controlBtn" id="pauseBtn">‚è∏Ô∏è Pause</button>
                    <button class="controlBtn" id="speedBtn">‚ö° x1</button>
                </div>
                <div class="controlRow">
                    <button class="controlBtn" id="leaderBtn">üèÜ Top 10</button>
                    <button class="controlBtn" id="fullscreenBtn">üî≥ Full</button>
                </div>
            </div>
        </div>
        
        <div id="wave" style="visibility: hidden;">
            <div>Wave: <span id="waveCount">1</span>/20</div>
            <div class="damage-bonus">DMG: +<span id="damageBonus">0</span>%</div>
        </div>
        
        <div id="gameBoard"></div>
        
        <div id="debugInfo"></div>
        
        <div id="pauseMenu">
            <h2>Game Paused</h2>
            <button class="btn" onclick="resumeGame()">‚ñ∂Ô∏è Resume</button>
            <button class="btn restart" onclick="confirmRestart()">üîÑ Restart</button>            
        </div>
        
        <div id="leaderboard">
            <h2>üèÜ Top 10 Scores</h2>
            <div id="leaderboardList"></div>
            <button class="btn" onclick="closeLeaderboard()">Close</button>
        </div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <div class="stats">
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Waves Survived: <span id="finalWave">0</span></p>
                <p>Zombies Defeated: <span id="finalZombies">0</span></p>
            </div>
            <div>
                <button class="btn secondary" onclick="showLeaderboard()">View Top 10</button>
                <button class="btn" onclick="restartGame()">Play Again</button>
            </div>
        </div>

        <div id="victoryScreen">
            <h2>üéâ Victory! üéâ</h2>
            <div class="stats">
                <p style="font-size: 1.3em; color: #FFD700;">You survived all 20 waves!</p>
                <p>Final Score: <span id="victoryScore" style="font-size: 1.5em; color: #764ba2;">0</span></p>
                <p>Zombies Defeated: <span id="victoryZombies">0</span></p>
                <p style="margin-top: 15px; color: #4CAF50;">Your score has been saved!</p>
            </div>
            <div>
                <button class="btn gold" onclick="showLeaderboard()">View Top 10</button>
                <button class="btn" onclick="restartGame()">Play Again</button>
            </div>
        </div>

        <div id="zombieSpawner">
            <!-- Zombie cards will be added here by JavaScript -->
        </div>
    </div>

    <!-- Custom Dialog Box -->
    <div id="customDialog" class="dialog-overlay">
        <div class="dialog-box">
            <h2 id="dialogTitle"></h2>
            <p id="dialogMessage"></p>
            <div id="dialogButtons">
                <!-- Buttons are injected here -->
            </div>
        </div>
    </div>
    
    <div id="plantCardTemplates" style="display: none;">
	    <div class="plantCard" data-plant="peashooter" data-cost="100">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üå±</div>
            <div class="cost">100</div>
            <div class="name">Peashooter</div>
        </div>
        <div class="plantCard" data-plant="sunflower" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üåª</div>
            <div class="cost">50</div>
            <div class="name">Sunflower</div>
        </div>
        <div class="plantCard" data-plant="cherrybomb" data-cost="150">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üí£</div>
            <div class="cost">150</div>
            <div class="name">Cherry Bomb</div>
        </div>
		<div class="plantCard" data-plant="wallnut" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ü••</div>
            <div class="cost">50</div>
            <div class="name">Wall-nut</div>
        </div>
        <div class="plantCard" data-plant="potatomine" data-cost="25">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ü•î</div>
            <div class="cost">25</div>
            <div class="name">Potato Mine</div>
        </div>
        <div class="plantCard" data-plant="snowpea" data-cost="175">
            <div class="cooldown-overlay"></div>
            <div class="emoji">‚ùÑÔ∏è</div>
            <div class="cost">175</div>
            <div class="name">Snow Pea</div>
        </div>
        <div class="plantCard" data-plant="chomper" data-cost="150">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üåø</div>
            <div class="cost">150</div>
            <div class="name">Chomper</div>
        </div>
        <div class="plantCard" data-plant="repeater" data-cost="200">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üåæ</div>
            <div class="cost">200</div>
            <div class="name">Repeater</div>
        </div>
        <div class="plantCard" data-plant="gravebuster" data-cost="75">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ü¶á</div>
            <div class="cost">75</div>
            <div class="name">Grave Buster</div>
        </div>
        <div class="plantCard" data-plant="iceshroom" data-cost="75">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üßä</div>
            <div class="cost">75</div>
            <div class="name">Ice-shroom</div>
        </div>
        <div class="plantCard" data-plant="doomshroom" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üçÑ</div>
            <div class="cost">125</div>
            <div class="name">Doom-shroom</div>
        </div>
        <div class="plantCard" data-plant="threepeater" data-cost="325">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üéã</div>
            <div class="cost">325</div>
            <div class="name">Threepeater</div>
        </div>
        <div class="plantCard" data-plant="jalapeno" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üå∂Ô∏è</div>
            <div class="cost">125</div>
            <div class="name">Jalapeno</div>
        </div>
        <div class="plantCard" data-plant="torchwood" data-cost="175">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ü™î</div>
            <div class="cost">175</div>
            <div class="name">Torchwood</div>
        </div>
        <div class="plantCard" data-plant="tallnut" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üå∞</div>
            <div class="cost">125</div>
            <div class="name">Tall-nut</div>
        </div>
        <div class="plantCard" data-plant="cactus" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üåµ</div>
            <div class="cost">125</div>
            <div class="name">Cactus</div>
        </div>
        <div class="plantCard" data-plant="blover" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üçÄ</div>
            <div class="cost">125</div>
            <div class="name">Blover</div>
        </div>
        <div class="plantCard" data-plant="garlic" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üßÑ</div>
            <div class="cost">50</div>
            <div class="name">Garlic</div>
        </div>
        <div class="plantCard" data-plant="marigold" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üåº</div>
            <div class="cost">50</div>
            <div class="name">Marigold</div>
        </div>
		<div class="plantCard" data-plant="melonpult" data-cost="300">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üçâ</div>
            <div class="cost">300</div>
            <div class="name">Melon-pult</div>
        </div>
		<div class="plantCard" data-plant="firepea" data-cost="250">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üî•</div>
            <div class="cost">250</div>
            <div class="name">Fire Pea</div>
        </div>
		<div class="plantCard" data-plant="gatling" data-cost="250" data-upgrade="true" data-upgrades-from="repeater">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üî´</div>
            <div class="cost">250</div>
            <div class="name">Gatling Pea</div>
        </div>
        <div class="plantCard" data-plant="twinSunflower" data-cost="150" data-upgrade="true" data-upgrades-from="sunflower">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üåªüåª</div>
            <div class="cost">150</div>
            <div class="name">Twin Sunflower</div>
        </div>
        <div class="plantCard" data-plant="wintermelon" data-cost="200" data-upgrade="true" data-upgrades-from="melonpult">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ü•∂</div>
            <div class="cost">200</div>
            <div class="name">Winter Melon</div>
        </div>
        <div class="plantCard" data-plant="imitater" data-cost="">
            <div class="cooldown-overlay"></div>
            <div class="emoji">üé≠</div>
            <div class="cost"></div>
            <div class="name">Imitater</div>
        </div>
		<div class="plantCard" data-plant="suncheat" data-cost="0">
            <div class="cooldown-overlay"></div>
            <div class="emoji">‚òÄÔ∏è</div>
            <div class="cost">0</div>
            <div class="name">Suncheat</div>
        </div>
        <!-- Shovel -->
        <div class="plantCard" id="shovelCard">
            <div class="emoji">‚õèÔ∏è</div>
            <div class="name" style="font-weight: bold; margin-top: 8px;">Shovel</div>
        </div>
    </div>


    <script>
        let selectedPlantDeck = []; 
        let lastSelectedPlantForImitater = null;

        // Game State
        let gameState = {
            sun: 200,
            score: 0,
            selectedPlant: null,
            selectedZombie: null, // For debug spawner
            isShovelActive: false,
            isZombieSpawnMode: false,
            plants: [],
            zombies: [],
            projectiles: [],
            suns: [],
            lawnmowers: [],
            graves: [],
            iceTrails: [],
            wave: 1,
            maxWaves: 20,
			isSpawningComplete: false,
            zombiesDefeated: 0,
            isPaused: false,
            isGameOver: false,
            isVictory: false,
            victoryTriggered: false, // Flag to ensure victory sequence only runs once
            cellSize: { width: 0, height: 0 },
            boardRect: null,
            gameSpeed: 1,
            lastUpdate: Date.now(),
            zombieDamageMultiplier: 1.0,
            waveTimerId: null,
            wasFullscreen: false,
            sunIntervalId: null,
            gameLoopId: null,
            timers: {},
            nextTimerId: 0
        };

        // Plant Types
        const plantTypes = { // üå¥Umbrella Leaf \ üß≤Magnet-shroom
            sunflower: { 
                emoji: 'üåª', 
                health: 3.6,
                maxHealth: 3.6,
                produces: 'sun', 
                sunAmount: 50,
                baseInterval: 24000,
                shoots: false,
                description: 'Produces sun',
                cooldown: 7500 // Fast
            },
			melonpult: {
                emoji: 'üçâ',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 4, // High direct damage
                splashDamage: 1.5, // Lower splash damage
                splashRadiusY: 1, // 3 rows total (target row +/- 1)
                shootInterval: 3000,
                projectile: 'üçà',
                description: 'Splash damage',
                cooldown: 7500 // Fast
            },
            wintermelon: {
                emoji: 'ü•∂',
                health: 4.8,
                maxHealth: 4.8,
                shoots: true,
                damage: 4, 
                splashDamage: 1.5,
                splashRadiusY: 1,
                slow: true, 
                shootInterval: 3000,
                projectile: 'üßä',
                description: 'Upgrade: Freezes and damages zombies.',
                isUpgrade: true,
                upgradesFrom: 'melonpult',
                cooldown: 50000 // Very Slow
            },
			suncheat: { 
                emoji: '‚òÄÔ∏è', 
                health: 1,
                maxHealth: 1,
                produces: 'sun', 
                sunAmount: 9990,
                baseInterval: 99900,
                shoots: false,
                description: 'Cheats sun',
                cooldown: 0
            },
            twinSunflower: {
                emoji: 'üåªüåª',
                health: 3.6,
                maxHealth: 3.6,
                produces: 'sun',
                sunAmount: 100,
                baseInterval: 24000,
                shoots: false,
                description: 'Upgrade: Produces more sun',
                isUpgrade: true,
                upgradesFrom: 'sunflower',
                cooldown: 50000 // Very Slow
            },
            peashooter: { 
                emoji: 'üå±', 
                health: 3.6,
                maxHealth: 3.6,
                shoots: true, 
                damage: 1, 
                shootInterval: 1500,
                projectile: 'üü¢',
                description: 'Basic shooter',
                cooldown: 7500 // Fast
            },
            wallnut: { 
                emoji: 'ü••', 
                health: 24,
                maxHealth: 24,
                shoots: false,
                description: 'Defensive wall',
                cooldown: 30000 // Slow
            },
            potatomine: {
                emoji: 'ü•î',
                health: 3.6,
                maxHealth: 3.6,
                shoots: false,
                isMine: true,
                damage: 90,
                armTime: 14000,
                description: 'Explodes on contact after arming.',
                cooldown: 30000 // Slow
            },
            garlic: {
                emoji: 'üßÑ',
                health: 18,
                maxHealth: 18,
                shoots: false,
                diverts: true,
                description: 'Diverts zombies to other lanes',
                cooldown: 7500 // Fast
            },
            snowpea: { 
                emoji: '‚ùÑÔ∏è', 
                health: 3.6,
                maxHealth: 3.6,
                shoots: true, 
                damage: 1, 
                slow: true, 
                shootInterval: 2000,
                projectile: '‚ùÑÔ∏è',
                description: 'Slows zombies',
                cooldown: 7500 // Fast
            },
            chomper: { 
                emoji: 'üåø', 
                health: 4.88,
                maxHealth: 4.88,
                shoots: false,
                damage: 40,
                attackInterval: 1000,
                chewTime: 42000,
                description: 'Eats zombies',
                cooldown: 7500 // Fast
            },
            repeater: { 
                emoji: 'üåæ', 
                health: 3.6,
                maxHealth: 3.6,
                shoots: true, 
                damage: 1, 
                double: true, 
                shootInterval: 1500,
                projectile: 'üü¢',
                description: 'Shoots twice',
                cooldown: 7500 // Fast
            },
            threepeater: {
                emoji: 'üéã',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 1,
                triple: true,
                shootInterval: 1500,
                projectile: 'üü¢',
                description: 'Shoots 3 lanes',
                cooldown: 7500 // Fast
            },
			gatling: { 
                emoji: 'üî´', 
                health: 3.6,
                maxHealth: 3.6,
                shoots: true, 
                damage: 1, 
                quad: true, 
                shootInterval: 1500,
                projectile: 'üü¢',
                description: 'Shoots 4 peas',
                isUpgrade: true,
                upgradesFrom: 'repeater',
                cooldown: 50000 // Very Slow
            },
            firepea: {
                emoji: 'üî•',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 2,
                splashDamage: 0.65,
                splashRadiusY: 0, // 3x1 radius
                fire: true,
                shootInterval: 1500,
                projectile: 'üî•',
                description: 'Splash fire damage',
                cooldown: 7500 // Fast
            },
            cactus: {
                emoji: 'üåµ',
                health: 4.8,
                maxHealth: 4.8,
                shoots: true,
                damage: 1,
                pierce: true,
                shootInterval: 1800,
                projectile: 'üìç',
                description: 'Piercing shots',
                cooldown: 7500 // Fast
            },
            blover: {
                emoji: 'üçÄ',
                health: Infinity,
                shoots: false,
                instant: true,
                isBlower: true,
                description: 'Blows away flying zombies',
                cooldown: 7500, // Fast
            },
            torchwood: {
                emoji: 'ü™î',
                health: 4.8,
                maxHealth: 4.8,
                shoots: false,
                description: 'Ignites peas',
                cooldown: 7500 // Fast
            },
            cherrybomb: {
                emoji: 'üí£',
                health: Infinity,
                shoots: false,
                instant: true,
                damage: 90,
                radius: 1, // 3x3 area (radius of 1 from center)
                description: 'Explodes in an area',
                cooldown: 50000 // Very Slow
            },
            jalapeno: {
                emoji: 'üå∂Ô∏è',
                health: Infinity,
                shoots: false,
                instant: true,
                damage: 90,
                laneWide: true,
                description: 'Destroys an entire lane',
                cooldown: 50000 // Very Slow
            },
            doomshroom: {
                emoji: 'üçÑ',
                health: Infinity,
                shoots: false,
                instant: true,
                damage: 90,
                radiusX: 3, // 7 wide
                radiusY: 2, // 5 high
                createsCrater: true,
                description: 'Huge explosion, leaves crater.',
                cooldown: 50000 // Very Slow
            },
            iceshroom: {
                emoji: 'üßä',
                health: Infinity,
                shoots: false,
                instant: true,
                damage: 4,
                freezes: true,
                description: 'Freezes all zombies on screen.',
                cooldown: 50000 // Very Slow
            },
			tallnut: { 
                emoji: 'üå∞', 
                health: 48,
                maxHealth: 48,
                shoots: false,
                description: 'Great defensive wall',
                cooldown: 30000 // Slow
            },
			marigold: { 
                emoji: 'üåº', 
                health: 3.6,
                maxHealth: 3.6,
                produces: 'coin',
                baseInterval: 15000,
                shoots: false,
                description: 'Produces coins(useless)',
                cooldown: 30000 // Slow
            },
            gravebuster: {
                emoji: 'ü¶á',
                health: 3.6,
                maxHealth: 3.6,
                shoots: false,
                isGraveBuster: true,
                description: 'Eats graves, single use',
                cooldown: 7500 // Fast
            },
            imitater: {
                emoji: 'üé≠',
                health: 0, // Health is copied from target
                isImitater: true,
                description: 'Copies the previously selected plant.',
                cooldown: 1000 // Cooldown is on the transformed card
            },
        };

        // Zombies
        const zombieTypes = {
            normal: { name: 'Zombie', emoji: 'üßü', health: 10, maxHealth: 10, speed: 13, damage: 1, points: 100 },
            cone: { name: 'Conehead', emoji: 'üßü‚Äç‚ôÇÔ∏è', health: 32, maxHealth: 32, speed: 13, damage: 1, points: 200 },
            bucket: { name: 'Buckethead', emoji: 'üßü‚Äç‚ôÄÔ∏è', health: 68, maxHealth: 68, speed: 10, damage: 1, points: 400 },
            fast: { name: 'Pole Vault', emoji: 'üíÄ', health: 25, maxHealth: 25, speed: 25, damage: 1, points: 150 },
            football: { name: 'Football', emoji: 'üëπ', health: 84, maxHealth: 84, speed: 25, damage: 2, points: 600 },
			gargantuar: { name: 'Gargantuar', emoji: 'üóø', health: 180, maxHealth: 180, speed: 5, damage: 99, points: 2000, uneatable: true, crushes: true },
			giga: { name: 'Giga-Garg', emoji: 'üë∫', health: 600, maxHealth: 600, speed: 5, damage: 99, points: 6000, uneatable: true, crushes: true },
            dancing: { name: 'Dancing', emoji: 'üï∫', health: 25, maxHealth: 25, speed: 13, damage: 1, points: 500, summons: true, summonCooldown: 10000 }, // Changed cooldown
            backupDancer: { name: 'Backup', emoji: 'üíÉ', health: 14, maxHealth: 14, speed: 13, damage: 1, points: 150, isSummoned: true },
            zomboni: { name: 'Zomboni', emoji: 'üöö', health: 58, maxHealth: 58, speed: 10, damage: 99, points: 1000, uneatable: true, crushes: true, leavesIceTrail: true },
            balloon: { name: 'Balloon', emoji: 'üéà', health: 15, maxHealth: 15, speed: 25, damage: 1, points: 250, isFlying: true }
        };

        // --- NEW TIMER SYSTEM ---
        function createTimer(delay, callback, isInterval = false) {
            const id = gameState.nextTimerId++;
            gameState.timers[id] = {
                id,
                delay,
                remaining: delay,
                callback,
                isInterval,
            };
            return id;
        }

        function clearTimer(id) {
            if (gameState.timers[id]) {
                delete gameState.timers[id];
            }
        }

        function updateTimers(deltaTime) {
            const adjustedDelta = deltaTime * gameState.gameSpeed;
            const timerIds = Object.keys(gameState.timers);

            for (const id of timerIds) {
                const timer = gameState.timers[id];
                if (timer) {
                    timer.remaining -= adjustedDelta;
                    if (timer.remaining <= 0) {
                        try {
                            timer.callback();
                        } catch (e) {
                            console.error("Error in timer callback:", e);
                        }

                        if (timer.isInterval && gameState.timers[id]) { 
                            timer.remaining += timer.delay;
                        } else {
                            clearTimer(id);
                        }
                    }
                }
            }
        }

        // Reset game state to initial values
        function resetGame() {
            // Clear any existing timers
            clearTimer(gameState.waveTimerId);
            clearTimer(gameState.sunIntervalId);
            gameState.timers = {}; // Clear all active timers
            
            // Clear all DOM elements
            clearAllGameElements();
            
            lastSelectedPlantForImitater = null;

            // Reset game state
            gameState = {
                sun: 200,
                score: 0,
                selectedPlant: null,
                selectedZombie: null, 
                isShovelActive: false,
                isZombieSpawnMode: false, 
                plants: [],
                zombies: [],
                projectiles: [],
                suns: [],
                lawnmowers: [],
                graves: [],
                iceTrails: [],
                wave: 1,
                maxWaves: 20,
                zombiesDefeated: 0,
                isPaused: false,
                isGameOver: false,
                isVictory: false,
                victoryTriggered: false, // Reset flag
                cellSize: { width: 0, height: 0 },
                boardRect: null,
                gameSpeed: 1,
                lastUpdate: Date.now(),
                zombieDamageMultiplier: 1.0,
                waveTimerId: null,
                wasFullscreen: document.fullscreenElement !== null,
                sunIntervalId: null,
                gameLoopId: gameState.gameLoopId, // Keep the game loop running
                timers: {},
                nextTimerId: 0
            };
            
            // Reset UI
            document.getElementById('sunCount').textContent = '200';
            document.getElementById('scoreCount').textContent = '0';
            document.getElementById('waveCount').textContent = '1';
            document.getElementById('damageBonus').textContent = '0';
            document.getElementById('speedBtn').textContent = '‚ö° x1';
            document.getElementById('speedBtn').classList.remove('active');
            document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
            document.getElementById('gameBoard').classList.remove('shovel-mode');
            document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
            document.getElementById('gameContainer').style.setProperty('--game-speed', 1);
            
            // Hide all menus
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('zombieSpawner').style.display = 'none';
            document.getElementById('plantSelection').innerHTML = '';
            
            
            // Reset zombie card selection
            document.querySelectorAll('.zombieCard').forEach(card => card.classList.remove('selected'));
            
            // Update displays
            updateSunDisplay();
            updateDamageDisplay();
            updateWaveDisplay();
            updateBoardDimensions();
        }

        // Clear all game elements from DOM
        function clearAllGameElements() {
            // Remove all zombies
            document.querySelectorAll('.zombie').forEach(el => el.remove());
            
            // Remove all projectiles
            document.querySelectorAll('.projectile').forEach(el => el.remove());
            
            // Remove all suns
            document.querySelectorAll('.sun').forEach(el => el.remove());
            
            // Remove all plants from cells
            document.querySelectorAll('.cell .plant').forEach(el => el.remove());
            
            // Remove any floating particles or popups
            document.querySelectorAll('.particle, .points-popup, .instant-effect').forEach(el => el.remove());
			
			// Remove all lawnmovers
			document.querySelectorAll('.lawnmower').forEach(el => el.remove());
			
			// Remove all craters
			document.querySelectorAll('.cell.crater').forEach(cell => cell.classList.remove('crater'));

            // Remove all graves
            document.querySelectorAll('.cell.grave').forEach(cell => cell.classList.remove('grave'));

            // Remove all ice trails
            document.querySelectorAll('.cell.iced').forEach(cell => cell.classList.remove('iced'));
        }

        // Calculate zombie damage with wave multiplier
        function getZombieDamage(baseZombieDamage) {
            return baseZombieDamage * gameState.zombieDamageMultiplier;
        }

        // Update damage multiplier display
        function updateDamageDisplay() {
            const bonusPercent = Math.round((gameState.zombieDamageMultiplier - 1) * 100);
            document.getElementById('damageBonus').textContent = bonusPercent;
        }

        // Update wave display
        function updateWaveDisplay() {
            document.getElementById('waveCount').textContent = gameState.wave;
            const waveElement = document.getElementById('wave');
            if (gameState.wave === gameState.maxWaves) {
                waveElement.classList.add('final-wave');
            } else {
                waveElement.classList.remove('final-wave');
            }
        }

        // Format date and time for display
        function formatDateTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            const timeStr = date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            
            let dateStr;
            if (diffDays === 0) {
                dateStr = 'Today';
            } else if (diffDays === 1) {
                dateStr = 'Yesterday';
            } else if (diffDays < 7) {
                dateStr = `${diffDays} days ago`;
            } else {
                dateStr = date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
                });
            }
            
            return { date: dateStr, time: timeStr };
        }

        // Show save notification
        function showSaveNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification';
            notification.textContent = '‚úÖ Score Saved to Top 10!';
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        // Leaderboard Functions
        function getLeaderboard() {
            const saved = localStorage.getItem('pvz_leaderboard');
            return saved ? JSON.parse(saved) : [];
        }

        function saveToLeaderboard(score, wave, zombies) {
            let leaderboard = getLeaderboard();
            
            leaderboard.push({
                score: score,
                wave: wave,
                zombies: zombies,
                datetime: new Date().toISOString(),
                victory: gameState.isVictory
            });
            
            // Sort by score and keep top 10
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10);
            
            localStorage.setItem('pvz_leaderboard', JSON.stringify(leaderboard));
            
            // Show notification if score made it to top 10
            if (leaderboard.some(entry => entry.score === score && entry.datetime === leaderboard[leaderboard.length - 1].datetime)) {
                showSaveNotification();
            }
            
            return leaderboard;
        }

        function displayLeaderboard() {
            const leaderboard = getLeaderboard();
            const listElement = document.getElementById('leaderboardList');
            listElement.innerHTML = '';
            
            if (leaderboard.length === 0) {
                listElement.innerHTML = '<p style="color: #666;">No scores yet. Be the first!</p>';
                return;
            }
            
            leaderboard.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'leaderboard-entry';
                
                if (index === 0) entryDiv.classList.add('gold');
                else if (index === 1) entryDiv.classList.add('silver');
                else if (index === 2) entryDiv.classList.add('bronze');
                
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
                const { date, time } = formatDateTime(entry.datetime);
                const victoryBadge = entry.victory ? ' üëë' : '';
                
                entryDiv.innerHTML = `
                    <span class="leaderboard-rank">${medal}</span>
                    <div class="leaderboard-datetime">
                        <span class="leaderboard-date">${date}${victoryBadge}</span>
                        <span class="leaderboard-time">${time}</span>
                    </div>
                    <span class="leaderboard-score">${entry.score.toLocaleString()}</span>
                `;
                
                listElement.appendChild(entryDiv);
            });
        }

        function showLeaderboard() {
            displayLeaderboard();
            document.getElementById('leaderboard').style.display = 'block';
        }

        function closeLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
        }

    // This function now only sets up listeners for dynamic or game-session-specific elements.
    function setupGameBoardListeners() {
        document.querySelectorAll('.cell').forEach(cell => {
            cell.addEventListener('click', () => placePlant(cell));
            cell.addEventListener('touchstart', (e) => {
                e.preventDefault();
                placePlant(cell);
            });
        });

        document.getElementById('startGameBtn').addEventListener('click', confirmAndStartGame);
    }

    // This function sets up listeners for permanent UI elements and is only called ONCE.
    function setupUIEventListeners() {
        document.getElementById('pauseBtn').addEventListener('click', togglePause);

        document.getElementById('speedBtn').addEventListener('click', () => {
            gameState.gameSpeed = gameState.gameSpeed === 1 ? 2 : gameState.gameSpeed === 2 ? 3 : 1;
            const btn = document.getElementById('speedBtn');
            btn.textContent = `‚ö° x${gameState.gameSpeed}`;
            btn.classList.toggle('active', gameState.gameSpeed > 1);
            document.getElementById('gameContainer').style.setProperty('--game-speed', gameState.gameSpeed);
        });

        document.getElementById('leaderBtn').addEventListener('click', showLeaderboard);
        document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

        window.addEventListener('resize', updateBoardDimensions);
        
        document.addEventListener('fullscreenchange', () => {
            setTimeout(updateBoardDimensions, 100);
        });
        
        document.addEventListener('webkitfullscreenchange', () => {
            setTimeout(updateBoardDimensions, 100);
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                const debugInfo = document.getElementById('debugInfo');
                debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
            }
            if (e.key === 'z' || e.key === 'Z') {
                toggleZombieSpawner();
            }
        });
    }

    // Sets up the plant selection listeners ONCE
    function setupPlantSelectionListeners() {
        const libraryGrid = document.getElementById('plantLibraryGrid');
        const deckBar = document.getElementById('deckBar');

        // Main click listener for the library (using event delegation)
        libraryGrid.addEventListener('click', (event) => {
            const clickedCard = event.target.closest('.plantCard');
            if (!clickedCard || clickedCard.classList.contains('in-library-hidden')) return;

            const plantName = clickedCard.dataset.plant;
            const plantInfo = plantTypes[plantName];

            if (plantInfo.isImitater) {
                // --- IMITATER LOGIC ---
                if (!lastSelectedPlantForImitater) {
                    showCustomDialog(
                        'Imitater Plant',
                        'Please select a regular plant from the library first, which the Imitater will copy.',
                        [{ text: 'OK', class: 'secondary' }]
                    );
                    return;
                }
                if (plantTypes[lastSelectedPlantForImitater.type].isUpgrade) {
                    showCustomDialog(
                        'Imitater Plant',
                        'The Imitater cannot copy upgrade plants like Gatling Pea or Twin Sunflower.',
                        [{ text: 'OK', class: 'secondary' }]
                    );
                    return;
                }

                const targetInfo = plantTypes[lastSelectedPlantForImitater.type];
                
                const imitaterCardClone = clickedCard.cloneNode(true);
                imitaterCardClone.dataset.plant = lastSelectedPlantForImitater.type;
                imitaterCardClone.dataset.cost = targetInfo.cost;
                imitaterCardClone.dataset.isImitated = 'true';
                imitaterCardClone.classList.add('imitated');

                imitaterCardClone.querySelector('.emoji').textContent = targetInfo.emoji;
                imitaterCardClone.querySelector('.cost').textContent = targetInfo.cost;
                imitaterCardClone.querySelector('.name').textContent = targetInfo.name;

                deckBar.appendChild(imitaterCardClone);
                selectedPlantDeck.push({ type: lastSelectedPlantForImitater.type, isImitated: true });

                clickedCard.classList.add('in-library-hidden');
            } else {
                // --- REGULAR PLANT LOGIC ---
                const newDeckCard = clickedCard.cloneNode(true);
                deckBar.appendChild(newDeckCard);
                selectedPlantDeck.push({ type: plantName, isImitated: false });
                lastSelectedPlantForImitater = { type: plantName };

                clickedCard.classList.add('in-library-hidden');
            }

            document.getElementById('selectedPlantCount').textContent = selectedPlantDeck.length;
        });

        // Click listener for removing plants from the deck (using event delegation)
        deckBar.addEventListener('click', (event) => {
            const clickedCard = event.target.closest('.plantCard');
            if (clickedCard) {
                handleRemoveFromDeck(clickedCard);
            }
        });
    }


    // --- Initialize Game ---
    function init() {
        createBoard();
        loadGameState();
        setupGameBoardListeners();
        setupUIEventListeners();
        setupPlantSelectionListeners();
        setupZombieSpawner();
        showPlantSelectionScreen();
        togglePause();
    }
        
    // --- Plant Selection Logic ---
    function handleRemoveFromDeck(deckCard) {
        const plantName = deckCard.dataset.plant;
        const isImitated = deckCard.dataset.isImitated === 'true';

        // Find the library card to unhide
        const libraryCardToShow = document.querySelector(`#plantLibraryGrid .plantCard[data-plant="${isImitated ? 'imitater' : plantName}"]`);
        if (libraryCardToShow) {
            libraryCardToShow.classList.remove('in-library-hidden');
        }
        
        // Remove from the internal deck array
        const indexToRemove = selectedPlantDeck.findIndex(card => card.isImitated === isImitated && card.type === plantName);
        if (indexToRemove > -1) {
            selectedPlantDeck.splice(indexToRemove, 1);
        }

        // Remove from the DOM and update state
        deckCard.remove();
        document.getElementById('selectedPlantCount').textContent = selectedPlantDeck.length;
        lastSelectedPlantForImitater = selectedPlantDeck.length > 0 ? selectedPlantDeck[selectedPlantDeck.length - 1] : null;
    }

    function showPlantSelectionScreen() {
        const screen = document.getElementById('plantSelectionScreen');
        const libraryGrid = document.getElementById('plantLibraryGrid');
        const deckBar = document.getElementById('deckBar');
        const templates = document.getElementById('plantCardTemplates');
        
        // Reset state for new selection
        libraryGrid.innerHTML = '';
        deckBar.innerHTML = '';
        selectedPlantDeck = [];
        lastSelectedPlantForImitater = null;
        document.getElementById('selectedPlantCount').textContent = '0'; // Reset count display

        document.getElementById('ui').style.visibility = 'hidden';
        document.getElementById('wave').style.visibility = 'hidden';
        screen.style.display = 'flex';

        // Populate the library
        templates.querySelectorAll('.plantCard').forEach(cardTemplate => {
            if(cardTemplate.id === 'shovelCard') return;
            const libraryCard = cardTemplate.cloneNode(true);
            libraryGrid.appendChild(libraryCard);
        });

    }


        function populateInGameUI() {
            const plantBar = document.getElementById('plantSelection');
            const templates = document.getElementById('plantCardTemplates');
            plantBar.innerHTML = '';

            selectedPlantDeck.forEach(deckItem => {
                const plantName = deckItem.type;
                const cardTemplate = templates.querySelector(`.plantCard[data-plant="${plantName}"]`);
                if (cardTemplate) {
                    const newCard = cardTemplate.cloneNode(true);
                    if (deckItem.isImitated) {
                        newCard.dataset.isImitated = 'true';
                        newCard.classList.add('imitated');
                    }
                    plantBar.appendChild(newCard);
                }
            });

            const shovelTemplate = templates.querySelector('#shovelCard');
            if (shovelTemplate) {
                plantBar.appendChild(shovelTemplate.cloneNode(true));
            }

            setupInGameCardListeners();
        }

        function confirmAndStartGame() {
            if (selectedPlantDeck.length === 0) {
                showCustomDialog(
                    'Choose Your Plants',
                    'Please select at least one plant for your deck before starting the game.',
                    [{ text: 'OK', class: 'secondary' }]
                );
                return;
            }

            document.getElementById('plantSelectionScreen').style.display = 'none';
            document.getElementById('ui').style.visibility = 'visible';
            document.getElementById('wave').style.visibility = 'visible';
            
            populateInGameUI();
            updatePlantCardAvailability();
            
            updateBoardDimensions();
			resumeGame();
            startGameLoop();
            spawnSunPeriodically();
            updateDamageDisplay();
            updateWaveDisplay();
            createTimer(5000, () => spawnZombieWave());
        }

        // Check if mobile device
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768);
        }

        // Enter fullscreen
        function enterFullscreen() {
            const elem = document.documentElement;
            
            const requestFS = elem.requestFullscreen || 
                             elem.webkitRequestFullscreen || 
                             elem.mozRequestFullScreen || 
                             elem.msRequestFullscreen;
            
            if (requestFS && !document.fullscreenElement) {
                requestFS.call(elem).then(() => {
                    gameState.wasFullscreen = true;
                    localStorage.setItem('pvz_fullscreen', 'true');
                    if (window.screen && window.screen.orientation && window.screen.orientation.lock) {
                        window.screen.orientation.lock('landscape').catch(err => {
                            console.log('Orientation lock not supported:', err);
                        });
                    }
                    setTimeout(updateBoardDimensions, 100);
                }).catch(err => {
                    console.log('Fullscreen error:', err);
                });
            }
        }

        // Create Lawnmowers
        function createLawnmowers() {
            if (!gameState.boardRect || gameState.lawnmowers.length > 0) return;

            for (let i = 0; i < 5; i++) {
                const mower = document.createElement('div');
                mower.className = 'lawnmower';
                mower.textContent = 'üöú';
                
                const yPosition = gameState.boardRect.top + i * gameState.cellSize.height + gameState.cellSize.height / 2 - 20;
                const xPosition = gameState.boardRect.left - gameState.cellSize.width * 0.4;

                mower.style.position = 'fixed';
                mower.style.top = yPosition + 'px';
                mower.style.left = xPosition + 'px';

                document.getElementById('gameContainer').appendChild(mower);

                gameState.lawnmowers.push({
                    element: mower,
                    row: i,
                    x: xPosition - gameState.boardRect.left,
                    moving: false
                });
            }
        }

        // Create Game Board
        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    board.appendChild(cell);
                }
            }
            
            setTimeout(updateBoardDimensions, 100);
        }

        // Update board dimensions
        function updateBoardDimensions() {
            const board = document.getElementById('gameBoard');
            gameState.boardRect = board.getBoundingClientRect();
            const cells = board.getElementsByClassName('cell');
            if (cells.length > 0) {
                const cellRect = cells[0].getBoundingClientRect();
                gameState.cellSize = {
                    width: cellRect.width,
                    height: cellRect.height
                };
            }

            // Create lawnmowers after dimensions are known for the first time
            if (gameState.lawnmowers.length === 0 && gameState.cellSize.width > 0) {
                createLawnmowers();
            } else {
                // Reposition existing lawnmowers on resize
                gameState.lawnmowers.forEach(mower => {
                    if (mower.element && !mower.moving) {
                        const yPosition = gameState.boardRect.top + mower.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 20;
                        const xPosition = gameState.boardRect.left - gameState.cellSize.width * 0.4;
                        mower.element.style.top = yPosition + 'px';
                        mower.element.style.left = xPosition + 'px';
                        mower.x = xPosition - gameState.boardRect.left;
                    }
                });
            }
            
            // Update existing zombie and projectile positions
            gameState.zombies.forEach(zombie => {
                if (zombie.element) {
                    const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + (zombie.isFlying ? -10 : gameState.cellSize.height / 2 - 20);
                    zombie.element.style.top = yPosition + 'px';
                }
            });
        }

// --- Separated listener setup for in-game cards ---
        function setupInGameCardListeners() {
            const mobileDevice = isMobile();

            document.querySelectorAll('#plantSelection .plantCard').forEach(card => {
                // The main function to call when a card is successfully selected
                const handleSelect = () => {
                    if (card.id === 'shovelCard') {
                        selectShovel();
                    } else {
                        selectPlant(card);
                    }
                };

                // --- Mobile-Specific Logic ---
                if (mobileDevice) {
                    let isDragging = false;
                    let touchStartX = 0;
                    let touchStartY = 0;
                    const scrollThreshold = 10; // How far a finger must move to be considered a scroll

                    card.addEventListener('touchstart', (e) => {
                        const touch = e.touches[0];
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        isDragging = false;
                    }, { passive: true });

                    card.addEventListener('touchmove', (e) => {
                        if (isDragging) return;
                        const touch = e.touches[0];
                        const deltaX = Math.abs(touch.clientX - touchStartX);
                        const deltaY = Math.abs(touch.clientY - touchStartY);

                        if (deltaX > scrollThreshold && deltaX > deltaY) {
                            isDragging = true;
                        }
                    }, { passive: true });

                    card.addEventListener('touchend', (e) => {
                        // If the touch ended without being flagged as a drag, it's a tap.
                        if (!isDragging) {
                            e.preventDefault();
                            handleSelect();
                        }
                    });
                
                // --- Desktop-Specific Logic ---
                } else {
                    card.addEventListener('click', handleSelect);
                }
            });
        }

        // Setup Event Listeners
        function setupEventListeners() {
            // This now only sets up listeners for elements that exist on page load
            document.querySelectorAll('.cell').forEach(cell => {
                cell.addEventListener('click', () => placePlant(cell));
                cell.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    placePlant(cell);
                });
            });
            
            document.getElementById('startGameBtn').addEventListener('click', confirmAndStartGame);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);

            document.getElementById('speedBtn').addEventListener('click', () => {
                gameState.gameSpeed = gameState.gameSpeed === 1 ? 2 : gameState.gameSpeed === 2 ? 3 : 1;
                const btn = document.getElementById('speedBtn');
                btn.textContent = `‚ö° x${gameState.gameSpeed}`;
                btn.classList.toggle('active', gameState.gameSpeed > 1);
                document.getElementById('gameContainer').style.setProperty('--game-speed', gameState.gameSpeed);
            });

            document.getElementById('leaderBtn').addEventListener('click', showLeaderboard);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

            window.addEventListener('resize', updateBoardDimensions);
            
            document.addEventListener('fullscreenchange', () => {
                setTimeout(updateBoardDimensions, 100);
            });
            
            document.addEventListener('webkitfullscreenchange', () => {
                setTimeout(updateBoardDimensions, 100);
            });
            
            // --- DEBUG KEY LISTENERS ---
            document.addEventListener('keydown', (e) => {
                // Debug info toggle with 'D' key
                if (e.key === 'd' || e.key === 'D') {
                    const debugInfo = document.getElementById('debugInfo');
                    debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
                }
                
                // Zombie spawner toggle with 'Z' key
                if (e.key === 'z' || e.key === 'Z') {
                    toggleZombieSpawner();
                }
            });
        }
        
        // --- Setup Zombie Spawner UI ---
        function setupZombieSpawner() {
            const spawner = document.getElementById('zombieSpawner');
            spawner.innerHTML = ''; // Clear any existing
            
            Object.keys(zombieTypes).forEach(typeKey => {
                const zombieType = zombieTypes[typeKey];
                const card = document.createElement('div');
                card.className = 'zombieCard';
                card.dataset.zombieType = typeKey;
                
                card.innerHTML = `
                    <div class="emoji">${zombieType.emoji}</div>
                    <div class="name">${zombieType.name || typeKey}</div>
                `;
                
                card.addEventListener('click', () => selectZombie(card, typeKey));
                spawner.appendChild(card);
            });
        }

        // --- Toggle Zombie Spawner UI ---
        function toggleZombieSpawner() {
            gameState.isZombieSpawnMode = !gameState.isZombieSpawnMode;
            const spawner = document.getElementById('zombieSpawner');
            
            if (gameState.isZombieSpawnMode) {
                spawner.style.display = 'flex';
            } else {
                spawner.style.display = 'none';
                // Clean up selection when closing
                gameState.selectedZombie = null;
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
            }
        }
        
        // --- Select Zombie from Spawner ---
        function selectZombie(card, typeKey) {
            if (gameState.isPaused) return;

            // Deselect any active plant or shovel
            gameState.selectedPlant = null;
            gameState.isShovelActive = false;
            document.querySelectorAll('.plantCard.selected').forEach(c => c.classList.remove('selected'));
            document.getElementById('gameBoard').classList.remove('shovel-mode');

            // Handle zombie selection
            if (gameState.selectedZombie === typeKey) {
                // Deselecting
                gameState.selectedZombie = null;
                card.classList.remove('selected');
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
            } else {
                // Selecting
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
                gameState.selectedZombie = typeKey;
                card.classList.add('selected');
                document.getElementById('gameBoard').classList.add('zombie-spawn-mode');
            }
        }

        // Select Shovel
        function selectShovel() {
            if (gameState.isPaused) return;
            
            // Deselect zombie if active
            if (gameState.selectedZombie) {
                gameState.selectedZombie = null;
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
            }
            
            gameState.isShovelActive = !gameState.isShovelActive;
            const shovelCard = document.getElementById('shovelCard');
            const gameBoard = document.getElementById('gameBoard');

            if (gameState.isShovelActive) {
                // Deselect any plant
                gameState.selectedPlant = null;
                document.querySelectorAll('.plantCard').forEach(c => c.classList.remove('selected'));
                
                shovelCard.classList.add('selected');
                gameBoard.classList.add('shovel-mode');
            } else {
                shovelCard.classList.remove('selected');
                gameBoard.classList.remove('shovel-mode');
            }
        }

        // Select Plant
        function selectPlant(card) {
            if (card.classList.contains('disabled') || card.classList.contains('on-cooldown') || gameState.isPaused) return;

            // Deselect zombie if active
            if (gameState.selectedZombie) {
                gameState.selectedZombie = null;
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
            }

            // Deactivate shovel if it's active
            if (gameState.isShovelActive) {
                gameState.isShovelActive = false;
                document.getElementById('shovelCard').classList.remove('selected');
                document.getElementById('gameBoard').classList.remove('shovel-mode');
            }

            if (card.classList.contains('selected')) {
                card.classList.remove('selected');
                gameState.selectedPlant = null;
            } else {
                document.querySelectorAll('#plantSelection .plantCard').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');

                gameState.selectedPlant = {
                    type: card.dataset.plant,
                    cost: parseInt(card.dataset.cost),
                    isImitated: card.dataset.isImitated === 'true',
                    cardElement: card 
                };
            }
        }

        // Function to remove a plant from a cell
        function removePlant(cell) {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            let actionTaken = false;

            const plantIndex = gameState.plants.findIndex(p => p.row === row && p.col === col);
            if (plantIndex !== -1) {
                const plantToRemove = gameState.plants[plantIndex];
                
                if (plantToRemove.graveBusterTimerId) {
                    clearTimer(plantToRemove.graveBusterTimerId);
                }
                if (plantToRemove.armingTimerId) {
                    clearTimer(plantToRemove.armingTimerId);
                }

                if (plantToRemove.element) {
                    createParticleEffect(plantToRemove.element, '‚õèÔ∏è');
                    plantToRemove.element.remove();
                }
                gameState.plants.splice(plantIndex, 1);
                actionTaken = true;
            }
            
            // Deactivate shovel after use
            if (actionTaken) {
                gameState.isShovelActive = false;
                document.getElementById('shovelCard').classList.remove('selected');
                document.getElementById('gameBoard').classList.remove('shovel-mode');
                updatePlantCardAvailability();
            }
        }

        // Start Cooldown on Plant Card
        function startCooldown(card, duration) {
            if (!card) return;
            
            card.classList.add('on-cooldown');
            
            const timerId = createTimer(duration, () => {
                card.classList.remove('on-cooldown');
                delete card.dataset.cooldownTimerId;
            });
            card.dataset.cooldownTimerId = timerId;
        }

        // --- PLANTING LOGIC ---

        /**
         * Checks if a plant can be placed on a specific cell.
         * This is the new central logic hub for planting rules.
         * @returns {object} { canPlant: boolean, reason: string, action: 'regular' | 'upgrade' | 'gravebust' | 'none' }
         */
        function canPlantOnCell(row, col, plantTypeInfo) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);

            // 1. Check for unplantable terrain
            if (cell.classList.contains('crater')) {
                return { canPlant: false, reason: 'Cell is a crater', action: 'none' };
            }
            // Check for ice trail
            if (cell.classList.contains('iced')) {
                return { canPlant: false, reason: 'Cell is frozen', action: 'none' };
            }

            // 2. Get info about what's on the cell
            const hasGrave = gameState.graves.some(g => g.row === row && g.col === col);
            const existingPlant = gameState.plants.find(p => p.row === row && p.col === col);

            // 3. Handle Grave Buster logic
            if (plantTypeInfo.isGraveBuster) {
                if (hasGrave) {
                    return { canPlant: true, reason: 'Planting Grave Buster', action: 'gravebust' };
                } else {
                    return { canPlant: false, reason: 'Grave Buster must be planted on a grave', action: 'none' };
                }
            }

            // 4. Handle Upgrade logic
            if (plantTypeInfo.isUpgrade) {
                if (existingPlant && existingPlant.type === plantTypeInfo.upgradesFrom) {
                    return { canPlant: true, reason: 'Upgrading existing plant', action: 'upgrade' };
                } else if (existingPlant) {
                    return { canPlant: false, reason: 'Cannot upgrade this plant', action: 'none' };
                } else {
                    return { canPlant: false, reason: 'Upgrades must be planted on an existing plant', action: 'none' };
                }
            }
            
            // 5. Handle Regular planting logic
            if (hasGrave) {
                return { canPlant: false, reason: 'Cell has a grave', action: 'none' };
            }

            if (existingPlant) {
                return { canPlant: false, reason: 'Cell already has a plant', action: 'none' };
            }
            
            // 6. If all checks pass, it's a valid regular planting
            return { canPlant: true, reason: 'Cell is clear for planting', action: 'regular' };
        }

        /**
         * Handles the logic for planting a Grave Buster.
         */
        function plantGraveBuster(row, col, plantToPlaceType, selectedPlantTypeInfo) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            
            const plant = {
                type: plantToPlaceType,
                row: row,
                col: col,
                health: selectedPlantTypeInfo.health,
                maxHealth: selectedPlantTypeInfo.maxHealth,
                element: null,
                healthBar: null,
                healthFill: null,
                shootCooldown: 0,
                sunCooldown: 0,
            };

            const plantElement = document.createElement('div');
            plantElement.className = 'plant eating-grave';
            plantElement.textContent = selectedPlantTypeInfo.emoji;
            plantElement.style.zIndex = '2'; // Ensure it's above the grave emoji
            
            const healthBar = document.createElement('div');
            healthBar.className = 'plant-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'plant-health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            plantElement.appendChild(healthBar);
            
            cell.appendChild(plantElement);
            plant.element = plantElement;
            plant.healthBar = healthBar;
            plant.healthFill = healthFill;
            
            gameState.plants.push(plant);

            const graveBusterTimerId = createTimer(5000, () => {
                // Check if plant still exists (wasn't eaten)
                const plantIndex = gameState.plants.indexOf(plant);
                if (plantIndex === -1) return; // Plant was eaten, do nothing

                const currentGraveIndex = gameState.graves.findIndex(g => g.row === row && g.col === col);
                if (currentGraveIndex !== -1) {
                    const graveToRemove = gameState.graves[currentGraveIndex];
                    if (graveToRemove.element) {
                        graveToRemove.element.classList.remove('grave');
                    }
                    gameState.graves.splice(currentGraveIndex, 1);
                }

                const sunValue = Math.random() < 0.2 ? 75 : 25; // 20% chance for 75, 80% for 25
                const emoji = sunValue === 75 ? 'üí∞' : 'üèµÔ∏è'; 
                
                const sun = document.createElement('div');
                sun.className = 'sun';
                sun.innerHTML = `<span>${emoji}</span><span class="sun-value" style="display: none;">${sunValue}</span>`;
                
                const rect = cell.getBoundingClientRect();
                sun.style.left = (rect.left + rect.width / 2 - 15) + 'px';
                sun.style.top = (rect.top + rect.height / 2 - 15) + 'px';
                sun.style.position = 'fixed';
                document.getElementById('gameContainer').appendChild(sun);
                
                sun.addEventListener('click', () => collectSun(sun, sunValue));
                sun.addEventListener('touchstart', (e) => { e.preventDefault(); collectSun(sun, sunValue); });
                
                // Auto-fade sun
                createTimer(7000, () => {
                    if (sun.parentElement && !sun.dataset.collecting) {
                        sun.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease-in, transform calc(0.5s / var(--game-speed)) ease-in';
                        sun.style.opacity = '0';
                        sun.style.transform = 'scale(0.5)';
                        createTimer(500, () => sun.remove());
                    }
                });

                if (plant.element) {
                    plant.element.remove();
                }
                gameState.plants.splice(plantIndex, 1);
                
                updatePlantCardAvailability(); // Check if gravebuster should be disabled
            });
            
            // Store timer ID on plant in case it gets eaten
            plant.graveBusterTimerId = graveBusterTimerId;
        }

        /**
         * Handles the logic for planting an Upgrade plant.
         */
        function plantUpgrade(row, col, plantToPlaceType, selectedPlantTypeInfo) {
            const plantToUpgrade = gameState.plants.find(p => p.row === row && p.col === col);
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);

            // We already checked if plantToUpgrade exists and is the correct type in canPlantOnCell
            if (!plantToUpgrade) return; 

            // Morph the existing plant
            plantToUpgrade.type = plantToPlaceType;
            plantToUpgrade.health = selectedPlantTypeInfo.health;
            plantToUpgrade.maxHealth = selectedPlantTypeInfo.maxHealth;
            plantToUpgrade.shootCooldown = 0;
            
            if (selectedPlantTypeInfo.produces === 'sun' || selectedPlantTypeInfo.produces === 'coin') {
                 plantToUpgrade.sunCooldown = (selectedPlantTypeInfo.baseInterval - 2000) + (Math.random() * 4000);
            }

            if (plantToUpgrade.element) {
                plantToUpgrade.element.textContent = selectedPlantTypeInfo.emoji;
                plantToUpgrade.element.appendChild(plantToUpgrade.healthBar); // Re-append health bar
            }
            updatePlantHealth(plantToUpgrade);
            
            createParticleEffect(cell, 'üåü');
        }

        /**
         * Handles the logic for planting a Regular or Instant plant.
         */
        function plantRegular(row, col, plantToPlaceType, selectedPlantTypeInfo) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);

            if (selectedPlantTypeInfo.instant) {
                activateInstantPlant(row, col, selectedPlantTypeInfo);
            } else {
                const plant = {
                    type: plantToPlaceType,
                    row: row,
                    col: col,
                    health: selectedPlantTypeInfo.health,
                    maxHealth: selectedPlantTypeInfo.maxHealth,
                    element: null,
                    healthBar: null,
                    healthFill: null,
                    shootCooldown: 0,
                    sunCooldown: 0,
                    isImitated: gameState.selectedPlant.isImitated || false
                };
                
                if (plant.type === 'chomper') {
                    plant.isChewing = false;
                    plant.chewTimer = 0;
                    plant.lastChomp = 0; 
                }

                if (selectedPlantTypeInfo.produces === 'sun' || selectedPlantTypeInfo.produces === 'coin') {
                    plant.sunCooldown = 7000 + (Math.random() * 5000);
                }

                const plantElement = document.createElement('div');
                plantElement.className = 'plant';
                if (plant.isImitated) {
                    plantElement.classList.add('imitated');
                }
                plantElement.textContent = selectedPlantTypeInfo.emoji;
                
                const healthBar = document.createElement('div');
                healthBar.className = 'plant-health-bar';
                const healthFill = document.createElement('div');
                healthFill.className = 'plant-health-fill';
                healthFill.style.width = '100%';
                healthBar.appendChild(healthFill);
                plantElement.appendChild(healthBar);
                
                cell.appendChild(plantElement);
                plant.element = plantElement;
                plant.healthBar = healthBar;
                plant.healthFill = healthFill;

                if (plant.type === 'potatomine') {
                    plant.isArmed = false;
                    plant.isArming = true;
                    plant.element.classList.add('arming');
                    const armingTimerId = createTimer(selectedPlantTypeInfo.armTime, () => {
                        const mineIndex = gameState.plants.indexOf(plant);
                        if (mineIndex !== -1) {
                            plant.isArmed = true;
                            plant.isArming = false;
                            if (plant.element) {
                                plant.element.classList.remove('arming');
                                plant.element.classList.add('armed');
                            }
                        }
                    });
                    plant.armingTimerId = armingTimerId;
                }
                
                gameState.plants.push(plant);
                createParticleEffect(cell, '‚ú®');
            }
        }
        
        // Spawn Zombie on Tile (from Debug)
        function spawnZombieOnTile(cell) {
            if (gameState.isPaused || !gameState.selectedZombie) return;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            spawnZombieAt(row, col, gameState.selectedZombie);
            // We don't deselect, as per user request (no cost, no cooldown)
        }

        // Place Plant
        function placePlant(cell) {
            // Handle Zombie Spawner first
            if (gameState.selectedZombie) {
                spawnZombieOnTile(cell);
                return;
            }

            // 1. Handle Shovel
            if (gameState.isShovelActive) {
                removePlant(cell);
                return;
            }

            // 2. Check for game state conditions
            if (!gameState.selectedPlant || gameState.isPaused) return;

            // 3. Get cell info
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const plantToPlaceType = gameState.selectedPlant.type;
            const selectedPlantTypeInfo = plantTypes[plantToPlaceType];
            
            // --- Centralized Planting Logic ---
            const plantingCheck = canPlantOnCell(row, col, selectedPlantTypeInfo);

            if (!plantingCheck.canPlant) {
                return;
            }
            
            // 5. Check affordability
            if (gameState.sun < gameState.selectedPlant.cost) {
                flashSunCounter();
                return;
            }

            // 6. Perform the planting action
            gameState.sun -= gameState.selectedPlant.cost;

            switch (plantingCheck.action) {
                case 'gravebust':
                    plantGraveBuster(row, col, plantToPlaceType, selectedPlantTypeInfo);
                    break;
                case 'upgrade':
                    plantUpgrade(row, col, plantToPlaceType, selectedPlantTypeInfo);
                    break;
                case 'regular':
                    plantRegular(row, col, plantToPlaceType, selectedPlantTypeInfo);
                    break;
                default:
                    // Refund sun if something went wrong
                    gameState.sun += gameState.selectedPlant.cost;
                    return;
            }
            
            // 7. Common post-planting logic
            const plantCard = gameState.selectedPlant.cardElement;
            if (plantCard && selectedPlantTypeInfo.cooldown) {
                startCooldown(plantCard, selectedPlantTypeInfo.cooldown);
            }

            if (plantingCheck.action !== 'regular') {
                addScore(50); // Bonus for upgrade/gravebusting
            } else if (!selectedPlantTypeInfo.instant) { // Instants score on explosion
                 addScore(25);
            }
            
            gameState.selectedPlant = null;
            document.querySelectorAll('.plantCard').forEach(c => c.classList.remove('selected'));
            updateSunDisplay();
        }
        
        // Function to handle instant-kill plants like Cherry Bomb and Jalapeno
        function activateInstantPlant(row, col, plantType) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            if (!cell) return;

            const plantElement = document.createElement('div');
            plantElement.className = 'plant';
            if (gameState.selectedPlant.isImitated) {
                plantElement.classList.add('imitated');
            }
            plantElement.textContent = plantType.emoji;
            cell.appendChild(plantElement);

            createTimer(1200, () => {
                plantElement.remove();

                const zombiesToDamage = [];
                
                if (plantType.radius) { // Cherry Bomb Logic
                    const explosionElement = document.createElement('div');
                    explosionElement.className = 'instant-effect';
                    explosionElement.textContent = 'üí•';
                    explosionElement.style.cssText = `position: absolute; font-size: 7em; z-index: 10; filter: drop-shadow(0 0 15px red); transform: translate(-50%, -50%); top: 50%; left: 50%;`;
                    cell.appendChild(explosionElement);
                    createTimer(600, () => explosionElement.remove());
                    
                    for (let r = row - plantType.radius; r <= row + plantType.radius; r++) {
                        for (let c = col - plantType.radius; c <= col + plantType.radius; c++) {
                            if (r >= 0 && r < 5 && c >= 0 && c < 9) {
                                const affectedCell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
                                if (affectedCell) {
                                    const marker = document.createElement('div');
                                    marker.className = 'instant-effect';
                                    marker.textContent = 'üí•';
                                    marker.style.cssText = `color: red; font-weight: bold; position: absolute; z-index: 11; animation: pointsFloat calc(1s / var(--game-speed)) ease-out;`;
                                    affectedCell.appendChild(marker);
                                    createTimer(1000, () => marker.remove());
                                }
                            }
                        }
                    }
                     gameState.zombies.forEach(zombie => {
                        const zombieCol = Math.floor(zombie.x / gameState.cellSize.width);
                        if (zombie.row >= row - plantType.radius && zombie.row <= row + plantType.radius &&
                            zombieCol >= col - plantType.radius && zombieCol <= col + plantType.radius) {
                            if (!zombiesToDamage.includes(zombie)) zombiesToDamage.push(zombie);
                        }
                    });
                } else if (plantType.radiusX && plantType.radiusY) { // Doom-shroom Logic
                    const explosionElement = document.createElement('div');
                    explosionElement.className = 'instant-effect';
                    explosionElement.textContent = 'üí•';
                    explosionElement.style.cssText = `position: absolute; font-size: 22em; z-index: 10; filter: drop-shadow(0 0 25px purple); transform: translate(-50%, -50%); top: 50%; left: 50%;`;
                    cell.appendChild(explosionElement);
                    createTimer(800, () => explosionElement.remove());

                    if (plantType.createsCrater) {
                        cell.classList.add('crater');
                        createTimer(180000, () => { // 3 minutes
                            cell.classList.remove('crater');
                        });
                    }

                    for (let r = row - plantType.radiusY; r <= row + plantType.radiusY; r++) {
                        for (let c = col - plantType.radiusX; c <= col + plantType.radiusX; c++) {
                            if (r >= 0 && r < 5 && c >= 0 && c < 9) {
                                gameState.zombies.forEach(zombie => {
                                    const zombieCol = Math.floor(zombie.x / gameState.cellSize.width);
                                    if (zombie.row === r && zombieCol === c) {
                                        if (!zombiesToDamage.includes(zombie)) zombiesToDamage.push(zombie);
                                    }
                                });
                            }
                        }
                    }
                } else if (plantType.laneWide) { // Jalapeno Logic
                    for (let c = 0; c < 9; c++) {
                        const affectedCell = document.querySelector(`.cell[data-row='${row}'][data-col='${c}']`);
                        if (affectedCell) {
                            const fireElement = document.createElement('div');
                            fireElement.className = 'instant-effect';
                            fireElement.textContent = 'üî•';
                            fireElement.style.cssText = `position: absolute; font-size: 3.5em; z-index: 10; animation: fireGlow calc(0.5s / var(--game-speed)) infinite alternate;`;
                            affectedCell.appendChild(fireElement);
                            createTimer(1000, () => fireElement.remove());

                            // Melt ice trail
                            const iceTrailIndex = gameState.iceTrails.findIndex(t => t.row === row && t.col === c);
                            if (iceTrailIndex !== -1) {
                                const iceTrail = gameState.iceTrails[iceTrailIndex];
                                clearTimer(iceTrail.timerId);
                                iceTrail.cellElement.classList.remove('iced');
                                gameState.iceTrails.splice(iceTrailIndex, 1);
                            }
                        }
                    }
                    gameState.zombies.forEach(zombie => {
                        if (zombie.row === row) {
                            if (!zombiesToDamage.includes(zombie)) zombiesToDamage.push(zombie);
                        }
                    });
                } else if (plantType.freezes) { // Ice-shroom Logic
                    const explosionElement = document.createElement('div');
                    explosionElement.className = 'instant-effect';
                    explosionElement.textContent = '‚ùÑÔ∏è';
                    explosionElement.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); font-size: 20em; z-index: 50; color: lightblue; opacity: 0.8; animation: freezeFlash calc(0.75s / var(--game-speed)) ease-out;`;
                    document.getElementById('gameContainer').appendChild(explosionElement);
                    createTimer(1000, () => explosionElement.remove());

                    gameState.zombies.forEach(zombie => {
                        if (zombie.element) {
                            zombie.health -= plantType.damage;
                            zombie.isFrozen = true;
                            zombie.freezeTimer = 4000;
                            zombie.element.classList.add('frozen');
                            zombie.element.classList.remove('eating');
                            updateZombieHealth(zombie);
                            
                            if (zombie.health <= 0) {
                                handleZombieDefeat(zombie);
                            }
                        }
                    });
                    
                    gameState.zombies = gameState.zombies.filter(z => z.element !== null);
                    return;
                } else if (plantType.isBlower) { // Blover Logic
                    for (let i = 0; i < 5; i++) {
                        const windElement = document.createElement('div');
                        windElement.className = 'instant-effect';
                        windElement.textContent = 'üí®';
                        windElement.style.cssText = `position: fixed; font-size: 4em; z-index: 10; opacity: 0.7; top: ${gameState.boardRect.top + i * gameState.cellSize.height + 20}px; left: ${gameState.boardRect.left}px; animation: windBlow calc(0.5s / var(--game-speed)) ease-out forwards;`;
                        document.getElementById('gameContainer').appendChild(windElement);
                        createTimer(800, () => windElement.remove());
                    }

                    const zombiesToBlow = gameState.zombies.filter(z => z.isFlying);
                    
                    zombiesToBlow.forEach(zombie => {
                        zombie.health = 0; // Mark for defeat
                        handleZombieDefeat(zombie, 'üí®');
                    });

                    gameState.zombies = gameState.zombies.filter(z => z.element !== null);
                    return;
                }

                // Apply damage to all targeted zombies
                zombiesToDamage.forEach(zombie => {
                    zombie.health -= plantType.damage;

                    // Unfreeze or unslow zombies hit by explosion
                    if (zombie.isFrozen) {
                        zombie.isFrozen = false;
                        zombie.freezeTimer = 0;
                        if (zombie.element) {
                            zombie.element.classList.remove('frozen');
                            createParticleEffect(zombie.element, 'üí®'); // Melt effect
                        }
                    } else if (zombie.slowed) {
                        zombie.slowed = false;
                        zombie.slowTimer = 0;
                        if (zombie.element) {
                            zombie.element.classList.remove('slowed');
                            createParticleEffect(zombie.element, 'üí®');
                        }
                    }

                    if (zombie.health <= 0) {
                        handleZombieDefeat(zombie);
                    } else {
                        if (zombie.element) {
                            updateZombieHealth(zombie);
                            zombie.element.classList.add('damage-effect');
                            createTimer(300, () => {
                                if (zombie.element) zombie.element.classList.remove('damage-effect');
                            });
                        }
                    }
                });

                // Clean up the main zombies array
                gameState.zombies = gameState.zombies.filter(z => z.element !== null);

            });
        }

        // Update Plant Health
        function updatePlantHealth(plant) {
            if (!plant.element || !plant.healthFill) return;
            
            const healthPercent = Math.max(0, plant.health / plant.maxHealth);
            plant.healthFill.style.width = (healthPercent * 100) + '%';
            
            if (healthPercent < 0.3) {
                plant.healthFill.style.background = 'linear-gradient(90deg, #ff0000, #ff6600)';
            } else if (healthPercent < 0.6) {
                plant.healthFill.style.background = 'linear-gradient(90deg, #FFA500, #FFD700)';
            } else {
                 plant.healthFill.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
            }
        }

        // Produce Sun
        function produceSun(plant) {
            if (!plant.element || !plant.element.parentElement) return;
            
            const cell = plant.element.parentElement;
            const rect = cell.getBoundingClientRect();
            const plantType = plantTypes[plant.type];
            const sunValue = plantType.sunAmount || 50;
            
            const sun = document.createElement('div');
            sun.className = 'sun';
            
            const sunEmoji = document.createElement('span');
            sunEmoji.textContent = plantType.produces === 'coin' ? 'üí∞' : '‚òÄÔ∏è';
            sun.appendChild(sunEmoji);
            
            const sunValueElement = document.createElement('span');
            sunValueElement.className = 'sun-value';
            sunValueElement.textContent = sunValue;
            // Only show value for sun, not coins
            if (plantType.produces === 'coin') {
                sunValueElement.style.display = 'none';
            }
            sun.appendChild(sunValueElement);
            
            // Set initial position for animation
            const startLeft = rect.left + rect.width / 2 - 15 + (Math.random() * 40 - 20);
            const startTop = rect.top;
            
            sun.style.left = startLeft + 'px';
            sun.style.top = startTop + 'px';
            sun.style.animation = 'none';
            sun.style.position = 'fixed';
            
            // Initial state for pop-up animation
            sun.style.transform = 'scale(0) translateY(20px)';
            sun.style.opacity = '0';
            sun.style.transition = 'transform calc(0.4s / var(--game-speed)) cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity calc(0.3s / var(--game-speed)) ease-out, top calc(0.3s / var(--game-speed)) ease-out';
            
            document.getElementById('gameContainer').appendChild(sun);
            
            // Trigger animation after element is added
            setTimeout(() => {
                sun.style.transform = 'scale(1)';
                sun.style.opacity = '1';
                sun.style.top = (startTop - 15) + 'px';
            }, 10);
            
            sun.addEventListener('click', () => collectSun(sun, sunValue));
            sun.addEventListener('touchstart', (e) => {
                e.preventDefault();
                collectSun(sun, sunValue);
            });
            
            createTimer(7000, () => {
                if (sun.parentElement && !sun.dataset.collecting) {
                    sun.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease-in, transform calc(0.5s / var(--game-speed)) ease-in';
                    sun.style.opacity = '0';
                    sun.style.transform = 'scale(0.5)';
                    createTimer(500, () => sun.remove());
                }
            });
        }


        // Shoot Projectile
        function shoot(plant) {
            if (!plant.element || !plant.element.parentElement) return;
            
            const plantType = plantTypes[plant.type];
            if (!plantType.shoots || plant.shootCooldown > 0) return;
            
            let targetRows = [plant.row];
            if (plantType.triple) {
                targetRows = [plant.row - 1, plant.row, plant.row + 1].filter(r => r >= 0 && r < 5);
            }
            
            const hasTarget = targetRows.some(row => 
                gameState.zombies.some(z => {
                    if (z.row !== row || !z.element || z.x <= plant.col * gameState.cellSize.width) return false;
                    // Cactus can target flying, others can't
                    return plant.type === 'cactus' || !z.isFlying;
                })
            );

            
            if (!hasTarget) return;
            
            plant.shootCooldown = plantType.shootInterval;
            plant.element.classList.add('shooting');
            createTimer(300, () => {
                if (plant.element) plant.element.classList.remove('shooting');
            });
            
            const cell = plant.element.parentElement;
            const rect = cell.getBoundingClientRect();
            
            const createProjectileForRow = (targetRow) => {
                 const hasRowTarget = gameState.zombies.some(z => {
                    if (z.row !== targetRow || !z.element) return false;
                    return plant.type === 'cactus' || !z.isFlying;
                });

                if (!hasRowTarget) return;

                const projectile = document.createElement('div');
                projectile.className = 'projectile';
                if (plantType.fire) projectile.classList.add('fire');
                projectile.textContent = plantType.projectile || 'üü¢';
                
                const rowY = gameState.boardRect.top + targetRow * gameState.cellSize.height + gameState.cellSize.height / 2 - 10;
                
                projectile.style.left = (rect.left + rect.width * 0.7) + 'px';
                projectile.style.top = rowY + 'px';
                projectile.style.position = 'fixed';
                
                document.getElementById('gameContainer').appendChild(projectile);
                
                let projectileDamage = plantType.damage;
                
                const proj = {
                    element: projectile,
                    row: targetRow,
                    damage: projectileDamage,
                    splashDamage: plantType.splashDamage,
                    splashRadiusY: plantType.splashRadiusY,
                    slow: plantType.slow,
                    fire: plantType.fire,
                    pierce: plantType.pierce,
                    x: rect.left + rect.width * 0.7 - gameState.boardRect.left,
                    speed: 200,
                    hitZombies: [],
                    hitTorchwoods: []
                };
                
                gameState.projectiles.push(proj);
            };
            
            targetRows.forEach(row => {
                createProjectileForRow(row);
            });
            
            if (plantType.double) {
                createTimer(200, () => {
                    targetRows.forEach(row => {
                        createProjectileForRow(row);
                    });
                });
            }
			
			if (plantType.quad) {
				createTimer(133, () => {
					targetRows.forEach(row => {
						createProjectileForRow(row);
					});
				});
				createTimer(266, () => {
					targetRows.forEach(row => {
						createProjectileForRow(row);
					});
				});
				createTimer(399, () => {
					targetRows.forEach(row => {
						createProjectileForRow(row);
					});
				});
			}
        }

        // Move Projectiles
        function moveProjectiles(deltaTime) {
            const adjustedDelta = deltaTime * gameState.gameSpeed;
            gameState.projectiles = gameState.projectiles.filter(proj => {
                if (!proj.element || !proj.element.parentElement) return false;
                
                proj.x += proj.speed * adjustedDelta / 1000;
                proj.element.style.left = (gameState.boardRect.left + proj.x) + 'px';
                
                // Logic for sequential Torchwood interaction
                const projCol = Math.floor(proj.x / gameState.cellSize.width);
                const torchwood = gameState.plants.find(p => 
                    p.type === 'torchwood' && 
                    p.row === proj.row && 
                    p.col === projCol
                );

                if (torchwood) {
                    const torchwoodId = `${torchwood.row}-${torchwood.col}`;
                    if (!proj.hitTorchwoods.includes(torchwoodId)) {
                        proj.hitTorchwoods.push(torchwoodId);

                        if (torchwood.element) {
                            torchwood.element.classList.add('shooting');
                            createTimer(300, () => {
                                if (torchwood.element) torchwood.element.classList.remove('shooting');
                            });
                        }

                        if (proj.element.textContent === '‚ùÑÔ∏è' || proj.element.textContent === 'üßä') {
                            proj.element.textContent = 'üü¢';
                            proj.slow = false;
                        } else if (proj.element.textContent === 'üü¢') {
                            proj.damage *= 2;
                            proj.element.textContent = 'üî•';
                            proj.element.classList.add('fire');
							proj.splashDamage = 0.65; // Add splash damage
                            proj.splashRadiusY = 0;   // 3x1 radius
							proj.fire = true;
                        }
                    }
                }

                const rowY = gameState.boardRect.top + proj.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 10;
                proj.element.style.top = rowY + 'px';
                
                const projRect = proj.element.getBoundingClientRect();
                let hit = false;
                
                for (const zombie of gameState.zombies) {
                    if (hit) break; // If projectile has already hit, stop checking
                    if (!zombie.element || zombie.row !== proj.row || proj.hitZombies.includes(zombie)) continue;
                    
                    const zombieRect = zombie.element.getBoundingClientRect();
                    
                    if (projRect.left < zombieRect.right && projRect.right > zombieRect.left) {                        
                        // Flying zombies can only be hit by piercing projectiles (e.g., Cactus)
                        if (zombie.isFlying && !proj.pierce) {
                            continue;
                        }

                        // Balloon Zombie Logic: popping the balloon
                        if (proj.pierce && zombie.isFlying) {
                            zombie.isFlying = false;
                            
                            const zombieEmoji = zombie.element.firstChild;
                            if (zombieEmoji) {
                                zombieEmoji.nodeValue = 'üßü';
                            }
                            zombie.element.style.transition = `top calc(0.3s / var(--game-speed)) ease-in`;
                            const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 20;
                            zombie.element.style.top = yPosition + 'px';
                            
                            zombie.element.appendChild(zombie.healthBar);
                            
                            createTimer(300, () => {
                                if (zombie.element) zombie.element.style.transition = '';
                            });
                        }

                        // --- SPLASH DAMAGE LOGIC (Melon-pult & Winter Melon) ---
                        if (proj.splashDamage) {
                            hit = true; // Splash projectiles are consumed on first hit

                            // Use existing particle mechanic for splash effect
                            createParticleEffect(zombie.element, proj.slow ? '‚ùÑÔ∏è' : (proj.fire ? 'üî•' : 'üíß'));
                            
                            // Damage primary target
                            zombie.health -= proj.damage;
                            updateZombieHealth(zombie);
                            if (zombie.element) zombie.element.classList.add('damage-effect');
                            createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); });
                            
                            if (proj.slow) {
                                zombie.slowed = true;
                                zombie.slowTimer = 3000;
                                if(zombie.element) zombie.element.classList.add('slowed');
                            }
                            
                            if (zombie.health <= 0) handleZombieDefeat(zombie);

                            const impactX = zombie.x;
                            const splashRadiusX = gameState.cellSize.width * 0.75; // Splash width

                            // Find and damage/slow splash targets based on proximity
                            gameState.zombies.forEach(splashTarget => {
                                if (splashTarget === zombie || !splashTarget.element || splashTarget.isFlying) return;
                                
                                // Check if the target is within the horizontal and vertical splash radius
                                const isHorizontallyClose = Math.abs(splashTarget.x - impactX) <= splashRadiusX;
                                const isVerticallyClose = Math.abs(splashTarget.row - proj.row) <= proj.splashRadiusY;

                                if (isHorizontallyClose && isVerticallyClose) {
                                    // Apply splash damage
                                    splashTarget.health -= proj.splashDamage;
                                    updateZombieHealth(splashTarget);
                                    if(splashTarget.element) splashTarget.element.classList.add('damage-effect');
                                    createTimer(300, () => { if (splashTarget.element) splashTarget.element.classList.remove('damage-effect'); });
                                    
                                    // Apply slow effect if projectile has it
                                    if (proj.slow) {
                                        splashTarget.slowed = true;
                                        splashTarget.slowTimer = 3000; // Standard slow duration
                                        if (splashTarget.element) splashTarget.element.classList.add('slowed');
                                    }

                                    if (splashTarget.health <= 0) handleZombieDefeat(splashTarget);
                                }
                            });

                        } else { // --- STANDARD/PIERCING DAMAGE LOGIC ---
                            zombie.health -= proj.damage;
                            updateZombieHealth(zombie);
                            zombie.element.classList.add('damage-effect');
                            
                            if (proj.slow) {
                                zombie.slowed = true;
                                zombie.slowTimer = 3000;
                                zombie.element.classList.add('slowed');
                            }
                            
                            if (proj.fire && zombie.element) {
                                if (zombie.isFrozen) {
                                    zombie.isFrozen = false;
                                    zombie.freezeTimer = 0;
                                    zombie.element.classList.remove('frozen');
                                    createParticleEffect(zombie.element, 'üí®');
                                } else if (zombie.slowed) {
                                    zombie.slowed = false;
                                    zombie.slowTimer = 0;
                                    zombie.element.classList.remove('slowed');
                                    createParticleEffect(zombie.element, 'üí®');
                                } else {
                                    createParticleEffect(zombie.element, 'üî•');
                                }
                            }
                            
                            createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); });
                            
                            if (zombie.health <= 0) handleZombieDefeat(zombie);
                            
                            if (!proj.pierce) {
                                hit = true;
                            } else {
                                proj.hitZombies.push(zombie);
                            }
                        }
                    }
                }
                
                if (hit || proj.x > window.innerWidth) {
                    proj.element.remove();
                    return false;
                }
                
                return true;
            });
        }

        // Move Lawnmowers
        function updateLawnmowers(deltaTime) {
            let zombiesKilledByMower = false;
            gameState.lawnmowers.forEach(mower => {
                if (!mower.moving || !mower.element) return;

                // Move mower
                const mowerSpeed = 500;
                mower.x += mowerSpeed * deltaTime / 1000 * gameState.gameSpeed;
                mower.element.style.left = (gameState.boardRect.left + mower.x) + 'px';

                const mowerRect = mower.element.getBoundingClientRect();

                // Check for collision with zombies in the same lane
                gameState.zombies.forEach(zombie => {
                    if (zombie.element && zombie.row === mower.row) {
                        const zombieRect = zombie.element.getBoundingClientRect();
                        if (mowerRect.right > zombieRect.left && mowerRect.left < zombieRect.right) {
                            zombie.health = 0; // Mark as dead
                            handleZombieDefeat(zombie, 'üí•');
                            zombiesKilledByMower = true;
                        }
                    }
                });

                // Remove mower after it goes off screen
                if (mower.x > gameState.boardRect.width) {
                    mower.element.remove();
                    mower.element = null;
                }
            });
            
            // If any zombies were killed, filter the main array once
            if (zombiesKilledByMower) {
                gameState.zombies = gameState.zombies.filter(z => z.element);
            }
        }

        // Update Zombie Health Bar
        function updateZombieHealth(zombie) {
            if (!zombie.element || !zombie.healthBar) return;
            
            const healthPercent = Math.max(0, zombie.health / zombieTypes[zombie.type].maxHealth);
            zombie.healthFill.style.width = (healthPercent * 100) + '%';
        }

        // Create Ice Trail
        function createIceTrail(row, col) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            if (!cell || cell.classList.contains('iced')) return;

            cell.classList.add('iced');
            
            const timerId = createTimer(90000, () => {
                cell.classList.remove('iced');
                const index = gameState.iceTrails.findIndex(t => t.row === row && t.col === col);
                if (index !== -1) {
                    gameState.iceTrails.splice(index, 1);
                }
            });

            gameState.iceTrails.push({ row, col, cellElement: cell, timerId });
        }

        // Summon Backup Dancers
        function summonBackupDancers(leader) {
            if (!leader || !leader.element) return;
            
            const now = Date.now();
            leader.lastSummon = now;

            const leaderCol = Math.floor(leader.x / gameState.cellSize.width);
            
            // Define relative positions
            const positions = [
                { r: leader.row - 1, c: leaderCol }, // Above
                { r: leader.row + 1, c: leaderCol }, // Below
                { r: leader.row, c: leaderCol - 1 }, // Behind
                { r: leader.row, c: leaderCol + 1 }  // In front
            ];

            // Filter out dead or non-existent dancers
            leader.dancers = leader.dancers.filter(d => d.element);

            positions.forEach(pos => {
                // Check if position is valid
                if (pos.r < 0 || pos.r > 4 || pos.c < 0 || pos.c > 8) return;

                // Check if a dancer (from this leader) is already there
                const dancerExists = leader.dancers.some(d => d.row === pos.r && d.spawnCol === pos.c);
                if (dancerExists) return;
                
                // Check if the cell is blocked (crater, ice)
                const cell = document.querySelector(`.cell[data-row='${pos.r}'][data-col='${pos.c}']`);
                if (!cell || cell.classList.contains('crater')) return;

                // Only spawn if dancer count is less than 4
                if (leader.dancers.length < 4) {
                    const newDancer = spawnZombieAt(pos.r, pos.c, 'backupDancer');
                    if (newDancer) {
                        newDancer.leader = leader;
                        newDancer.spawnCol = pos.c; // Store original spawn col for tracking
                        leader.dancers.push(newDancer);
                    }
                }
            });
        }


        // Move Zombies
        function moveZombies(deltaTime) {
            const adjustedDelta = deltaTime * gameState.gameSpeed;
            const now = Date.now();

            // --- Dancing Zombie Group Logic ---
            const dancingLeaders = gameState.zombies.filter(z => z.type === 'dancing' && z.element);
            
            dancingLeaders.forEach(leader => {
                // 1. Check if group is slowed or attacking
                let isGroupSlowed = leader.slowed;
                let isGroupAttacking = leader.attacking;

                // Filter out dead dancers
                leader.dancers = leader.dancers.filter(d => d.element && d.health > 0);

                leader.dancers.forEach(dancer => {
                    if (dancer.slowed) isGroupSlowed = true;
                    if (dancer.attacking) isGroupAttacking = true;
                });

                // 2. Apply group state to leader and all dancers
                leader.isGroupSlowed = isGroupSlowed;
                leader.isGroupAttacking = isGroupAttacking;
                leader.dancers.forEach(dancer => {
                    dancer.isGroupSlowed = isGroupSlowed;
                    dancer.isGroupAttacking = isGroupAttacking;
                });

                // 3. Summon logic
                if (now - leader.lastSummon > leader.summonCooldown && leader.dancers.length < 4) {
                    summonBackupDancers(leader);
                }
            });

            gameState.zombies = gameState.zombies.filter(zombie => {
                if (!zombie.element) return false;
                
                if (zombie.isFrozen) {
                    zombie.freezeTimer -= adjustedDelta;
                    if (zombie.freezeTimer <= 0) {
                        zombie.isFrozen = false;
                        zombie.element.classList.remove('frozen');
                        zombie.slowed = true;
                        zombie.slowTimer = 6000;
                        zombie.element.classList.add('slowed');
                    }
                    return true;
                }
                
                if (zombie.slowTimer > 0) {
                    zombie.slowTimer -= adjustedDelta;
                    if (zombie.slowTimer <= 0) {
                        zombie.slowed = false;
                        zombie.element.classList.remove('slowed');
                    }
                }
                
                // Determine speed and attacking state (handles group logic)
                const isSlowed = zombie.isGroupSlowed || zombie.slowed;
                let isAttacking = zombie.isGroupAttacking || zombie.attacking;
                const isFlyingAndNotAttacking = zombie.isFlying && !isAttacking;

                // Check for armed potato mines before moving
                const zombieColBeforeMove = Math.floor(zombie.x / gameState.cellSize.width);
                const mineOnTile = gameState.plants.find(p => p.type === 'potatomine' && p.isArmed && p.row === zombie.row && p.col === zombieColBeforeMove);
                
                if (mineOnTile) {
                    isAttacking = true;
                }


                // Only perform regular movement logic if not in the middle of a lane change
                if (!zombie.isChangingLane) {
                    let baseSpeed = zombieTypes[zombie.type].speed;
                    // If balloon popped, use normal zombie speed
                    if (zombie.type === 'balloon' && !zombie.isFlying) {
                        baseSpeed = zombieTypes['normal'].speed;
                    }
                    const currentSpeed = isSlowed ? baseSpeed * 0.5 : baseSpeed;
                    
                    if (!isAttacking || isFlyingAndNotAttacking) {
                        zombie.x -= currentSpeed * adjustedDelta / 1000;
                        zombie.element.style.left = (gameState.boardRect.left + zombie.x) + 'px';
                        
                        // Set Y position based on flying status
                        const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + (zombie.isFlying ? -10 : gameState.cellSize.height / 2 - 20);
                        if(zombie.element.style.top !== yPosition + 'px' && !zombie.element.style.transition.includes('top')) {
                             zombie.element.style.top = yPosition + 'px';
                        }


                        // Zomboni Ice Trail Logic
                        if (zombieTypes[zombie.type].leavesIceTrail) {
							const zomboniCenter = zombie.x + (gameState.cellSize.width / 2);
							const zomboniCol = Math.floor(zomboniCenter / gameState.cellSize.width);
                            if (zomboniCol >= 0 && zomboniCol < 9) {
                                createIceTrail(zombie.row, zomboniCol);
                            }
                        }
                    }
                }
                
                zombie.attacking = false;
                const zombieCol = Math.floor(zombie.x / gameState.cellSize.width);
                const zombieTypeInfo = zombieTypes[zombie.type];
                
                gameState.plants.forEach(plant => {
                    if (!plant.element || plant.row !== zombie.row || zombie.isFlying) return;
                    
                    if (plant.col === zombieCol) {

                        if (plant.type === 'potatomine' && plant.isArmed) return;

                        // Crusher Logic (Zomboni, Gargantuar)
                        const isCrusher = zombieTypeInfo.crushes || zombieTypeInfo.uneatable;
                        
                        if (isCrusher) {
                            zombie.attacking = false; // Crushers don't stop
                            zombie.element.classList.remove('eating');
                            plant.health = 0; // Insta-kill
                            updatePlantHealth(plant);
                            plant.element.classList.add('plant-damage-effect');
                            createTimer(300, () => {
                                if (plant.element) plant.element.classList.remove('plant-damage-effect');
                            });

                        } else { // Not a crusher, normal attack
                            zombie.attacking = true;
                            zombie.element.classList.add('eating');
                            
                            zombie.attackCooldown -= adjustedDelta;
                            if (zombie.attackCooldown <= 0) {
                                zombie.attackCooldown = 1000;
                                const damage = getZombieDamage(zombieTypeInfo.damage);
                                plant.health -= damage;
                                updatePlantHealth(plant);
                                plant.element.classList.add('plant-damage-effect');
                                
                                createTimer(300, () => {
                                    if (plant.element) {
                                        plant.element.classList.remove('plant-damage-effect');
                                    }
                                });
                                
                                // Garlic Logic (only for non-crushers)
                                if (plantTypes[plant.type].diverts && !zombie.isChangingLane) {
                                    zombie.isChangingLane = true; // Prevent movement and re-diversion

                                    createTimer(200, () => {
                                        if (!zombie.element) {
                                            zombie.isChangingLane = false;
                                            return;
                                        }

                                        let possibleRows = [];
                                        if (zombie.row === 0) possibleRows.push(1);
                                        else if (zombie.row === 4) possibleRows.push(3);
                                        else possibleRows.push(zombie.row - 1, zombie.row + 1);
                                        
                                        const newRow = possibleRows[Math.floor(Math.random() * possibleRows.length)];
                                        
                                        zombie.row = newRow;
                                        zombie.attacking = false;
                                        
                                        zombie.x -= gameState.cellSize.width * 0.375;

                                        const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + (zombie.isFlying ? -10 : gameState.cellSize.height / 2 - 20);
                                        zombie.element.style.transition = `top calc(0.3s / var(--game-speed)) ease, left calc(0.3s / var(--game-speed)) ease`;
                                        zombie.element.style.top = yPosition + 'px';
                                        zombie.element.style.left = (gameState.boardRect.left + zombie.x) + 'px';
                                        
                                        // After animation, reset state
                                        createTimer(300, () => {
                                            if (zombie.element) {
                                                zombie.element.style.transition = '';
                                            }
                                            zombie.isChangingLane = false;
                                        });

                                    });
                                }
                            }
                        }

                        // Plant death logic (common for both crushers and eaters)
                        if (plant.health <= 0) {
                            if (plant.armingTimerId) {
                                clearTimer(plant.armingTimerId);
                            }
                            if (plant.graveBusterTimerId) {
                                clearTimer(plant.graveBusterTimerId);
                            }
                            createParticleEffect(plant.element, 'üí•');
                            plant.element.remove();
                            plant.element = null;
                        }

                    }
                });
                
                if (!zombie.attacking) {
                    zombie.element.classList.remove('eating');
                }
                
                // Lawnmower activation
                if (zombie.x <= 0) {
                    const mower = gameState.lawnmowers.find(m => m.row === zombie.row);
                    if (mower && !mower.moving && mower.element) {
                        mower.moving = true;
                    }
                }

                // Game Over trigger
                if (zombie.x <= -gameState.cellSize.width) {
                    gameOver();
                }
                
                return zombie.element !== null;
            });
        }
        
        // Generic function to spawn a zombie at a specific grid location
        function spawnZombieAt(row, col, typeKey) {
            if (gameState.cellSize.width === 0) return null; // Board not ready

            const zombieType = zombieTypes[typeKey];
            if (!zombieType) return null;
            
            const zombie = document.createElement('div');
            zombie.className = 'zombie';
            zombie.textContent = zombieType.emoji;
            
            // Add classes for specific zombie styles
            if (typeKey === 'dancing') zombie.classList.add('dancing');
            if (typeKey === 'zomboni') zombie.classList.add('zomboni');
			if (typeKey === 'gargantuar' || typeKey === 'giga') zombie.classList.add('gargantuar');
            
            const healthBar = document.createElement('div');
            healthBar.className = 'zombie-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'zombie-health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            zombie.appendChild(healthBar);
            
            // Spawn *at* the cell's column
            const startX = col * gameState.cellSize.width + (gameState.cellSize.width * 0.2);
            const yPosition = gameState.boardRect.top + row * gameState.cellSize.height + (zombieType.isFlying ? -10 : gameState.cellSize.height / 2 - 20);
            
            zombie.style.position = 'fixed';
            zombie.style.left = (gameState.boardRect.left + startX) + 'px';
            zombie.style.top = yPosition + 'px';
            
            // Rise from ground animation
            zombie.style.opacity = '0';
            zombie.style.transform = 'scaleX(-1) translateY(20px)';
            zombie.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease, transform calc(0.5s / var(--game-speed)) ease';
            
            document.getElementById('gameContainer').appendChild(zombie);

            setTimeout(() => {
                zombie.style.opacity = '1';
                zombie.style.transform = 'scaleX(-1) translateY(0)';
            }, 50);
            
            const zombieObj = {
                element: zombie,
                healthBar: healthBar,
                healthFill: healthFill,
                row: row,
                health: zombieType.health,
                type: typeKey,
                x: startX,
                attacking: false,
                attackCooldown: 0,
                slowed: false,
                slowTimer: 0,
                isFrozen: false,
                freezeTimer: 0,
                isFlying: !!zombieType.isFlying,
                lastChomped: 0,
                isChangingLane: false
            };
            
            // Add special properties for Dancing Zombie
            if (typeKey === 'dancing') {
                zombieObj.dancers = [];
                // Set lastSummon time to trigger first summon after 3 seconds
                zombieObj.lastSummon = Date.now() - (zombieType.summonCooldown - 3000); 
                zombieObj.summonCooldown = zombieType.summonCooldown;
            }
            
            gameState.zombies.push(zombieObj);
            return zombieObj;
        }

        // Spawn Zombie with Health Bar (from edge)
        function spawnZombie() {
            const row = Math.floor(Math.random() * 5);
            
            // Filter out summoned zombies from natural spawn pool
            const zombieTypeKeys = Object.keys(zombieTypes).filter(k => !zombieTypes[k].isSummoned);
            let typeKey;
            const rand = Math.random();

            // Updated spawn logic with new zombies
            if (gameState.wave > 15 && rand > 0.95) {
                typeKey = 'giga';
            } else if (gameState.wave > 12 && rand > 0.9) {
                typeKey = 'gargantuar';
            } else if (gameState.wave > 10 && rand > 0.8) {
                typeKey = 'zomboni';
            } else if (gameState.wave > 9 && rand > 0.75) {
                typeKey = 'football';
            } else if (gameState.wave > 8 && rand > 0.65) {
                typeKey = 'dancing';
            } else if (gameState.wave > 7 && rand > 0.6) {
                typeKey = 'balloon';
            } else if (gameState.wave > 5 && rand > 0.4) {
                typeKey = 'bucket';
            } else if (gameState.wave > 3 && rand > 0.3) {
                typeKey = 'fast';
            } else if (gameState.wave > 1 && rand > 0.2) {
                typeKey = 'cone';
            } else {
                typeKey = 'normal';
            }
            
            const zombieType = zombieTypes[typeKey];
            
            const zombie = document.createElement('div');
            zombie.className = 'zombie';
            zombie.textContent = zombieType.emoji;
            
            // Add classes for specific zombie styles
            if (typeKey === 'dancing') zombie.classList.add('dancing');
            if (typeKey === 'zomboni') zombie.classList.add('zomboni');
			if (typeKey === 'gargantuar' || typeKey === 'giga') zombie.classList.add('gargantuar');

            
            const healthBar = document.createElement('div');
            healthBar.className = 'zombie-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'zombie-health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            zombie.appendChild(healthBar);
            
            const startX = gameState.boardRect.width;
            const yPosition = gameState.boardRect.top + row * gameState.cellSize.height + (zombieType.isFlying ? -10 : gameState.cellSize.height / 2 - 20);
            
            zombie.style.position = 'fixed';
            zombie.style.left = (gameState.boardRect.left + startX) + 'px';
            zombie.style.top = yPosition + 'px';
            
            document.getElementById('gameContainer').appendChild(zombie);
            
            const zombieObj = {
                element: zombie,
                healthBar: healthBar,
                healthFill: healthFill,
                row: row,
                health: zombieType.health,
                type: typeKey,
                x: startX,
                attacking: false,
                attackCooldown: 0,
                slowed: false,
                slowTimer: 0,
                isFrozen: false,
                freezeTimer: 0,
                isFlying: !!zombieType.isFlying,
                lastChomped: 0,
                isChangingLane: false
            };

            // Add special properties for Dancing Zombie
            if (typeKey === 'dancing') {
                zombieObj.dancers = [];
                // Set lastSummon time to trigger first summon after 3 seconds
                zombieObj.lastSummon = Date.now() - (zombieType.summonCooldown - 3000); 
                zombieObj.summonCooldown = zombieType.summonCooldown;
            }
            
            gameState.zombies.push(zombieObj);
        }

        // Spawn Zombie from a Grave
        function spawnZombieFromGrave(row, col) {
            // Only spawn basic types from graves
            const possibleTypes = ['normal', 'cone', 'bucket'];
            const randomTypeKey = possibleTypes[Math.floor(Math.random() * possibleTypes.length)];
            spawnZombieAt(row, col, randomTypeKey);
        }


        // Spawn Graves
        function spawnGraves(count) {
            const board = document.getElementById('gameBoard');
            const allCells = Array.from(board.getElementsByClassName('cell'));
            
            // Find cells that are free (no plant, no grave, not a crater, not iced)
            const freeCells = allCells.filter(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // Only spawn graves in last 4 columns (5, 6, 7, 8)
                if (col < 5) return false;
                
                const hasPlant = gameState.plants.some(p => p.row === row && p.col === col);
                const hasGrave = gameState.graves.some(g => g.row === row && g.col === col);
                const isCrater = cell.classList.contains('crater');
                const isIced = cell.classList.contains('iced');
                
                return !hasPlant && !hasGrave && !isCrater && !isIced;
            });

            freeCells.sort(() => 0.5 - Math.random());
            
            const cellsToGrave = freeCells.slice(0, count);
            
            cellsToGrave.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                cell.classList.add('grave', 'grave-spawn');
                gameState.graves.push({ row, col, element: cell });

                createTimer(500, () => {
                    if (cell) {
                        cell.classList.remove('grave-spawn');
                    }
                });
            });
        }

        // Show Points Popup
        function showPointsPopup(element, points) {
            const rect = element.getBoundingClientRect();
            const popup = document.createElement('div');
            popup.className = 'points-popup';
            popup.textContent = `+${points}`;
            popup.style.left = rect.left + 'px';
            popup.style.top = rect.top + 'px';
            popup.style.position = 'fixed';
            
            document.body.appendChild(popup);
            
            setTimeout(() => popup.remove(), 1500 / gameState.gameSpeed);
        }

        // Add Score
        function addScore(points) {
            gameState.score += points;
            document.getElementById('scoreCount').textContent = gameState.score.toLocaleString();
            
            if (gameState.score % 1000 < points) {
                gameState.sun += 50;
                updateSunDisplay();
                showPointsPopup(document.getElementById('sunCounter'), '+50 ‚òÄÔ∏è');
            }
        }

        // Spawn Zombie Wave
        function spawnZombieWave() {
            if (gameState.isGameOver || gameState.isVictory) return;
			
			gameState.isSpawningComplete = false;
            
            // Spawn graves (e.g., 1-3 new graves from wave 8 onwards, 33% chance)
            if (gameState.wave > 7 && Math.random() < 0.33) { // 33% chance
                const newGraveCount = Math.floor(Math.random() * 3) + 1; // 1, 2, or 3
                spawnGraves(newGraveCount);
            }
            
            // Spawn zombies from existing graves
            gameState.graves.forEach(grave => {
                createTimer(Math.random() * 5000 + 1000, () => {
                    if (!gameState.isGameOver && !gameState.isVictory) {
                        spawnZombieFromGrave(grave.row, grave.col);
                    }
                });
            });

            const zombieCount = Math.min(3 + Math.floor(gameState.wave / 2), 15);
            const spawnDelay = Math.max(3000 - gameState.wave * 100, 1000);
            
            for (let i = 0; i < zombieCount; i++) {
                createTimer(i * spawnDelay, () => {
                    if (!gameState.isGameOver && !gameState.isVictory) {
                        spawnZombie();
                    }
                });
            }
			
			const totalSpawnDuration = (zombieCount - 1) * spawnDelay;

			createTimer(totalSpawnDuration, () => {
				gameState.isSpawningComplete = true;
			});
            
            clearTimer(gameState.waveTimerId);
            
            gameState.waveTimerId = createTimer(30000, () => {
                if (!gameState.isGameOver && !gameState.isVictory && gameState.wave < gameState.maxWaves) {
                    gameState.wave++;
                    gameState.zombieDamageMultiplier = 1 + (gameState.wave - 1) * 0.02;
                    updateWaveDisplay();
                    updateDamageDisplay();
                    addScore(100 * gameState.wave);
                    saveGameState();
                    spawnZombieWave();
                }
            });
        }

        // Victory function
        function victory() {
            if (gameState.isVictory) return;
            gameState.isVictory = true;
            gameState.isGameOver = true;
            
            // Add victory bonus
            const victoryBonus = 5000;
            gameState.score += victoryBonus;
            
            // Auto-save score
            saveToLeaderboard(gameState.score, gameState.wave, gameState.zombiesDefeated);
            
            // Show victory screen
            document.getElementById('victoryScore').textContent = gameState.score.toLocaleString();
            document.getElementById('victoryZombies').textContent = gameState.zombiesDefeated;
            document.getElementById('victoryScreen').style.display = 'block';
        }

        // Spawn Sun Periodically
        function spawnSunPeriodically() {
            clearTimer(gameState.sunIntervalId);
            
            gameState.sunIntervalId = createTimer(8000, () => {
                if (!gameState.isGameOver) {
                    spawnFallingSun();
                }
            }, true);
        }

        // Spawn Falling Sun
        function spawnFallingSun() {
            const gameContainer = document.getElementById('gameContainer');
            const containerRect = gameContainer.getBoundingClientRect();
            
            const padding = 100;
            const spawnWidth = containerRect.width - (padding * 2);
            if (spawnWidth <= 0) return;

            const startLeft = containerRect.left + padding + (Math.random() * spawnWidth);
            const startTop = containerRect.top + 15;

            const boardTopMargin = 150 / 700;
            const boardBottomMargin = 50 / 700;
            
            const landMinY = containerRect.top + (containerRect.height * boardTopMargin);
            const landMaxY = containerRect.top + containerRect.height - (containerRect.height * boardBottomMargin) - 50;
            const endTop = landMinY + (Math.random() * (landMaxY - landMinY));
            
            const sun = document.createElement('div');
            sun.className = 'sun';
            
            const sunEmoji = document.createElement('span');
            sunEmoji.textContent = '‚òÄÔ∏è';
            sun.appendChild(sunEmoji);
            
            const sunValue = document.createElement('span');
            sunValue.className = 'sun-value';
            sunValue.textContent = '50';
            sun.appendChild(sunValue);
            
            sun.style.position = 'fixed';
            sun.style.left = startLeft + 'px';
            sun.style.top = startTop + 'px';
            sun.style.opacity = '1'; 
            sun.style.transform = 'scale(1)';
            sun.style.transition = `top calc(10s / var(--game-speed)) cubic-bezier(0.3, 0, 0.7, 1), opacity calc(0.5s / var(--game-speed)) ease-out, transform calc(0.5s / var(--game-speed)) ease-out`;
            
            document.getElementById('gameContainer').appendChild(sun);
            
            void sun.offsetHeight; 
            sun.style.top = endTop + 'px';
            
            sun.addEventListener('click', () => collectSun(sun, 50));
            sun.addEventListener('touchstart', (e) => {
                e.preventDefault();
                collectSun(sun, 50);
            });
            
            const timeToFall = 10000;
            const lifeOnGround = 7000;
            createTimer(timeToFall + lifeOnGround, () => {
                if (sun.parentElement && !sun.dataset.collecting) {
                    sun.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease-in, transform calc(0.5s / var(--game-speed)) ease-in';
                    sun.style.opacity = '0';
                    sun.style.transform = 'scale(0.5)';
                    createTimer(500, () => sun.remove());
                }
            });
        }


        // Collect Sun
        function collectSun(sunElement, value) {
			if (gameState.isPaused) return;
		
            if (!sunElement.parentElement || sunElement.dataset.collecting) return;
			
            sunElement.dataset.collecting = 'true';
			sunElement.style.pointerEvents = 'none';
            
            const sunCounter = document.getElementById('sunCounter');
            const counterRect = sunCounter.getBoundingClientRect();
            
            const sunRect = sunElement.getBoundingClientRect();

            sunElement.style.zIndex = '11';
            sunElement.style.transition = 'left calc(0.5s / var(--game-speed)) ease-in, top calc(0.5s / var(--game-speed)) ease-out, transform calc(0.5s / var(--game-speed)) ease-in, opacity calc(0.5s / var(--game-speed)) ease-in';
            sunElement.style.left = (counterRect.left + counterRect.width / 2 - sunRect.width / 2) + 'px';
            sunElement.style.top = (counterRect.top + counterRect.height / 2 - sunRect.height / 2) + 'px';
            sunElement.style.opacity = '0.5';
            
            createTimer(500, () => {
                if (sunElement.parentElement) {
                    sunElement.remove();
                }
                gameState.sun += value;
                updateSunDisplay();
                addScore(10);
            });
        }


        // Update Plant Card Availability
        function updatePlantCardAvailability() {
            const repeaterOnBoard = gameState.plants.some(p => p.type === 'repeater');
            const sunflowerOnBoard = gameState.plants.some(p => p.type === 'sunflower');
            const melonpultOnBoard = gameState.plants.some(p => p.type === 'melonpult');
            const gravesOnBoard = gameState.graves.length > 0;

            document.querySelectorAll('#plantSelection .plantCard').forEach(card => {
                if (!card.dataset.plant) return; // Skip shovel

                const cost = parseInt(card.dataset.cost);
                const isUpgrade = card.dataset.upgrade === 'true';
                const upgradesFrom = card.dataset.upgradesFrom;
                const plantType = card.dataset.plant;

                let canAfford = gameState.sun >= cost;
                let hasBasePlant = true;
                let meetsSpecialReq = true;

                if (isUpgrade) {
                    if (upgradesFrom === 'repeater') {
                        hasBasePlant = repeaterOnBoard;
                    } else if (upgradesFrom === 'sunflower') {
                        hasBasePlant = sunflowerOnBoard;
                    } else if (upgradesFrom === 'melonpult') {
                        hasBasePlant = melonpultOnBoard;
                    }
                }
                
                if (plantType === 'gravebuster') {
                    meetsSpecialReq = gravesOnBoard;
                }

                if (canAfford && hasBasePlant && meetsSpecialReq) {
                    card.classList.remove('disabled');
                } else {
                    card.classList.add('disabled');
                }
            });
        }


        // Update Sun Display
        function updateSunDisplay() {
            document.getElementById('sunCount').textContent = gameState.sun;
            updatePlantCardAvailability();
            saveGameState();
        }

        // Flash Sun Counter when not enough sun
        function flashSunCounter() {
            const sunCounter = document.getElementById('sunCounter');
            sunCounter.style.transition = 'transform 0.1s ease, background 0.1s ease';
            sunCounter.style.transform = 'scale(1.1)';
            sunCounter.style.background = 'linear-gradient(135deg, #FF6B6B, #E91E63)'; // Flash red
            
            createTimer(100, () => {
                sunCounter.style.transform = 'scale(1)';
                sunCounter.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)'; // Return to normal
                
                createTimer(100, () => {
                     sunCounter.style.transition = 'transform 0.1s ease'; // Restore original transition
                });
            });
        }

        // Create Particle Effect
        function createParticleEffect(element, emoji) {
            const rect = element.getBoundingClientRect ? 
                element.getBoundingClientRect() : 
                { left: element.offsetLeft, top: element.offsetTop };
            
            for (let i = 0; i < 3; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = emoji;
                particle.style.left = rect.left + 'px';
                particle.style.top = rect.top + 'px';
                particle.style.setProperty('--x', (Math.random() - 0.5) * 100 + 'px');
                particle.style.setProperty('--y', (Math.random() - 0.5) * 100 + 'px');
                
                document.body.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1000);
            }
        }
        
		function updateCooldownVisuals() {
			document.querySelectorAll('#plantSelection .plantCard').forEach(card => {
				const overlay = card.querySelector('.cooldown-overlay');
				if (!overlay) return;

				// If the card IS on cooldown...
				if (card.classList.contains('on-cooldown')) {
					const timerId = card.dataset.cooldownTimerId;
					if (timerId && gameState.timers[timerId]) {
						const timer = gameState.timers[timerId];
						const percent = Math.max(0, timer.remaining / timer.delay);
						overlay.style.height = `${percent * 100}%`;
					} else {
						overlay.style.height = '0%';
					}
				} else {
					// Force reset if the card is NOT on cooldown.
					overlay.style.height = '0%';
				}
			});
		}

        // --- Centralized function for handling zombie defeat ---
        function handleZombieDefeat(zombie, particleEmoji = 'üíÄ') {
            if (!zombie || !zombie.element || zombie.health > 0) return;

            // Check for victory condition.
            if (gameState.wave === gameState.maxWaves && gameState.isSpawningComplete && !gameState.victoryTriggered) {
                // Check if this kill results in zero *living* zombies on the board.
                const livingZombiesCount = gameState.zombies.filter(z => z.health > 0).length;
                
                if (livingZombiesCount === 0) {
                    // This is the last zombie (or part of the last batch).
                    gameState.victoryTriggered = true; // Set flag immediately to prevent multiple trophies
                    dropVictoryTrophy(zombie);
                    
                    // Award points for the final kill
                    addScore(zombieTypes[zombie.type].points);
                    gameState.zombiesDefeated++;

                    // Remove the element and mark for filtering
                    zombie.element.remove();
                    zombie.element = null;
                    return; // Stop further processing for this zombie
                }
            }

            // Normal death logic
            const points = zombieTypes[zombie.type].points;
            showPointsPopup(zombie.element, points);
            addScore(points);
            createParticleEffect(zombie.element, particleEmoji);
            zombie.element.remove();
            zombie.element = null;
            gameState.zombiesDefeated++;
        }

        // --- VICTORY TROPHY LOGIC ---
        function dropVictoryTrophy(zombie) {
            const trophy = document.createElement('div');
            trophy.textContent = 'üèÜ';
            trophy.style.cssText = `
                position: fixed;
                font-size: 3em;
                z-index: 100;
                cursor: pointer;
                filter: drop-shadow(0 0 15px gold);
                transition: transform calc(0.2s / var(--game-speed) ease-out;
            `;
            
            const zombieRect = zombie.element.getBoundingClientRect();
            trophy.style.left = zombieRect.left + 'px';
            trophy.style.top = zombieRect.top + 'px';

            trophy.addEventListener('mouseover', () => {
                trophy.style.transform = 'scale(1.2)';
            });
            trophy.addEventListener('mouseout', () => {
                trophy.style.transform = 'scale(1)';
            });

            trophy.addEventListener('click', () => animateAndTriggerVictory(trophy));
            
            document.getElementById('gameContainer').appendChild(trophy);
        }

        function animateAndTriggerVictory(trophyElement) {
            trophyElement.style.pointerEvents = 'none'; // Prevent double clicks
            
            const gameContainer = document.getElementById('gameContainer');
            const containerRect = gameContainer.getBoundingClientRect();
            
            const endLeft = containerRect.left + containerRect.width / 2;
            const endTop = containerRect.top + containerRect.height / 2;

            trophyElement.style.transition = 'left 0.75s ease-in-out, top 0.75s ease-in-out, transform 0.75s ease-in-out, filter 0.75s ease-in-out';
            
            // Start animation
            trophyElement.style.left = endLeft + 'px';
            trophyElement.style.top = endTop + 'px';
            trophyElement.style.transform = 'translate(-50%, -50%) scale(5)';
            trophyElement.style.filter = 'drop-shadow(0 0 30px gold) brightness(1.5)';

            // When animation is done, call victory
            createTimer(1200, () => {
                trophyElement.remove();
                victory();
            });
        }


        // Game Loop
        function startGameLoop() {
            function gameLoop() {
                const now = Date.now();
                const deltaTime = now - gameState.lastUpdate;
                gameState.lastUpdate = now;
                
                if (!gameState.isPaused && !gameState.isGameOver) {
                    const adjustedDelta = deltaTime * gameState.gameSpeed;

                    updateTimers(deltaTime);
                    updateCooldownVisuals();
                    moveZombies(deltaTime);
                    moveProjectiles(deltaTime);
                    updateLawnmowers(deltaTime);

                    // --- POTATO MINE EXPLOSION LOGIC ---
                    const minesToExplode = [];
                    gameState.plants.forEach(plant => {
                        if (plant.type === 'potatomine' && plant.isArmed && !plant.isArming) {
                            const triggeringZombie = gameState.zombies.find(zombie =>
                                !zombie.isFlying &&
                                zombie.row === plant.row &&
                                Math.floor(zombie.x / gameState.cellSize.width) === plant.col
                            );
                            if (triggeringZombie) {
                                minesToExplode.push(plant);
                            }
                        }
                    });

                    if (minesToExplode.length > 0) {
                        minesToExplode.forEach(mine => {
                            const zombiesToDamage = gameState.zombies.filter(zombie =>
                                zombie.row === mine.row && Math.floor(zombie.x / gameState.cellSize.width) === mine.col
                            );

                            if (mine.element) createParticleEffect(mine.element, 'üí•');

                            zombiesToDamage.forEach(zombie => {
                                zombie.health -= plantTypes.potatomine.damage;
                                updateZombieHealth(zombie);
                                if (zombie.element) {
                                    zombie.element.classList.add('damage-effect');
                                    createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); });
                                }
                                if (zombie.health <= 0) {
                                    handleZombieDefeat(zombie);
                                }
                            });

                            if (mine.element) mine.element.remove();
                            mine.element = null;
                        });

                        gameState.plants = gameState.plants.filter(p => p.element);
                        gameState.zombies = gameState.zombies.filter(z => z.element);
                    }
					
					// UPDATED: Logic to advance to the next wave
                    if (gameState.isSpawningComplete && gameState.zombies.length === 0 && !gameState.victoryTriggered) {
                        if (gameState.wave < gameState.maxWaves) {
                            gameState.isSpawningComplete = false; 

                            clearTimer(gameState.waveTimerId);

                            createTimer(2000, () => {
                                if (!gameState.isGameOver && !gameState.isVictory) {
                                    gameState.wave++;
                                    gameState.zombieDamageMultiplier = 1 + (gameState.wave - 1) * 0.02;
                                    updateWaveDisplay();
                                    updateDamageDisplay();
                                    addScore(100 * gameState.wave);
                                    saveGameState();
                                    spawnZombieWave();
                                }
                            });
                        }
                    }

                    gameState.plants.forEach(plant => {
                        if (!plant.element) return;
                        const plantType = plantTypes[plant.type];
                        
                        // Sun Production
                        if (plantType.produces === 'sun' || plantType.produces === 'coin') {
                             plant.sunCooldown -= adjustedDelta;
                             if (plant.sunCooldown <= 0) {
                                produceSun(plant);
                                const baseInterval = plantType.baseInterval || 24000;
                                plant.sunCooldown = (baseInterval - 2000) + (Math.random() * 4000);
                            }
                        }
                        
                        // Shooting
                        if (plantType.shoots) {
                            plant.shootCooldown -= adjustedDelta;
                            if (plant.shootCooldown <= 0) {
                                shoot(plant);
                            }
                        }

                        // Chomper Logic
                        if (plant.type === 'chomper') {
                            if (plant.isChewing) {
                                plant.chewTimer -= adjustedDelta;
                                if (plant.chewTimer <= 0) {
                                    plant.isChewing = false;
                                    if (plant.element) {
                                        plant.element.classList.remove('chewing');
                                    }
                                }
                            } else {
                                const targetZombie = gameState.zombies.find(zombie =>
                                    zombie.row === plant.row &&
                                    !zombie.isFlying &&
                                    zombie.element &&
                                    zombie.x < (plant.col + 2) * gameState.cellSize.width &&
                                    zombie.x > (plant.col - 0.5) * gameState.cellSize.width
                                );

                                if (targetZombie) {
                                    const zombieType = zombieTypes[targetZombie.type];
                                    if (zombieType.uneatable) {
                                        if (now - plant.lastChomp > plantType.attackInterval / gameState.gameSpeed) {
                                            plant.lastChomp = now;
                                            targetZombie.health -= plantType.damage;
                                            
                                            if (plant.element) {
                                                plant.element.classList.add('shooting');
                                                createTimer(300, () => { if (plant.element) plant.element.classList.remove('shooting'); });
                                            }

                                            if (targetZombie.element) {
                                                targetZombie.element.classList.add('damage-effect');
                                                createTimer(300, () => {
                                                    if (targetZombie.element) targetZombie.element.classList.remove('damage-effect');
                                                });
                                            }
                                            updateZombieHealth(targetZombie);
                                            if (targetZombie.health <= 0) {
                                                handleZombieDefeat(targetZombie);
                                            }
                                        }
                                    } else {
                                        targetZombie.health = 0; // Mark for defeat
                                        handleZombieDefeat(targetZombie, 'üòã');

                                        plant.isChewing = true;
                                        plant.chewTimer = plantType.chewTime;
                                        if (plant.element) {
                                            plant.element.classList.add('shooting');
                                            createTimer(300, () => { if (plant.element) plant.element.classList.remove('shooting'); });
                                            
                                            createTimer(750, () => {
                                                if (plant.element && plant.isChewing) {
                                                    plant.element.classList.add('chewing');
                                                }
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    gameState.plants = gameState.plants.filter(p => p.element);
                    
                    const debugInfo = document.getElementById('debugInfo');
                    if (debugInfo.style.display === 'block') {
                        debugInfo.innerHTML = `
                            Zombies: ${gameState.zombies.length}<br>
                            Plants: ${gameState.plants.length}<br>
                            Projectiles: ${gameState.projectiles.length}<br>
                            Graves: ${gameState.graves.length}<br>
                            Ice: ${gameState.iceTrails.length}<br>
                            Timers: ${Object.keys(gameState.timers).length}<br>
							Score: ${gameState.score}<br>
                            Wave: ${gameState.wave}/${gameState.maxWaves}<br>
                            Speed: x${gameState.gameSpeed}<br>
							Damage Mult: ${gameState.zombieDamageMultiplier.toFixed(2)}x<br>
                            FPS: ${Math.round(1000 / deltaTime)}
                        `;
                    }
                }
                
                gameState.gameLoopId = requestAnimationFrame(gameLoop);
            }
            
            gameState.gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Toggle Pause
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                // Actions on pause
                // Deselect zombie when pausing
                if (gameState.isZombieSpawnMode) {
                    gameState.selectedZombie = null;
                    document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                    document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
                }
            } else {
                // Actions on resume
                gameState.lastUpdate = Date.now(); // Prevents a large deltaTime jump
            }
            document.getElementById('pauseMenu').style.display = 
                gameState.isPaused ? 'block' : 'none';
            document.getElementById('pauseBtn').textContent = gameState.isPaused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
        }

        // Resume Game
        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
            gameState.lastUpdate = Date.now();
        }

        // Game Over - AUTO SAVE SCORE
        function gameOver() {
            if (gameState.isGameOver) return;
            
            gameState.isGameOver = true;
            
            // Auto-save score
            saveToLeaderboard(gameState.score, gameState.wave, gameState.zombiesDefeated);
            
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = gameState.score.toLocaleString();
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('finalZombies').textContent = gameState.zombiesDefeated;
        }

        // Custom Dialog System
        function showCustomDialog(title, message, buttons) {
            const dialog = document.getElementById('customDialog');
            const titleEl = document.getElementById('dialogTitle');
            const messageEl = document.getElementById('dialogMessage');
            const buttonsEl = document.getElementById('dialogButtons');

            titleEl.textContent = title;
            messageEl.textContent = message;
            buttonsEl.innerHTML = '';

            buttons.forEach(buttonInfo => {
                const button = document.createElement('button');
                button.textContent = buttonInfo.text;
                button.className = 'btn';
                if (buttonInfo.class) {
                    button.classList.add(buttonInfo.class);
                }

                button.addEventListener('click', () => {
                    hideCustomDialog();
                    if (buttonInfo.callback) {
                        buttonInfo.callback();
                    }
                });

                buttonsEl.appendChild(button);
            });

            dialog.style.display = 'flex';
        }

        function hideCustomDialog() {
            document.getElementById('customDialog').style.display = 'none';
        }

        function confirmRestart() {
            showCustomDialog(
                'Confirm Restart',
                'Are you sure you want to start a new game? Your current progress will be lost.',
                [
                    { text: 'Yes, Restart', class: 'secondary', callback: restartGame },
                    { text: 'No, Cancel' }
                ]
            );
        }

        // Restart Game
		function restartGame() {
			if (gameState.gameLoopId) {
				cancelAnimationFrame(gameState.gameLoopId);
			}
			resetGame();
			createBoard(); 
        
			// Only need to re-attach listeners to the newly created cells.
			setupGameBoardListeners(); 
        
			selectedPlantDeck = [];
			document.getElementById('selectedPlantCount').textContent = '0';
			showPlantSelectionScreen();
			togglePause();
		}

        // Toggle Fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                enterFullscreen();
            } else {
                const exitFS = document.exitFullscreen || 
                              document.webkitExitFullscreen || 
                              document.mozCancelFullScreen || 
                              document.msExitFullscreen;
                
                if (exitFS) {
                    exitFS.call(document).then(() => {
                        gameState.wasFullscreen = false;
                        localStorage.removeItem('pvz_fullscreen');
                        setTimeout(updateBoardDimensions, 100);
                    });
                }
            }
        }

        // Save Game State
        function saveGameState() {
            const saveData = {
                sun: gameState.sun,
                score: gameState.score,
                wave: gameState.wave,
                zombiesDefeated: gameState.zombiesDefeated,
                zombieDamageMultiplier: gameState.zombieDamageMultiplier
            };
            localStorage.setItem('pvz_gameState', JSON.stringify(saveData));
        }

        // Load Game State
        function loadGameState() {
            // Check if should restore fullscreen
            const shouldBeFullscreen = localStorage.getItem('pvz_fullscreen') === 'true';
            if (shouldBeFullscreen) {
                setTimeout(() => {
                    enterFullscreen();
                }, 100);
            }
            
            updateSunDisplay();
        }

        // Initialize game when page loads
        window.addEventListener('load', init);
        
        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && !gameState.isPaused && !gameState.isGameOver) {
                togglePause();
            } else if (!document.hidden && gameState.isPaused) {
                // When coming back, ensure lastUpdate is reset to avoid a time jump
                gameState.lastUpdate = Date.now();
            }
        });
    </script>
</body>
</html>
