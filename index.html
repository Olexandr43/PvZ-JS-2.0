<!DOCTYPE html>
<!-- MIT License
Copyright (c) 2025 Olexandr_43
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="Plants vs Zombies">
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <title>Plants vs Zombies</title>
    <style>
        /* --- ROOT & BODY --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        :root {
            --game-speed: 1;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Fullscreen mode adjustments */
        body:fullscreen #gameContainer,
        body:-webkit-full-screen #gameContainer,
        body:-moz-full-screen #gameContainer,
        body:-ms-fullscreen #gameContainer {
            max-width: 100%;
            max-height: 100%;
            border-radius: 0;
        }

        /* --- MAIN LAYOUT & CONTAINERS --- */
        #gameContainer {
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            max-height: 700px;
            position: relative;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 40%, #90EE90 40%, #228B22 100%);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
        }

        #gameBoard {
            position: absolute;
            top: 150px;
            left: 100px;
            right: 20px;
            bottom: 50px;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            background: rgba(0, 0, 0, 0.1);
            padding: 10px;
            border-radius: 10px;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 130px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 240, 240, 0.95));
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            gap: 10px;
            align-items: center;
            backdrop-filter: blur(10px);
            z-index: 30;
        }

        #leftPanel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 140px;
        }

        #plantSelection {
            display: flex;
            gap: 8px;
            flex: 1;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 5px;
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
        }

        #controlButtons {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 140px;
        }

        .controlRow {
            display: flex;
            gap: 5px;
        }

        #wave {
            position: absolute;
            bottom: 10px;
            right: 20px;
            font-size: 1.2em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(135deg, #FF6B6B, #FF8E53);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 29;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #zombieSpawner {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(50, 50, 50, 0.8);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            padding: 10px;
            gap: 10px;
            z-index: 200;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
        }

        #debugInfo {
            position: absolute;
            z-index: 999999;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 0.8em;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            display: none;
            width: 200px;
            font-family: monospace;
        }

        #fpsGraph {
            width: 100%;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            margin-top: 5px;
        }

        /* --- GAME BOARD ELEMENTS --- */
        .cell {
            background: linear-gradient(135deg, rgba(144, 238, 144, 0.3), rgba(34, 139, 34, 0.3));
            border: 2px solid rgba(34, 139, 34, 0.5);
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
        }

        .cell:hover {
            background: rgba(144, 238, 144, 0.5);
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .cell.crater {
            background: radial-gradient(circle, #3b2a1a 0%, #5c422a 50%, #2e1e10 100%);
            border: 2px solid #1a1a1a;
            cursor: not-allowed;
            pointer-events: none;
        }

        .cell.crater::after {
            content: 'ðŸ”¥';
            position: absolute;
            font-size: 1.5em;
            opacity: 0.3;
            animation: smoke calc(3s / var(--game-speed)) infinite alternate;
        }

        .cell.iced {
            background: linear-gradient(135deg, rgba(173, 216, 230, 0.8), rgba(100, 149, 237, 0.8));
            border: 2px solid rgba(173, 216, 230, 1);
            cursor: not-allowed;
            pointer-events: none;
            animation: iceGlimmer calc(2s / var(--game-speed)) infinite alternate;
        }

        .cell.grave {
            cursor: not-allowed;
            position: relative;
        }

        .cell.grave::before {
            content: 'âš°ï¸';
            font-size: 2.5em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .cell.grave.grave-spawn::before {
            animation: graveRise calc(0.5s / var(--game-speed)) ease-out;
        }

        #gameBoard:not(.shovel-mode) .cell.grave {
            cursor: pointer;
        }

        #gameBoard:not(.shovel-mode) .cell.grave:hover {
            background: rgba(144, 238, 144, 0.5);
        }

        .lawnmower {
            position: absolute;
            font-size: 2.5em;
            z-index: 3;
            will-change: left;
            transform: scaleX(-1);
            /* Face right */
        }


        /* --- PLANTS --- */
        .plant {
            font-size: 2.5em;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
            z-index: 2;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .plant.plant-spawn {
            animation: plantGrow calc(0.5s / var(--game-speed)) ease;
        }

        .plant.sleeping {
            opacity: 0.6;
            filter: grayscale(50%) drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        .plant.sleeping::after {
            content: 'Zzz';
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 0.5em;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            animation: sleepAnimation calc(2.5s / var(--game-speed)) infinite ease-in-out;
        }

        .plant.spike-plant {
            z-index: 1;
            transform: translate(-50%, -25%);
        }

        .plant.imitated {
            filter: grayscale(100%) drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }

        .plant-octopus-overlay {
            position: absolute;
            font-size: 1.2em;
            z-index: 3;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.9;
            pointer-events: none;
            animation: plantGrow calc(0.3s / var(--game-speed)) ease;
        }

        .flying-octopus {
            position: fixed;
            font-size: 1.5em;
            z-index: 6;
            pointer-events: none;
            filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.4));
            will-change: left, top;
        }

        .plant.arming {
            transform: translate(-50%, -50%) scale(0.6);
            opacity: 0.7;
            transition: transform calc(0.3s / var(--game-speed)) ease, opacity calc(0.3s / var(--game-speed)) ease;
        }

        .plant.armed {
            animation: mineArm calc(0.3s / var(--game-speed)) ease-out;
        }

        .plant.activating {
            animation: plantActivatePulse calc(0.4s / var(--game-speed)) infinite alternate ease-in-out;
        }

        .plant.shooting {
            animation: shootAnimation calc(0.3s / var(--game-speed)) ease;
        }

        .plant.chewing {
            animation: chewAnimation calc(1s / var(--game-speed)) infinite ease-in-out;
        }

        .plant.eating-grave {
            animation: eatGraveAnimation calc(0.5s / var(--game-speed)) infinite ease-in-out;
        }

        .plant-health-bar {
            position: absolute;
            width: 40px;
            height: 3px;
            background: rgba(0, 0, 0, 0.3);
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            overflow: hidden;
        }

        .plant-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width calc(0.3s / var(--game-speed)) ease;
            box-shadow: 0 0 3px rgba(76, 175, 80, 0.5);
        }

        .plant-damage-effect {
            animation: plantDamage calc(0.3s / var(--game-speed)) ease;
        }

        .plant.spike-plant.plant-damage-effect {
            animation: plantSpikeDamage calc(0.3s / var(--game-speed)) ease;
        }

        .plant.arming.plant-damage-effect {
            animation: plantArmedDamage calc(0.3s / var(--game-speed)) ease;
        }

        /* --- ZOMBIES --- */
        .zombie {
            position: absolute;
            font-size: 2.5em;
            z-index: 3;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
            transition: filter calc(0.3s / var(--game-speed)) ease;
            will-change: transform;
            transform: scaleX(-1);
            pointer-events: none;
        }

        .zombie-attachment,
        .zombie-card-attachment {
            position: absolute;
            transform: scaleX(-1);
            /* Un-flip the attachment */
            font-size: 0.65em;
            z-index: 1;
            pointer-events: none;
        }

        .zombie.dancing {
            animation: moonwalk calc(1s / var(--game-speed)) infinite alternate ease-in-out;
        }

        .zombie.dancing.eating {
            animation: zombieEat calc(0.5s / var(--game-speed)) infinite;
        }

        .zombie.zombie-throwing {
            animation: zombieThrow calc(1s / var(--game-speed)) ease-in-out;
        }

        .zombie.enraged {
            filter: drop-shadow(2px 2px 4px rgba(255, 0, 0, 0.7)) hue-rotate(-25deg) brightness(1.3);
        }

        .zombie.zomboni {
            font-size: 3.35em;
        }

        .zombie.gargantuar {
            font-size: 3.5em;
        }

        .zombie.imp {
            font-size: 2em;
        }

        .zombie.frozen {
            filter: drop-shadow(2px 2px 8px rgba(173, 216, 230, 0.9)) brightness(1.4) saturate(0);
            animation: frozenWiggle calc(0.5s / var(--game-speed)) infinite ease-in-out;
        }

        .zombie.jackInTheBox {
            animation: winding-up calc(0.7s / var(--game-speed)) infinite ease-in-out;
        }

        .zombie.stunned::after {
            content: 'ðŸ§ˆ';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2em;
            z-index: 2;
        }

        .zombie.slowed {
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5)) hue-rotate(200deg) brightness(1.5);
        }

        .zombie.eating {
            animation: zombieEat calc(0.5s / var(--game-speed)) infinite;
        }

        .zombie-health-bar {
            position: absolute;
            width: 40px;
            height: 4px;
            background: rgba(255, 0, 0, 0.8);
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            overflow: hidden;
            z-index: 3;
        }

        .zombie-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width calc(0.3s / var(--game-speed)) ease;
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
        }

        .zombie.damage-effect {
            animation: damage calc(0.3s / var(--game-speed)) ease;
        }

        .zombie.gargantuar-throwing {
            animation: gargantuarThrow calc(1s / var(--game-speed)) ease-in-out;
        }

        .flying-imp {
            position: fixed;
            font-size: 2em;
            z-index: 5;
            pointer-events: none;
            will-change: transform;
            transform: scaleX(-1);
            animation-name: impThrowArc;
            animation-duration: calc(0.7s / var(--game-speed));
            animation-timing-function: ease-out;
        }


        /* --- PROJECTILES & PARTICLES --- */
        .projectile {
            position: absolute;
            font-size: 1.5em;
            z-index: 4;
            filter: drop-shadow(0 0 5px rgba(255, 255, 0, 0.8));
            will-change: transform;
            pointer-events: none;
        }

        .projectile.fire {
            filter: drop-shadow(0 0 10px rgba(255, 100, 0, 1));
            animation: fireGlow calc(0.3s / var(--game-speed)) infinite alternate;
        }

        .sun {
            position: absolute;
            font-size: 2em;
            cursor: pointer;
            z-index: 5;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));
            transition: transform calc(0.3s / var(--game-speed)) ease, filter calc(0.3s / var(--game-speed)) ease;
            display: flex;
            align-items: center;
            gap: 5px;
            will-change: transform, opacity, top, left;
        }

        .sun:hover {
            transform: scale(1.2);
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 1));
        }

        .sun-value {
            font-size: 0.6em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .particle {
            position: absolute;
            pointer-events: none;
            animation: particle calc(1s / var(--game-speed)) ease-out forwards;
            font-size: 1.5em;
            z-index: 10;
        }

        /* --- UI --- */
        .plantCard {
            min-width: 70px;
            width: 70px;
            height: 95px;
            background: linear-gradient(135deg, #fff, #f0f0f0);
            border: 3px solid #4CAF50;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .plantCard:hover {
            transform: translateY(-5px) scale(1.05);
            border-color: #45a049;
        }

        .plantCard::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s ease;
            opacity: 0;
        }

        .plantCard:hover::before {
            animation: shine calc(0.5s / var(--game-speed)) ease;
        }

        .plantCard.selected {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            transform: scale(1.1);
        }

        .plantCard.imitated {
            filter: grayscale(1);
        }

        .plantCard.imitated.selected {
            filter: grayscale(0.5);
        }

        .plantCard[data-upgrade="true"] {
            border-color: #9b59b6;
            background: linear-gradient(135deg, #e8daef, #d5b4e0);
        }

        .plantCard[data-upgrade="true"].selected {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
        }

        .plantCard.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        .plantCard.imitated.disabled {
            filter: grayscale(1) opacity(0.5);
        }

        .plantCard.on-cooldown {
            cursor: not-allowed;
            filter: grayscale(80%);
            opacity: 0.7;
        }

        .plantCard.imitated.on-cooldown {
            filter: grayscale(1) opacity(0.7);
        }

        .plantCard .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0;
            background: rgba(25, 25, 25, 0.7);
            z-index: 1;
            pointer-events: none;
            border-radius: 0 0 9px 9px;
        }

        .plantCard .emoji,
        .plantCard .cost,
        .plantCard .name {
            position: relative;
            z-index: 2;
        }

        .plantCard .emoji {
            font-size: 1.6em;
            margin-bottom: 2px;
        }

        .plantCard .cost {
            font-size: 0.75em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .plantCard .name {
            font-size: 0.55em;
            color: #333;
            text-align: center;
        }

        #shovelCard {
            background: linear-gradient(135deg, #c0c0c0, #a9a9a9);
            border-color: #808080;
        }

        #shovelCard.selected {
            background: linear-gradient(135deg, #A9A9A9, #808080);
            border-color: #696969;
        }

        .zombieCard {
            min-width: 70px;
            width: 70px;
            height: 95px;
            background: linear-gradient(135deg, #f0f0f0, #ddd);
            border: 3px solid #b22222;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .zombieCard:hover {
            transform: translateY(-5px) scale(1.05);
            border-color: #ff0000;
        }

        .zombieCard.selected {
            background: linear-gradient(135deg, #b22222, #8b0000);
            transform: scale(1.1);
        }

        .zombieCard .name {
            font-size: 0.6em;
            color: #333;
            text-align: center;
            font-weight: bold;
            margin-top: 2px;
        }

        .zombieCard.selected .name {
            color: white;
        }

        #sunCounter,
        #scoreCounter {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1em;
            font-weight: bold;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
            transition: transform 0.1s ease;
        }

        #sunCounter {
            background: linear-gradient(135deg, #FFD700, #FFA500);
        }

        #scoreCounter {
            background: linear-gradient(135deg, #9C27B0, #E91E63);
        }

        .controlBtn {
            padding: 8px 12px;
            font-size: 1em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            flex: 1;
        }

        .controlBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .controlBtn.active {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .btn {
            padding: 12px 25px;
            margin: 8px;
            font-size: 1em;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .btn.restart {
            background: linear-gradient(135deg, #FF9800, #FB8C00);
        }

        .btn.gold {
            margin: 0px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
        }

        .btn.letsrock {
            margin: 0px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            width: 220px;
            padding: 12px 20px;
            font-size: 1.3em;
            box-shadow: 0 8px 15px rgba(255, 215, 0, 0.25);
            transition: all 0.3s ease;
        }

        .btn.savegame {
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        #plantSelection::-webkit-scrollbar,
        #zombieSpawner::-webkit-scrollbar {
            height: 6px;
        }

        #plantSelection::-webkit-scrollbar-track,
        #zombieSpawner::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        #plantSelection::-webkit-scrollbar-thumb,
        #zombieSpawner::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        /* --- GAME STATE & MODE --- */
        #gameContainer.night-mode #nightOverlay {
            display: block;
        }

        #gameBoard.shovel-mode .cell {
            cursor: crosshair;
        }

        #gameBoard.shovel-mode .cell:hover,
        #gameBoard.zombie-spawn-mode .cell:hover {
            background: rgba(255, 0, 0, 0.3);
            outline: 2px solid red;
        }

        #gameBoard.zombie-spawn-mode .cell {
            cursor: crosshair;
        }

        #wave.final-wave {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            animation: pulse calc(1s / var(--game-speed)) infinite;
        }

        #wave .damage-bonus {
            font-size: 0.7em;
            margin-top: 3px;
            opacity: 0.9;
            display: none;
        }

        /* --- OVERLAYS, SCREENS & POPUPS --- */
        #modalOverlay {
            display: none;
            /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 999;
            backdrop-filter: blur(2px);
        }

        #nightOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 50, 0.4);
            pointer-events: none;
            z-index: 25;
            display: none;
        }

        #gameOver,
        #pauseMenu,
        #leaderboard,
        #victoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(240, 240, 240, 0.98));
            padding: 20px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            display: none;
            max-width: 500px;
            width: 90%;
        }

        #leaderboard {
            z-index: 1000;
            max-height: 70vh;
            overflow-y: auto;
        }

        #gameOver,
        #pauseMenu,
        #victoryScreen {
            z-index: 100;
        }

        #gameOver h2,
        #pauseMenu h2,
        #leaderboard h2,
        #victoryScreen h2 {
            font-size: 2.2em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #victoryScreen h2 {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(240, 240, 240, 0.8));
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        .leaderboard-entry:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .leaderboard-entry.gold {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            font-weight: bold;
        }

        .leaderboard-entry.silver {
            background: linear-gradient(135deg, #C0C0C0, #A0A0A0);
            color: white;
            font-weight: bold;
        }

        .leaderboard-entry.bronze {
            background: linear-gradient(135deg, #CD7F32, #B87333);
            color: white;
            font-weight: bold;
        }

        .leaderboard-rank {
            font-size: 1.2em;
            font-weight: bold;
            min-width: 30px;
        }

        .leaderboard-datetime {
            flex: 1;
            text-align: left;
            margin: 0 15px;
            display: flex;
            flex-direction: column;
        }

        .leaderboard-date {
            font-size: 0.9em;
        }

        .leaderboard-time {
            font-size: 0.75em;
            opacity: 0.8;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #764ba2;
        }

        .leaderboard-entry.gold .leaderboard-score,
        .leaderboard-entry.silver .leaderboard-score,
        .leaderboard-entry.bronze .leaderboard-score {
            color: rgba(255, 255, 255, 0.9);
        }

        .almanac-card {
            background: linear-gradient(135deg, #4a4a4a, #333333);
            border: 2px solid #222;
            border-radius: 15px;
            padding: 15px;
            color: #f0f0f0;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), 0 5px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            position: relative;
        }

        .almanac-card:not(.hidden):hover {
            transform: translateY(-5px);
            background: linear-gradient(135deg, #5a5a5a, #404040);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        .almanac-visual {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }

        .almanac-details {
            flex-grow: 1;
        }

        .almanac-name {
            font-family: 'Segoe UI Black', Impact, sans-serif;
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 5px;
            color: #d4cba7;
            text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);
        }

        .almanac-stats {
            width: 100%;
            font-size: 0.8em;
            margin-bottom: 8px;
        }

        .almanac-stats div {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .almanac-stats div:last-child {
            border-bottom: none;
        }

        .almanac-stats span:first-child {
            font-weight: bold;
            opacity: 0.8;
        }

        .almanac-desc {
            font-size: 0.8em;
            line-height: 1.4;
            opacity: 0.9;
        }

        .almanac-health-bar {
            width: 100%;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            border: 1px solid rgba(0, 0, 0, 0.7);
            overflow: hidden;
            margin-top: 4px;
        }

        .almanac-health-fill {
            height: 100%;
            border-radius: 4px;
            box-shadow: inset 0 -1px 2px rgba(0, 0, 0, 0.3);
            transition: width 0.5s ease-in-out;
        }

        .almanac-health-fill.low {
            background: linear-gradient(to right, #8BC34A, #4CAF50);
        }

        .almanac-health-fill.medium {
            background: linear-gradient(to right, #FFD700, #FFA500);
        }

        .almanac-health-fill.high {
            background: linear-gradient(to right, #ff6600, #ff0000);
        }

        .almanac-health-fill.extreme {
            background: linear-gradient(to right, #E91E63, #9C27B0);
        }

        .stats {
            margin: 20px 0;
            font-size: 1.1em;
            color: #333;
        }

        #almanacScreen {
            padding: 15px;
        }

        #almanacContent {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 950px;
            height: calc(100% - 100px);
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 15px;
        }

        #almanacZombieList {
            flex-basis: 45%;
            flex-shrink: 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        #almanacZombieList::-webkit-scrollbar {
            width: 8px;
        }

        #almanacZombieList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #almanacZombieList::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .almanac-icon-card {
            aspect-ratio: 1 / 1;
            background: linear-gradient(135deg, #4a4a4a, #333333);
            border: 2px solid #222;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 5px;
        }

        .almanac-icon-card:hover {
            background: linear-gradient(135deg, #5a5a5a, #404040);
            border-color: #555;
        }

        .almanac-icon-card.selected {
            border-color: #d4cba7;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(212, 203, 167, 0.5);
        }

        .almanac-icon-card.hidden .almanac-visual {
            filter: brightness(0);
            opacity: 0.5;
        }

        .almanac-icon-card .almanac-visual {
            transform: scale(0.9);
        }

        #almanacZombieDetails {
            flex-basis: 55%;
            display: none;
            /* Initially hidden */
            flex-direction: column;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #4a4a4a, #333333);
            border: 2px solid #222;
            border-radius: 15px;
            padding: 20px;
            color: #f0f0f0;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }

        #almanacZombieDetails .almanac-visual {
            width: 150px;
            height: 150px;
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        #almanacZombieDetails .almanac-name {
            font-size: 1.8em;
        }

        #almanacDetailContent {
            width: 100%;
            text-align: left;
        }

        #almanacDetailContent .almanac-stats {
            font-size: 0.9em;
            margin: 15px 0;
        }

        #almanacDetailContent .almanac-desc {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 1.5;
            margin-top: 20px;
        }

        .challenges-box {
            max-width: 550px;
            text-align: left;
        }

        .challenges-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 50vh;
            overflow-y: auto;
            padding-right: 10px;
        }

        .challenge-toggle {
            background: rgba(0, 0, 0, 0.05);
            padding: 12px 15px;
            border-radius: 10px;
            border-left: 5px solid transparent;
            transition: all 0.3s ease;
        }

        .challenge-toggle:has(input:checked) {
            border-left-color: #764ba2;
            background: rgba(118, 75, 162, 0.1);
        }

        .challenge-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }

        .challenge-toggle input[type="checkbox"] {
            display: none;
        }

        .challenge-toggle label span::before {
            content: '';
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            border: 2px solid #ccc;
            border-radius: 5px;
            margin-right: 15px;
            background-color: white;
            transition: all 0.2s ease;
            color: white;
            content: 'âœ”';
            font-size: 18px;
        }

        .challenge-toggle input:checked+span::before {
            background-color: #764ba2;
            border-color: #6a4291;
        }

        .challenge-toggle:has(input:checked) p {
            color: #764ba2;
        }

        .challenge-toggle p {
            font-size: 0.9em;
            color: #777;
            margin-left: 41px;
            margin-top: 3px;
            line-height: 1.4;
            transition: color 0.3s ease;
        }

        .points-popup {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 31;
            pointer-events: none;
            animation: pointsFloat calc(1.5s / var(--game-speed)) ease-out forwards;
        }

        .save-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 200;
            animation: saveNotification calc(2s / var(--game-speed)) ease forwards;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        #plantSelectionScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            z-index: 150;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            color: white;
        }

        #mapChooser {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .mapOption {
            padding: 4px 7px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .mapOption:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mapOption.active {
            background: #FFD700;
            color: #333;
            border-color: #FFA500;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        #deckContainer {
            width: 100%;
            text-align: center;
        }

        #deckContainer h2 {
            font-size: 2.2em;
            text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }

        #deckBar {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-start;
            height: 130px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            overflow-x: auto;
            flex-wrap: nowrap;
        }

        #deckBar .plantCard {
            opacity: 1;
            transition: opacity 0.2s ease-in;
        }

        #deckBar .plantCard.hiding {
            opacity: 0;
            pointer-events: none;
        }

        #plantLibrary {
            max-width: 950px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            flex-grow: 1;
            overflow-y: auto;
        }

        #plantLibraryGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 10px;
            max-width: calc(8 * 70px + 7 * 10px);
            margin: 0 auto;
        }

        #plantLibrary .plantCard {
            transition: opacity 0.3s ease, filter 0.3s ease;
        }

        #plantLibrary .plantCard.in-library-hidden {
            opacity: 0.4;
            pointer-events: none;
            filter: grayscale(80%);
        }

        .plant-card-clone {
            position: fixed;
            z-index: 2000;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #plantSelectionFooter {
            text-align: center;
            width: 100%;
            position: relative;
        }

        #plantSelectionFooter>div:first-child {
            position: absolute;
            left: 25px;
        }

        #selectedPlantCount {
            font-size: 1.2em;
            font-weight: bold;
        }

        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 15px;
        }

        .dialog-box {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(240, 240, 240, 0.98));
            padding: 20px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 450px;
            animation: dialogAppear calc(0.3s / var(--game-speed)) ease-out;
        }

        .dialog-box h2 {
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #333;
        }

        .dialog-box p {
            font-size: 1.1em;
            margin-bottom: 20px;
            color: #555;
            line-height: 1.6;
        }

        #landscapeMessage {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            z-index: 2000;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        #landscapeMessage h2 {
            font-size: 2em;
            margin-bottom: 20px;
        }

        #landscapeMessage p {
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .plant-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            line-height: 1.4;
            max-width: 200px;
            text-align: center;
            z-index: 3000;
            pointer-events: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .plant-tooltip.visible {
            opacity: 1;
            transform: scale(1);
        }

        .plant-tooltip::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
        }

        .plant-tooltip.bottom::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 6px 6px 6px;
            border-color: transparent transparent rgba(0, 0, 0, 0.85) transparent;
        }

        .plant-tooltip.top::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 6px 6px 0 6px;
            border-color: rgba(0, 0, 0, 0.85) transparent transparent transparent;
        }

        #slotListContainer {
            max-height: 45vh;
            overflow-y: auto;
            padding: 5px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slot-entry {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .slot-button {
            flex-grow: 1;
            text-align: left !important;
            padding: 12px 15px !important;
        }

        .delete-slot-btn {
            flex-shrink: 0;
            padding: 12px 15px !important;
            font-size: 1.1em;
            background: linear-gradient(135deg, #FF6B6B, #E91E63) !important;
        }

        .delete-slot-btn:disabled {
            background: #ccc !important;
            opacity: 0.5;
            cursor: not-allowed;
        }

        #slotListContainer::-webkit-scrollbar {
            width: 8px;
        }

        #slotListContainer::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        #slotListContainer::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
        }

        /* --- ANIMATIONS --- */
        @keyframes iceGlimmer {
            from {
                box-shadow: 0 0 2px rgba(255, 255, 255, 0);
            }

            to {
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
            }
        }

        @keyframes smoke {
            from {
                transform: translateY(0) scale(1);
                opacity: 0.3;
            }

            to {
                transform: translateY(-10px) scale(1.2);
                opacity: 0.1;
            }
        }

        @keyframes graveRise {
            0% {
                transform: translate(-50%, -30%) scale(0.8);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }
        }

        @keyframes plantGrow {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(0deg);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(10deg);
            }

            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
        }

        @keyframes sleepAnimation {

            0%,
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            50% {
                transform: translateY(-5px) scale(1.1);
                opacity: 0.7;
            }
        }

        @keyframes mineArm {
            0% {
                transform: translate(-50%, -50%) scale(0.6);
            }

            50% {
                transform: translate(-50%, -60%) scale(1.2);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes shootAnimation {
            0% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.2);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes chewAnimation {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1) rotate(5deg);
            }
        }

        @keyframes eatGraveAnimation {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(-2deg);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.15) rotate(2deg);
            }
        }

        @keyframes moonwalk {
            0% {
                transform: scaleX(-1) translateX(-5px);
            }

            100% {
                transform: scaleX(-1) translateX(5px);
            }
        }

        @keyframes winding-up {

            0%,
            100% {
                transform: scaleX(-1) rotate(-2deg);
            }

            50% {
                transform: scaleX(-1) rotate(2deg);
            }
        }

        @keyframes frozenWiggle {

            0%,
            100% {
                transform: scaleX(-1) rotate(-1deg);
            }

            50% {
                transform: scaleX(-1) rotate(1deg);
            }
        }

        @keyframes zombieEat {

            0%,
            100% {
                transform: scaleX(-1) translateY(0);
            }

            50% {
                transform: scaleX(-1) translateY(-5px);
            }
        }

        @keyframes fireGlow {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.2);
            }
        }

        @keyframes windBlow {
            0% {
                transform: translateX(0) scale(1);
                opacity: 0.7;
            }

            100% {
                transform: translateX(1000px) scale(1.5);
                opacity: 0;
            }
        }

        @keyframes shine {
            0% {
                transform: translateX(-100%) translateY(-100%) rotate(45deg);
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                transform: translateX(100%) translateY(100%) rotate(45deg);
                opacity: 0;
            }
        }

        @keyframes pointsFloat {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        @keyframes damage {

            0%,
            100% {
                transform: scaleX(-1);
                filter: brightness(1);
            }

            50% {
                transform: scaleX(-1) scale(0.9);
                filter: brightness(1.5) hue-rotate(180deg);
            }
        }

        @keyframes plantDamage {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
                filter: brightness(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(0.9);
                filter: brightness(1.5) hue-rotate(90deg);
            }
        }

        @keyframes plantArmedDamage {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(0.6);
                filter: brightness(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(0.5);
                filter: brightness(1.5) hue-rotate(90deg);
            }
        }

        @keyframes plantSpikeDamage {

            0%,
            100% {
                transform: translate(-50%, -25%) scale(1);
                filter: brightness(1);
            }

            50% {
                transform: translate(-50%, -25%) scale(0.9);
                filter: brightness(1.5) hue-rotate(90deg);
            }
        }

        @keyframes collect {
            0% {
                transform: scale(1) rotate(0deg);
            }

            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes freezeFlash {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0.8;
            }

            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.5;
            }

            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }

        @keyframes particle {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(var(--x), var(--y)) scale(0);
                opacity: 0;
            }
        }

        @keyframes saveNotification {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }

            40% {
                transform: translate(-50%, -50%) scale(1);
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        @keyframes dialogAppear {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes gargantuarThrow {
            0% {
                transform: scaleX(-1) rotate(0deg);
            }

            40% {
                transform: scaleX(-1) rotate(-15deg) translateY(-10px);
            }

            80% {
                transform: scaleX(-1) rotate(10deg);
            }

            100% {
                transform: scaleX(-1) rotate(0deg);
            }
        }

        @keyframes impThrowArc {
            0% {
                transform: scaleX(1) translate(0, 0) scale(0.5) rotate(0deg);
                opacity: 1;
            }

            50% {
                transform: scaleX(1) translate(-100px, -80px) scale(1) rotate(360deg);
            }

            100% {
                transform: scaleX(1) translate(-200px, 0) scale(0.8) rotate(720deg);
                opacity: 0;
            }
        }

        @keyframes zombieThrow {
            0% {
                transform: scaleX(-1) rotate(0deg);
            }

            40% {
                transform: scaleX(-1) rotate(-10deg) translateY(-5px);
            }

            80% {
                transform: scaleX(-1) rotate(5deg);
            }

            100% {
                transform: scaleX(-1) rotate(0deg);
            }
        }

        @keyframes plantActivatePulse {
            from {
                transform: translate(-50%, -50%) scale(1);
                filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3)) brightness(1);
            }

            to {
                transform: translate(-50%, -50%) scale(1.15);
                filter: drop-shadow(2px 2px 8px rgba(255, 0, 0, 0.5)) brightness(1.2);
            }
        }

        /* --- MOBILE --- */
        @media (orientation: portrait) and (max-width: 768px) {
            #landscapeMessage {
                display: flex;
            }

            #gameContainer {
                display: none;
            }
        }

        @media (orientation: landscape) and (max-height: 600px) {
            #ui {
                height: 100px;
            }

            #gameBoard {
                top: 110px;
                bottom: 20px;
            }

            #wave {
                bottom: 5px;
                right: 10px;
                font-size: 1em;
                padding: 8px 15px;
            }

            .plant,
            .zombie {
                font-size: 2em;
            }

            .zombie-attachment,
            .zombie-card-attachment {
                position: absolute;
                transform: scaleX(-1) translateX(-2px) translateY(3px);
            }

            .zombie.zomboni {
                font-size: 2.85em;
            }

            .zombie.gargantuar {
                font-size: 3em;
            }

            .zombie.imp {
                font-size: 1.5em;
            }

            .plantCard {
                min-width: 60px;
                width: 60px;
                height: 80px;
            }

            .zombieCard {
                min-width: 60px;
                width: 60px;
                height: 80px;
            }

            .plantCard .emoji {
                font-size: 1.3em;
            }

            .controlBtn {
                padding: 5px 8px;
                font-size: 0.85em;
            }

            #sunCounter,
            #scoreCounter {
                font-size: 0.95em;
                padding: 6px 12px;
            }

            #deckBar {
                height: 100px;
                padding: 8px;
            }

            #deckBar .plantCard {
                min-width: 60px;
                width: 60px;
                height: 80px;
            }

            #deckBar .plantCard .emoji {
                font-size: 1.4em;
            }

            #plantLibrary {
                padding: 10px;
            }

            .dialog-box h2 {
                font-size: 1.2em;
                margin-bottom: 12px;
            }

            .dialog-box p {
                font-size: 0.9em;
                margin-bottom: 7px;
                line-height: 1;
            }

            .dialog-overlay {
                padding: 10px;
            }

            .btn.letsrock {
                width: 180px;
                padding: 10px 15px;
                font-size: 1.2em;
            }

            .projectile {
                font-size: 1.2em;
            }

            #almanacScreen {
                padding: 10px;
            }

            #almanacZombieDetails .almanac-visual {
                width: 100px;
                height: 100px;
            }

            #almanacZombieDetails .almanac-name {
                font-size: 1.5em;
            }

            .almanac-icon-card {
                border: 3px solid #222;
                width: 70px;
                height: 70px;
            }

            #almanacZombieList {
                grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            }
        }

        @media (max-width: 768px) {
            #gameBoard {
                left: 10px;
                right: 10px;
                top: 140px;
            }

            .plantCard {
                min-width: 60px;
                width: 60px;
                height: 80px;
            }

            .zombieCard {
                min-width: 60px;
                width: 60px;
                height: 80px;
            }

            .plantCard .emoji {
                font-size: 1.4em;
            }

            .plant,
            .zombie {
                font-size: 2em;
            }

            #ui {
                padding: 8px;
                gap: 8px;
            }

            #leftPanel,
            #controlButtons {
                min-width: 120px;
            }

            .controlBtn {
                font-size: 0.9em;
                padding: 6px 10px;
            }
        }

        .zombie,
        .projectile,
        .lawnmower,
        .sun,
        .flying-imp,
        .flying-octopus {
            will-change: top, left, transform;
            /* transform: translateZ(0); */
            backface-visibility: hidden;
        }

        /* --- PERFORMANCE MODE TOGGLE --- */

        /* 1. Game Entities */
        body.performance-mode .zombie,
        body.performance-mode .plant,
        body.performance-mode .projectile,
        body.performance-mode .sun,
        body.performance-mode .lawnmower,
        body.performance-mode .particle,
        body.performance-mode .cell,
        body.performance-mode .cell:hover,
        body.performance-mode .zombie-health-fill,
        body.performance-mode .plant-health-fill,
        body.performance-mode .instant-effect,
        body.performance-mode .flying-imp,
        body.performance-mode .flying-octopus {
            filter: none !important;
            box-shadow: none !important;
            text-shadow: none !important;
        }

        /* 2. UI Elements */
        body.performance-mode #ui,
        body.performance-mode #zombieSpawner,
        body.performance-mode #pauseMenu,
        body.performance-mode #gameOver,
        body.performance-mode #victoryScreen,
        body.performance-mode .dialog-box,
        body.performance-mode .plantCard,
        body.performance-mode .plantCard.on-cooldown,
        body.performance-mode .zombieCard {
            filter: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
        }

        /* 3. Remove the main container shadow */
        body.performance-mode #gameContainer {
            box-shadow: none !important;
        }

        /* 4. Visual Fixes */
        body.performance-mode .zombie.frozen {
            background-color: rgba(135, 206, 235, 0.6) !important;
            border-radius: 50% !important;
        }

        body.performance-mode .zombie.slowed {
            background-color: rgba(0, 0, 255, 0.2) !important;
            border-radius: 20% !important;
        }

        body.performance-mode .zombie.damage-effect,
        body.performance-mode .plant.plant-damage-effect {
            animation: none !important;
            background-color: rgba(255, 0, 0, 0.5) !important;
            border-radius: 20% !important;
        }

        body.performance-mode .plant.imitated {
            background-color: rgba(200, 200, 200, 0.4) !important;
            border-radius: 10px !important;
        }

        body.performance-mode .zombie.enraged {
            background-color: rgba(235, 35, 152, 0.4) !important;
            border-radius: 20% !important;
        }

        body.performance-mode .plantCard.on-cooldown {
            opacity: 0.5 !important;
        }
    </style>
</head>

<body>
    <div id="landscapeMessage">
        <h2>ðŸ“± Rotate Your Device</h2>
        <p>Please rotate your device to landscape mode for the best gaming experience!</p>
        <div style="font-size: 4em;">â†»</div>
    </div>

    <div id="gameContainer">
        <div id="modalOverlay"></div>
        <div id="nightOverlay"></div>

        <div id="plantSelectionScreen" style="display: none;">
            <div id="mapChooser">
                <div class="mapOption active" data-map="day">â˜€ï¸ Day</div>
                <div class="mapOption" data-map="night">ðŸŒ™ Night</div>
            </div>

            <div id="deckContainer">
                <h2>Choose Your Plants</h2>
                <div id="deckBar">
                    <!-- Selected plants go here -->
                </div>
            </div>

            <div id="plantLibrary">
                <div id="plantLibraryGrid">
                    <!-- All available plants go here -->
                </div>
            </div>

            <div id="plantSelectionFooter">
                <div style="margin-bottom: 15px;">
                    Selected: <span id="selectedPlantCount">0</span>
                    <button class="btn secondary" id="almanacBtn" style="margin: 0; padding: 8px 15px;">ðŸ“–</button>
                    <button class="btn secondary" id="leaderBtn" style="margin: 0; padding: 8px 15px;">ðŸ†</button>
                    <button class="btn secondary" id="challengesBtn" style="margin: 0; padding: 8px 15px;">âš™ï¸</button>
                </div>

                <button id="startGameBtn" class="btn letsrock">Let's Rock!</button>

                <button id="loadGameBtn" class="btn secondary"
                    style="display: none; position: absolute; right: 25px; bottom: 0;">ðŸ”„ Load Game</button>
            </div>
        </div>

        <div id="ui" style="visibility: hidden;">
            <div id="leftPanel">
                <div id="sunCounter">â˜€ï¸ <span id="sunCount">200</span></div>
                <div id="scoreCounter">â­ <span id="scoreCount">0</span></div>
            </div>

            <div id="plantSelection">
                <!-- Selected plant cards will be populated here -->
            </div>

            <div id="controlButtons">
                <div class="controlRow">
                    <button class="controlBtn" id="pauseBtn">â¸ï¸ Pause</button>
                    <button class="controlBtn" id="speedBtn">âš¡ x1</button>
                </div>
                <div class="controlRow">
                    <button class="controlBtn" id="gameUiBtn">ðŸ† Top 10</button>
                    <button class="controlBtn" id="fullscreenBtn">ðŸ”³ Full</button>
                </div>
            </div>
        </div>

        <div id="wave" style="visibility: hidden;">
            <div>Wave: <span id="waveCount">1</span>/<span id="maxWavesCount">20</span></div>
            <div class="damage-bonus">DMG: +<span id="damageBonus">0</span>%</div>
        </div>

        <div id="gameBoard"></div>

        <div id="debugInfo">
            <div id="debugText"></div>
            <canvas id="fpsGraph" width="150" height="40"></canvas>
        </div>

        <div id="pauseMenu">
            <h2>Game Paused</h2>
            <button class="btn" onclick="resumeGame()">â–¶ï¸ Resume</button>
            <button class="btn savegame" onclick="openSaveLoadMenu('save')">ðŸ’¾ Save Game</button>
            <button class="btn restart" onclick="confirmRestart()">ðŸ”„ Restart</button>
            <button class="btn secondary" onclick="togglePerformanceMode()">ðŸš€ Performance Mode</button>
        </div>

        <div id="leaderboard">
            <h2>ðŸ† Top 10 Scores</h2>
            <div id="leaderboardList"></div>
            <button class="btn" onclick="closeLeaderboard()">Close</button>
        </div>

        <div id="gameOver">
            <h2>Game Over!</h2>
            <div class="stats">
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Waves Survived: <span id="finalWave">0</span></p>
                <p>Zombies Defeated: <span id="finalZombies">0</span></p>
            </div>
            <div>
                <button class="btn secondary" onclick="showLeaderboard()">View Top 10</button>
                <button class="btn" onclick="restartGame()">Play Again</button>
            </div>
        </div>

        <div id="victoryScreen">
            <h2>ðŸŽ‰ Victory! ðŸŽ‰</h2>
            <div class="stats">
                <p style="font-size: 1.3em; color: #FFD700;">You survived all <span id="victoryMaxWaves">20</span>
                    waves!</p>
                <p>Final Score: <span id="victoryScore" style="font-size: 1.5em; color: #764ba2;">0</span></p>
                <p>Zombies Defeated: <span id="victoryZombies">0</span></p>
                <p style="margin-top: 15px; color: #4CAF50;">Your score has been saved!</p>
            </div>
            <div>
                <button class="btn gold" onclick="showLeaderboard()">View Top 10</button>
                <button class="btn" onclick="restartGame()">Play Again</button>
            </div>
        </div>

        <div id="saveLoadMenu" class="dialog-overlay">
            <div class="dialog-box" style="max-width: 500px;">
                <h2 id="saveLoadTitle">Select a Slot</h2>
                <div id="slotListContainer">
                    <!-- Slots will be generated here by JavaScript -->
                </div>
                <button id="closeSaveLoadMenuBtn" class="btn secondary" style="margin-top: 20px;">Cancel</button>
            </div>
        </div>

        <div id="almanacScreen"
            style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #3d2a15; z-index: 1000; flex-direction: column; align-items: center; padding: 30px;">
            <h2 style="color: white; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 15px;">
                Zombie Almanac</h2>
            <div id="almanacContent">
                <div id="almanacZombieList">
                    <!-- Zombie icon cards will be generated here by JavaScript -->
                </div>
                <div id="almanacZombieDetails">
                    <!-- Details for the selected zombie will be shown here by JavaScript -->
                </div>
            </div>
            <button class="btn" onclick="closeAlmanac()" style="margin-top: 15px;">Close</button>
        </div>


        <div id="zombieSpawner">
            <!-- Zombie cards will be added here by JavaScript -->
        </div>
    </div>

    <div id="challengesScreen" class="dialog-overlay">
        <div class="dialog-box challenges-box">
            <h2>âš™ï¸ Challenges</h2>
            <p style="margin-bottom: 25px; font-size: 1em; color: #666;">Select challenges to modify your game. Changes
                will apply when you start a new game.</p>
            <div class="challenges-list">
                <!-- 40 Wave Survival -->
                <div class="challenge-toggle">
                    <label for="fortyWaves">
                        <input type="checkbox" id="fortyWaves" data-challenge="fortyWaves">
                        <span>40 Wave Survival</span>
                    </label>
                    <p>Survive a grueling 40 waves to win.</p>
                </div>
                <!-- Hard Mode -->
                <div class="challenge-toggle">
                    <label for="hardMode">
                        <input type="checkbox" id="hardMode" data-challenge="hardMode">
                        <span>Hard Mode</span>
                    </label>
                    <p>No lawnmowers and zombies have bigger hordes.</p>
                </div>
                <!-- Survival: Endless -->
                <div class="challenge-toggle">
                    <label for="endless">
                        <input type="checkbox" id="endless" data-challenge="endless">
                        <span>Survival: Endless</span>
                    </label>
                    <p>The waves never stop. How long can you last?</p>
                </div>
                <!-- Sandbox -->
                <div class="challenge-toggle">
                    <label for="sandbox">
                        <input type="checkbox" id="sandbox" data-challenge="sandbox">
                        <span>Sandbox</span>
                    </label>
                    <p>No zombies will spawn.</p>
                    <p>You have infinite sun.</p>
                    <p>Plants have no cooldown.</p>
                    <p>You have Zombie Spawner button.</p>
                </div>
            </div>
            <button id="closeChallengesBtn" class="btn" style="margin-top: 20px;">Done</button>
        </div>
    </div>

    <!-- Custom Dialog Box -->
    <div id="customDialog" class="dialog-overlay">
        <div class="dialog-box">
            <h2 id="dialogTitle"></h2>
            <p id="dialogMessage"></p>
            <div id="dialogButtons">
                <!-- Buttons are injected here -->
            </div>
        </div>
    </div>

    <!-- Critical Error Modal -->
    <div id="errorModal" class="dialog-overlay" style="z-index: 10000;">
        <div class="dialog-box" style="border: 4px solid #ff4444; max-width: 600px;">
            <h2 style="color: #ff4444; margin-bottom: 10px;">âš ï¸ Critical Error</h2>
            <p style="margin-bottom: 15px;">The game encountered a problem and needs to stop.<br>Please copy the error
                below and report it.</p>

            <textarea id="errorDetail" readonly style="
                width: 100%; 
                height: 150px; 
                margin-bottom: 15px; 
                background: rgba(0,0,0,0.1); 
                border: 1px solid #ccc; 
                border-radius: 5px; 
                padding: 10px; 
                font-family: monospace; 
                font-size: 0.8em; 
                resize: none; 
                color: #333;
            "></textarea>

            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn restart" onclick="location.reload()">ðŸ”„ Reload Game</button>
                <button class="btn secondary" id="copyErrorBtn" onclick="copyErrorToClipboard()">ðŸ“‹ Copy Error</button>
            </div>
        </div>
    </div>

    <div id="plantCardTemplates" style="display: none;">
        <div class="plantCard" data-plant="peashooter" data-cost="100">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ±</div>
            <div class="cost">100</div>
            <div class="name">Peashooter</div>
        </div>
        <div class="plantCard" data-plant="sunflower" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ»</div>
            <div class="cost">50</div>
            <div class="name">Sunflower</div>
        </div>
        <div class="plantCard" data-plant="cherrybomb" data-cost="150">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ’</div>
            <div class="cost">150</div>
            <div class="name">Cherry Bomb</div>
        </div>
        <div class="plantCard" data-plant="wallnut" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ¥¥</div>
            <div class="cost">50</div>
            <div class="name">Wall-nut</div>
        </div>
        <div class="plantCard" data-plant="potatomine" data-cost="25">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ¥”</div>
            <div class="cost">25</div>
            <div class="name">Potato Mine</div>
        </div>
        <div class="plantCard" data-plant="snowpea" data-cost="175">
            <div class="cooldown-overlay"></div>
            <div class="emoji">â„ï¸</div>
            <div class="cost">175</div>
            <div class="name">Snow Pea</div>
        </div>
        <div class="plantCard" data-plant="chomper" data-cost="150">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ¿</div>
            <div class="cost">150</div>
            <div class="name">Chomper</div>
        </div>
        <div class="plantCard" data-plant="repeater" data-cost="200">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ¾</div>
            <div class="cost">200</div>
            <div class="name">Repeater</div>
        </div>
        <div class="plantCard" data-plant="puffshroom" data-cost="0">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ¡</div>
            <div class="cost">0</div>
            <div class="name">Puff-shroom</div>
        </div>
        <div class="plantCard" data-plant="sunshroom" data-cost="25">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒž</div>
            <div class="cost">25</div>
            <div class="name">Sun-shroom</div>
        </div>
        <div class="plantCard" data-plant="fumeshroom" data-cost="75">
            <div class="cooldown-overlay"></div>
            <div class="emoji">âš—ï¸</div>
            <div class="cost">75</div>
            <div class="name">Fume-shroom</div>
        </div>
        <div class="plantCard" data-plant="gravebuster" data-cost="75">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ¦‡</div>
            <div class="cost">75</div>
            <div class="name">Grave Buster</div>
        </div>
        <div class="plantCard" data-plant="scaredyshroom" data-cost="25">
            <div class="cooldown-overlay"></div>
            <div class="emoji">â˜‚ï¸</div>
            <div class="cost">25</div>
            <div class="name">Scaredy-shroom</div>
        </div>
        <div class="plantCard" data-plant="iceshroom" data-cost="75">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ§Š</div>
            <div class="cost">75</div>
            <div class="name">Ice-shroom</div>
        </div>
        <div class="plantCard" data-plant="doomshroom" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ„</div>
            <div class="cost">125</div>
            <div class="name">Doom-shroom</div>
        </div>
        <div class="plantCard" data-plant="threepeater" data-cost="325">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŽ‹</div>
            <div class="cost">325</div>
            <div class="name">Threepeater</div>
        </div>
        <div class="plantCard" data-plant="jalapeno" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ¶ï¸</div>
            <div class="cost">125</div>
            <div class="name">Jalapeno</div>
        </div>
        <div class="plantCard" data-plant="spikeweed" data-cost="100">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ“Œ</div>
            <div class="cost">100</div>
            <div class="name">Spikeweed</div>
        </div>
        <div class="plantCard" data-plant="torchwood" data-cost="175">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸª”</div>
            <div class="cost">175</div>
            <div class="name">Torchwood</div>
        </div>
        <div class="plantCard" data-plant="tallnut" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ°</div>
            <div class="cost">125</div>
            <div class="name">Tall-nut</div>
        </div>
        <div class="plantCard" data-plant="plantern" data-cost="25">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ®</div>
            <div class="cost">25</div>
            <div class="name">Plantern</div>
        </div>
        <div class="plantCard" data-plant="cactus" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒµ</div>
            <div class="cost">125</div>
            <div class="name">Cactus</div>
        </div>
        <div class="plantCard" data-plant="blover" data-cost="125">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ€</div>
            <div class="cost">125</div>
            <div class="name">Blover</div>
        </div>
        <div class="plantCard" data-plant="cabbagepult" data-cost="100">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ¥¬</div>
            <div class="cost">100</div>
            <div class="name">Cabbage-pult</div>
        </div>
        <div class="plantCard" data-plant="kernelpult" data-cost="100">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ½</div>
            <div class="cost">100</div>
            <div class="name">Kernel-pult</div>
        </div>
        <div class="plantCard" data-plant="coffeebean" data-cost="75">
            <div class="cooldown-overlay"></div>
            <div class="emoji">â˜•</div>
            <div class="cost">75</div>
            <div class="name">Coffee Bean</div>
        </div>
        <div class="plantCard" data-plant="garlic" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ§„</div>
            <div class="cost">50</div>
            <div class="name">Garlic</div>
        </div>
        <div class="plantCard" data-plant="marigold" data-cost="50">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ¼</div>
            <div class="cost">50</div>
            <div class="name">Marigold</div>
        </div>
        <div class="plantCard" data-plant="melonpult" data-cost="300">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ‰</div>
            <div class="cost">300</div>
            <div class="name">Melon-pult</div>
        </div>
        <div class="plantCard" data-plant="firepea" data-cost="250">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ”¥</div>
            <div class="cost">250</div>
            <div class="name">Fire Pea</div>
        </div>
        <div class="plantCard" data-plant="snapdragon" data-cost="225">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ²</div>
            <div class="cost">225</div>
            <div class="name">Snapdragon</div>
        </div>
        <div class="plantCard" data-plant="hurrikale" data-cost="150">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ¬ï¸</div>
            <div class="cost">150</div>
            <div class="name">Hurrikale</div>
        </div>
        <div class="plantCard" data-plant="gatling" data-cost="250" data-upgrade="true" data-upgrades-from="repeater">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ”«</div>
            <div class="cost">250</div>
            <div class="name">Gatling Pea</div>
        </div>
        <div class="plantCard" data-plant="twinSunflower" data-cost="150" data-upgrade="true"
            data-upgrades-from="sunflower">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ»ðŸŒ»</div>
            <div class="cost">150</div>
            <div class="name">Twin Sunflower</div>
        </div>
        <div class="plantCard" data-plant="gloomshroom" data-cost="150" data-upgrade="true"
            data-upgrades-from="fumeshroom">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŒ€</div>
            <div class="cost">150</div>
            <div class="name">Gloom-shroom</div>
        </div>
        <div class="plantCard" data-plant="wintermelon" data-cost="200" data-upgrade="true"
            data-upgrades-from="melonpult">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ¥¶</div>
            <div class="cost">200</div>
            <div class="name">Winter Melon</div>
        </div>
        <div class="plantCard" data-plant="spikerock" data-cost="125" data-upgrade="true"
            data-upgrades-from="spikeweed">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸ“</div>
            <div class="cost">125</div>
            <div class="name">Spikerock</div>
        </div>
        <div class="plantCard" data-plant="imitater" data-cost="">
            <div class="cooldown-overlay"></div>
            <div class="emoji">ðŸŽ­</div>
            <div class="cost"></div>
            <div class="name">Imitater</div>
        </div>
        <div class="plantCard" data-plant="suncheat" data-cost="0">
            <div class="cooldown-overlay"></div>
            <div class="emoji">â˜€ï¸</div>
            <div class="cost">0</div>
            <div class="name">Suncheat</div>
        </div>
        <!-- Shovel -->
        <div class="plantCard" id="shovelCard">
            <div class="emoji">â›ï¸</div>
            <div class="name" style="font-weight: bold; margin-top: 8px;">Shovel</div>
        </div>
    </div>


    <script>
        // --- GLOBAL ERROR HANDLING ---
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            handleCriticalError(msg, url, lineNo, columnNo, error);
            return false;
        };

        window.onunhandledrejection = function (event) {
            handleCriticalError('Unhandled Promise Rejection', '', '', '', event.reason);
        };

        function handleCriticalError(msg, url, lineNo, columnNo, error) {
            const modal = document.getElementById('errorModal');
            const detailBox = document.getElementById('errorDetail');

            if (modal.style.display === 'flex') return;

            if (typeof gameState !== 'undefined') {
                gameState.isPaused = true;
                if (gameState.gameLoopId) cancelAnimationFrame(gameState.gameLoopId);
            }

            let errorText = `Error: ${msg}\n`;
            if (lineNo) errorText += `Location: Line ${lineNo}:${columnNo}\n`;
            if (url) errorText += `URL: ${url}\n`;
            if (error && error.stack) {
                errorText += `\nStack Trace:\n${error.stack}`;
            } else if (error) {
                errorText += `\nDetails:\n${JSON.stringify(error, null, 2)}`;
            }

            detailBox.value = errorText;
            modal.style.display = 'flex';
        }

        function copyErrorToClipboard() {
            const copyText = document.getElementById("errorDetail");
            copyText.select();
            copyText.setSelectionRange(0, 99999);

            try {
                navigator.clipboard.writeText(copyText.value).then(() => {
                    const btn = document.getElementById('copyErrorBtn');
                    const originalText = btn.textContent;
                    btn.textContent = "âœ… Copied!";
                    setTimeout(() => btn.textContent = originalText, 2000);
                });
            } catch (err) {
                document.execCommand("copy");
                alert("Error copied to clipboard");
            }
        }

        let selectedPlantDeck = [];
        let lastSelectedPlantForImitater = null;
        let wavePointsForCurrentWave = null;
        let isShowingZombiesInPlantBar = false;

        // Game State
        let gameState = {
            sun: 200,
            score: 0,
            map: 'day',
            selectedPlant: null,
            selectedZombie: null, // For debug spawner
            isShovelActive: false,
            isZombieSpawnMode: false,
            plants: [],
            zombies: [],
            projectiles: [],
            suns: [],
            lawnmowers: [],
            graves: [],
            iceTrails: [],
            flyingOctopuses: [],
            wave: 1,
            maxWaves: 20,
            isSpawningComplete: false,
            zombiesDefeated: 0,
            isPaused: false,
            isGameOver: false,
            isVictory: false,
            victoryTriggered: false, // Flag to ensure victory sequence only runs once
            cellSize: { width: 0, height: 0 },
            boardRect: null,
            gameSpeed: 1,
            lastUpdate: Date.now(),
            zombieDamageMultiplier: 1.0,
            waveTimerId: null,
            wasFullscreen: false,
            sunIntervalId: null,
            gameLoopId: null,
            timers: {},
            nextTimerId: 0,
            nextId: 0
        };

        let activeChallenges = {
            fortyWaves: false,
            hardMode: false,
            endless: false,
            sandbox: false,
        };

        // Plant Types
        const plantTypes = { // ðŸŒ´Umbrella Leaf \ ðŸ§²Magnet-shroom
            peashooter: {
                emoji: 'ðŸŒ±',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 1,
                shootInterval: 1500,
                projectile: 'ðŸŸ¢',
                description: 'Basic shooter',
                cooldown: 7500 // Fast
            },
            sunflower: {
                emoji: 'ðŸŒ»',
                health: 3.6,
                maxHealth: 3.6,
                produces: 'sun',
                sunAmount: 50,
                baseInterval: 24000,
                shoots: false,
                description: 'Produces sun',
                cooldown: 7500 // Fast
            },
            cherrybomb: {
                emoji: 'ðŸ’',
                health: Infinity,
                maxHealth: Infinity,
                shoots: false,
                isActivatingPlant: true,
                armTime: 1200,
                damage: 90,
                radius: 1, // 3x3 area (radius of 1 from center)
                description: 'Explodes in an area',
                cooldown: 50000 // Very Slow
            },
            wallnut: {
                emoji: 'ðŸ¥¥',
                health: 24,
                maxHealth: 24,
                shoots: false,
                description: 'Defensive wall',
                cooldown: 30000 // Slow
            },
            potatomine: {
                emoji: 'ðŸ¥”',
                health: 3.6,
                maxHealth: 3.6,
                shoots: false,
                isMine: true,
                damage: 90,
                armTime: 14000,
                description: 'Explodes on contact after arming',
                cooldown: 30000 // Slow
            },
            snowpea: {
                emoji: 'â„ï¸',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 1,
                slow: true,
                shootInterval: 2000,
                projectile: 'â„ï¸',
                description: 'Slows zombies',
                cooldown: 7500 // Fast
            },
            chomper: {
                emoji: 'ðŸŒ¿',
                health: 4.88,
                maxHealth: 4.88,
                shoots: false,
                damage: 2,
                attackInterval: 1000,
                chewTime: 42000,
                description: 'Eats zombies',
                cooldown: 7500 // Fast
            },
            repeater: {
                emoji: 'ðŸŒ¾',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 1,
                double: true,
                shootInterval: 1500,
                projectile: 'ðŸŸ¢',
                description: 'Shoots twice',
                cooldown: 7500 // Fast
            },
            puffshroom: {
                emoji: 'ðŸ¡',
                health: 3.6,
                maxHealth: 3.6,
                isMushroom: true,
                shoots: true,
                damage: 1,
                shootInterval: 1500,
                projectile: 'ðŸ’¨',
                range: 3, // Range in grid cells
                lifespan: 60000, // Dies after 60 seconds
                description: 'Shoots for a short distance, has a limited lifespan.<br><p style="color: #CC6CE7;">Sleeps during day.',
                cooldown: 7500 // Fast
            },
            sunshroom: {
                emoji: 'ðŸŒž',
                health: 3.6,
                maxHealth: 3.6,
                isMushroom: true,
                produces: 'sun',
                sunAmount: 50,
                baseInterval: 24000,
                isGrowing: true,
                growthTime: 60000, // 60 seconds to grow
                description: 'Gives small suns, then normal suns after a while.<br><p style="color: #CC6CE7;">Sleeps during day.',
                cooldown: 7500 // Fast
            },
            fumeshroom: {
                emoji: 'âš—ï¸',
                health: 3.6,
                maxHealth: 3.6,
                isMushroom: true,
                shoots: true,
                damage: 1,
                pierce: true, // Fumes hit multiple targets
                shootInterval: 1500,
                projectile: 'â˜ï¸',
                range: 4, // Range of the fume cloud
                description: 'Damage all zombies in a line, ignoring shields.<br><p style="color: #CC6CE7;">Sleeps during day.',
                cooldown: 7500 // Fast
            },
            gravebuster: {
                emoji: 'ðŸ¦‡',
                health: 3.6,
                maxHealth: 3.6,
                shoots: false,
                isGraveBuster: true,
                description: 'Eats graves, single use',
                cooldown: 7500 // Fast
            },
            scaredyshroom: {
                emoji: 'â˜‚ï¸',
                health: 3.6,
                maxHealth: 3.6,
                isMushroom: true,
                shoots: true,
                isScaredy: true,
                damage: 1,
                shootInterval: 1500,
                projectile: 'ðŸŸ£',
                description: 'Shooter that gets scared and hides when enemies get too close.<br><p style="color: #CC6CE7;">Sleeps during day.',
                cooldown: 7500 // Fast
            },
            iceshroom: {
                emoji: 'ðŸ§Š',
                health: 3.6,
                maxHealth: 3.6,
                shoots: false,
                isMushroom: true,
                damage: 1,
                freezes: true,
                description: 'Freezes all zombies on screen. <br>Sleeps during day',
                cooldown: 50000 // Very Slow
            },
            doomshroom: {
                emoji: 'ðŸ„',
                health: 3.6,
                maxHealth: 3.6,
                shoots: false,
                isMushroom: true,
                damage: 90,
                radiusX: 3, // 7 wide
                radiusY: 2, // 5 high
                createsCrater: true,
                description: 'Huge explosion, leaves crater. <br>Sleeps during day',
                cooldown: 50000 // Very Slow
            },
            threepeater: {
                emoji: 'ðŸŽ‹',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 1,
                triple: true,
                shootInterval: 1500,
                projectile: 'ðŸŸ¢',
                description: 'Shoots 3 lanes',
                cooldown: 7500 // Fast
            },
            jalapeno: {
                emoji: 'ðŸŒ¶ï¸',
                health: Infinity,
                maxHealth: Infinity,
                shoots: false,
                isActivatingPlant: true,
                armTime: 1200,
                damage: 90,
                laneWide: true,
                description: 'Destroys an entire lane',
                cooldown: 50000 // Very Slow
            },
            spikeweed: {
                emoji: 'ðŸ“Œ',
                health: 4.8,
                maxHealth: 4.8,
                shoots: false,
                isSpike: true,
                damage: 0.5,
                attackInterval: 1000,
                description: 'Hurts zombies that step on it',
                cooldown: 7500 // Fast
            },
            torchwood: {
                emoji: 'ðŸª”',
                health: 4.8,
                maxHealth: 4.8,
                shoots: false,
                description: 'Ignites peas',
                cooldown: 7500 // Fast
            },
            tallnut: {
                emoji: 'ðŸŒ°',
                health: 48,
                maxHealth: 48,
                shoots: false,
                description: 'Great defensive wall',
                cooldown: 30000 // Slow
            },
            plantern: {
                emoji: 'ðŸ®',
                health: 4.8,
                maxHealth: 4.8,
                shoots: false,
                description: 'Creates cozy light (imagination)',
                cooldown: 30000 // Slow
            },
            cactus: {
                emoji: 'ðŸŒµ',
                health: 4.8,
                maxHealth: 4.8,
                shoots: true,
                damage: 1,
                pierce: true,
                shootInterval: 1800,
                projectile: 'ðŸ“',
                description: 'Piercing shots',
                cooldown: 7500 // Fast
            },
            blover: {
                emoji: 'ðŸ€',
                health: Infinity,
                maxHealth: Infinity,
                shoots: false,
                isActivatingPlant: true,
                armTime: 1200,
                isBlower: true,
                description: 'Blows away flying zombies',
                cooldown: 7500, // Fast
            },
            cabbagepult: {
                emoji: 'ðŸ¥¬',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 2,
                shootInterval: 3000,
                projectile: 'ðŸ¥¬',
                description: 'Lobs cabbages',
                cooldown: 7500 // Fast
            },
            kernelpult: {
                emoji: 'ðŸŒ½',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 1,
                shootInterval: 3000,
                projectile: 'ðŸŸ¡',
                hasButter: true,
                description: 'Lobs kernels and butter that stuns',
                cooldown: 7500, // Fast
            },
            coffeebean: {
                emoji: 'â˜•',
                health: Infinity,
                shoots: false,
                isWakeUp: true,
                description: 'Wakes up sleeping mushrooms',
                cooldown: 7500 // Fast
            },
            garlic: {
                emoji: 'ðŸ§„',
                health: 18,
                maxHealth: 18,
                shoots: false,
                diverts: true,
                description: 'Diverts zombies to other lanes',
                cooldown: 7500 // Fast
            },
            marigold: {
                emoji: 'ðŸŒ¼',
                health: 3.6,
                maxHealth: 3.6,
                produces: 'coin',
                baseInterval: 15000,
                shoots: false,
                description: 'Produces coins(little suns)',
                cooldown: 30000 // Slow
            },
            melonpult: {
                emoji: 'ðŸ‰',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 4, // High direct damage
                splashDamage: 1.3, // Lower splash damage
                splashRadiusY: 1, // 3 rows total (target row +/- 1)
                shootInterval: 3000,
                projectile: 'ðŸˆ',
                description: 'High direct, 3x3 splash damage',
                cooldown: 7500 // Fast
            },
            firepea: {
                emoji: 'ðŸ”¥',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 2,
                splashDamage: 0.65,
                splashRadiusY: 0, // 3x1 radius
                fire: true,
                shootInterval: 1500,
                projectile: 'ðŸ”¥',
                description: 'Splash fire damage',
                cooldown: 7500 // Fast
            },
            snapdragon: {
                emoji: 'ðŸ²',
                health: 4.8,
                maxHealth: 4.8,
                shoots: false,
                isSnapdragon: true,
                damage: 1.5,
                shootInterval: 2000,
                description: 'Breathes fire in a 3x2 area',
                cooldown: 7500 // Fast
            },
            hurrikale: {
                emoji: 'ðŸŒ¬ï¸',
                health: Infinity,
                maxHealth: Infinity,
                shoots: false,
                isActivatingPlant: true,
                armTime: 1200,
                laneWide: true,
                isPusher: true,
                description: 'Pushes zombies back and slows them',
                cooldown: 15000 // Medium
            },
            gatling: {
                emoji: 'ðŸ”«',
                health: 3.6,
                maxHealth: 3.6,
                shoots: true,
                damage: 1,
                quad: true,
                shootInterval: 1500,
                projectile: 'ðŸŸ¢',
                description: 'Shoots 4 peas. <br>Has to be planted on <strong>Repeater',
                isUpgrade: true,
                upgradesFrom: 'repeater',
                cooldown: 50000 // Very Slow
            },
            twinSunflower: {
                emoji: 'ðŸŒ»ðŸŒ»',
                health: 3.6,
                maxHealth: 3.6,
                produces: 'sun',
                sunAmount: 100,
                baseInterval: 24000,
                shoots: false,
                description: 'Produces double sun. <br>Has to be planted on <strong>Sunflower',
                isUpgrade: true,
                upgradesFrom: 'sunflower',
                cooldown: 50000 // Very Slow
            },
            gloomshroom: {
                emoji: 'ðŸŒ€',
                health: 4.8,
                maxHealth: 4.8,
                isMushroom: true,
                shoots: false,
                isGloomshroom: true,
                damage: 4,
                attackInterval: 1500,
                description: 'Fires in a 3x3 area. <br><p style="color: #CC6CE7;">Sleeps during day. <br><p style="color: white;">Has to be planted on <strong>Fume-shroom</strong>',
                isUpgrade: true,
                upgradesFrom: 'fumeshroom',
                cooldown: 50000 // Very Slow
            },
            wintermelon: {
                emoji: 'ðŸ¥¶',
                health: 4.8,
                maxHealth: 4.8,
                shoots: true,
                damage: 4,
                splashDamage: 1.3,
                splashRadiusY: 1,
                slow: true,
                shootInterval: 3000,
                projectile: 'ðŸ§Š',
                description: 'Splash freezes and damages zombies. <br>Has to be planted on <strong>Melon-pult',
                isUpgrade: true,
                upgradesFrom: 'melonpult',
                cooldown: 50000 // Very Slow
            },
            spikerock: {
                emoji: 'ðŸ“',
                health: 9.6 * 3,
                maxHealth: 9.6 * 3,
                shoots: false,
                isSpike: true,
                isSpikerock: true,
                damage: 1,
                attackInterval: 750,
                description: 'Damages zombies that walk over it. <br>Has to be planted on <strong>Spikeweed',
                isUpgrade: true,
                upgradesFrom: 'spikeweed',
                cooldown: 50000 // Very Slow
            },
            imitater: {
                emoji: 'ðŸŽ­',
                health: 0, // Health is copied from target
                isImitater: true,
                description: 'Copies the previously selected plant',
                cooldown: 1000 // Cooldown is on the transformed card
            },
            suncheat: {
                emoji: 'â˜€ï¸',
                health: 1,
                maxHealth: 1,
                produces: 'sun',
                sunAmount: 9990,
                baseInterval: 99900,
                shoots: false,
                description: 'Cheats sun',
                cooldown: 0
            },
        };

        // Zombies
        const zombieTypes = {
            normal: { emoji: 'ðŸ§Ÿ', health: 10, maxHealth: 10, speed: 13, damage: 1, points: 100 },
            flag: { emoji: 'ðŸ§Ÿ', health: 10, maxHealth: 10, speed: 17, damage: 1, points: 125, attachments: [{ emoji: 'ðŸš©', offset: { x: 3, y: 0 } }] },
            cone: { emoji: 'ðŸ§Ÿâ€â™‚ï¸', health: 28, maxHealth: 28, speed: 13, damage: 1, points: 200, attachments: [{ emoji: 'âš ï¸', offset: { x: 9, y: -13 } }] },
            fast: { emoji: 'ðŸ’€', health: 17, maxHealth: 17, speed: 25, damage: 1, points: 150 },
            newspaper: { emoji: 'ðŸ§Ÿ', health: 17.5, maxHealth: 17.5, speed: 10, rageSpeedMultiplier: 4.57, damage: 1, points: 175, attachments: [{ emoji: 'ðŸ“°', offset: { x: 9, y: 16 } }] },
            bucket: { emoji: 'ðŸ§Ÿâ€â™€ï¸', health: 65, maxHealth: 65, speed: 10, damage: 1, points: 400, attachments: [{ emoji: 'ðŸŽ“', offset: { x: 9, y: -13 } }] },
            jackInTheBox: { emoji: 'ðŸ¤¡', health: 17, maxHealth: 17, speed: 25, damage: 1, points: 450, isExplosive: true },
            balloon: { emoji: 'ðŸŽˆ', health: 11, maxHealth: 11, speed: 25, damage: 1, points: 250, isFlying: true },
            dancing: { emoji: 'ðŸ•º', health: 17, maxHealth: 17, speed: 13, damage: 1, points: 500, summons: true, summonCooldown: 10000 },
            backupDancer: { emoji: 'ðŸ’ƒ', health: 10, maxHealth: 10, speed: 13, damage: 1, points: 150, isSummoned: true },
            football: { emoji: 'ðŸ‘¹', health: 80, maxHealth: 80, speed: 25, damage: 2, points: 600 },
            zomboni: { emoji: 'ðŸšš', health: 65, maxHealth: 65, speed: 10, damage: 99, points: 1000, crushes: true, leavesIceTrail: true, attachments: [{ emoji: 'ðŸ§Ÿâ€â™€ï¸', offset: { x: 30, y: 3 } }] },
            trashCanZombie: { emoji: 'ðŸ§Ÿ', health: 50, maxHealth: 50, speed: 10, damage: 1, points: 450, attachments: [{ emoji: 'ðŸ—‘ï¸', offset: { x: -4, y: 15 } }] },
            gargantuar: { emoji: 'ðŸ—¿', health: 150, maxHealth: 150, speed: 5, damage: 99, points: 2000, uneatable: true, crushes: true },
            imp: { emoji: 'ðŸ‘¿', health: 10, maxHealth: 10, speed: 20, damage: 1, points: 75 },
            octoZombie: { emoji: 'ðŸ§Ÿ', health: 46, maxHealth: 46, speed: 13, damage: 1, points: 450, isThrower: true, throwInterval: 6000, projectile: 'ðŸ™', attachments: [{ emoji: 'ðŸ™', offset: { x: 9, y: -2 } }] },
            peashooterZombie: { emoji: 'ðŸ§Ÿ', health: 10, maxHealth: 10, speed: 13, damage: 0.225, points: 225, shoots: true, shootInterval: 1500, projectile: 'ðŸŸ¢', attachments: [{ emoji: 'ðŸŒ±', offset: { x: 9, y: -2 } }] },
            giga: { emoji: 'ðŸ‘º', health: 300, maxHealth: 300, speed: 5, damage: 99, points: 6000, uneatable: true, crushes: true },
            wallnutZombie: { emoji: 'ðŸ§Ÿ', health: 65, maxHealth: 65, speed: 10, damage: 1, points: 800, attachments: [{ emoji: 'ðŸ¥¥', offset: { x: 9, y: -2 } }] },
            gatlingZombie: { emoji: 'ðŸ§Ÿ', health: 28, maxHealth: 28, speed: 13, damage: 0.225, points: 350, shoots: true, quad: true, shootInterval: 1500, projectile: 'ðŸŸ¢', attachments: [{ emoji: 'ðŸ”«', offset: { x: 9, y: -2 } }] },
            tallnutZombie: { emoji: 'ðŸ§Ÿ', health: 120, maxHealth: 120, speed: 10, damage: 1, points: 1500, attachments: [{ emoji: 'ðŸŒ°', offset: { x: 9, y: -2 } }] },
            gigafootball: { emoji: 'ðŸ‘¹', health: 155, maxHealth: 155, speed: 25, damage: 2, points: 2800, attachments: [{ emoji: 'â›‘ï¸', offset: { x: 9, y: -4 } }] },
            rally: { emoji: 'ðŸ§Ÿ', health: 18, maxHealth: 18, speed: 22, damage: 3, points: 175, attachments: [{ emoji: 'ðŸ´â€â˜ ï¸', offset: { x: 3, y: 0 } }] },
            zomboss: { emoji: 'ðŸ¤–', health: 2000, maxHealth: 2000, speed: 1, damage: 99, points: 40000, uneatable: true, crushes: true },
        };

        // Zombies Wave Generation Data
        const zombieWaveData = {
            normal: { cost: 1, weight: 4000, minWave: 1 },
            cone: { cost: 2, weight: 3500, minWave: 2 },
            fast: { cost: 2, weight: 3000, minWave: 3 },
            newspaper: { cost: 3, weight: 3000, minWave: 4 },
            bucket: { cost: 4, weight: 3500, minWave: 5 },
            jackInTheBox: { cost: 3, weight: 2000, minWave: 6 },
            balloon: { cost: 2, weight: 2000, minWave: 7 },
            dancing: { cost: 6, weight: 2000, minWave: 8 },
            football: { cost: 5, weight: 3000, minWave: 9 },
            zomboni: { cost: 7, weight: 1500, minWave: 10 },
            trashCanZombie: { cost: 5, weight: 3000, minWave: 11 },
            gargantuar: { cost: 10, weight: 1000, minWave: 12 },
            octoZombie: { cost: 5, weight: 2000, minWave: 13 },
            peashooterZombie: { cost: 3, weight: 1500, minWave: 14 },
            giga: { cost: 15, weight: 500, minWave: 15 },
            wallnutZombie: { cost: 6, weight: 3000, minWave: 16 },
            gatlingZombie: { cost: 4, weight: 1500, minWave: 17 },
            tallnutZombie: { cost: 8, weight: 2500, minWave: 18 },
            gigafootball: { cost: 13, weight: 3000, minWave: 19 },

            flag: { cost: 1, weight: 0, minWave: 1 },
            backupDancer: { cost: 0, weight: 0, minWave: 1 },
            imp: { cost: 0, weight: 0, minWave: 1 },
            rally: { cost: 1, weight: 0, minWave: 20 },
        };

        // --- Global variable for the active tooltip
        let activeTooltip = null;

        // --- NEW TIMER SYSTEM ---
        function createTimer(delay, callback, isInterval = false, type = 'anonymous', context = null) {
            const id = gameState.nextTimerId++;
            gameState.timers[id] = {
                id,
                delay,
                remaining: delay,
                callback,
                isInterval,
                type, // The purpose of the timer (e.g., 'waveTimer', 'plantShoot')
                context // The ID of the object this timer affects (e.g., a plant's unique ID)
            };
            return id;
        }

        function clearTimer(id) {
            if (gameState.timers[id]) {
                delete gameState.timers[id];
            }
        }

        function updateTimers(deltaTime) {
            const adjustedDelta = deltaTime * gameState.gameSpeed;
            const timerIds = Object.keys(gameState.timers);

            for (const id of timerIds) {
                const timer = gameState.timers[id];
                if (timer) {
                    timer.remaining -= adjustedDelta;
                    if (timer.remaining <= 0) {
                        try {
                            timer.callback();
                        } catch (e) {
                            console.error("Error in timer callback:", e);
                        }

                        if (timer.isInterval && gameState.timers[id]) {
                            timer.remaining += timer.delay;
                        } else {
                            clearTimer(id);
                        }
                    }
                }
            }
        }

        // Reset game state to initial values
        function resetGame() {
            // Clear any existing timers
            clearTimer(gameState.waveTimerId);
            clearTimer(gameState.sunIntervalId);
            gameState.timers = {}; // Clear all active timers

            // Clear all DOM elements
            clearAllGameElements();

            lastSelectedPlantForImitater = null;
            wavePointsForCurrentWave = null;
            isShowingZombiesInPlantBar = false;
            const selectedMap = document.querySelector('#mapChooser .mapOption.active').dataset.map || 'day';

            // Reset game state
            gameState = {
                sun: 200,
                score: 0,
                map: selectedMap,
                selectedPlant: null,
                selectedZombie: null,
                isShovelActive: false,
                isZombieSpawnMode: false,
                plants: [],
                zombies: [],
                projectiles: [],
                suns: [],
                lawnmowers: [],
                graves: [],
                iceTrails: [],
                flyingOctopuses: [],
                wave: 1,
                maxWaves: 20,
                zombiesDefeated: 0,
                isPaused: false,
                isGameOver: false,
                isVictory: false,
                victoryTriggered: false,
                cellSize: { width: 0, height: 0 },
                boardRect: null,
                gameSpeed: 1,
                lastUpdate: Date.now(),
                zombieDamageMultiplier: 1.0,
                waveTimerId: null,
                wasFullscreen: document.fullscreenElement !== null,
                sunIntervalId: null,
                gameLoopId: gameState.gameLoopId, // Keep the game loop running
                timers: {},
                nextTimerId: 0,
                nextId: 0
            };

            // Reset UI
            document.getElementById('sunCount').textContent = '200';
            document.getElementById('scoreCount').textContent = '0';
            document.getElementById('waveCount').textContent = '1';
            document.getElementById('damageBonus').textContent = '0';
            document.getElementById('speedBtn').textContent = 'âš¡ x1';
            document.getElementById('speedBtn').classList.remove('active');
            document.getElementById('pauseBtn').textContent = 'â¸ï¸ Pause';
            document.getElementById('gameBoard').classList.remove('shovel-mode');
            document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
            document.getElementById('gameContainer').style.setProperty('--game-speed', 1);

            // Hide all menus
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('zombieSpawner').style.display = 'none';
            document.getElementById('plantSelection').innerHTML = '';

            // Reset map visuals
            document.getElementById('gameContainer').classList.remove('night-mode');

            // Reset zombie card selection
            document.querySelectorAll('.zombieCard').forEach(card => card.classList.remove('selected'));

            // Update displays
            updateSunDisplay();
            updateDamageDisplay();
            updateWaveDisplay();
            updateBoardDimensions();
        }

        function resetChallenges() {
            const challengeCheckboxes = document.querySelectorAll('#challengesScreen input[type="checkbox"]');

            challengeCheckboxes.forEach(checkbox => {
                const challengeName = checkbox.dataset.challenge;

                if (challengeName in activeChallenges) {
                    activeChallenges[challengeName] = checkbox.checked;
                }
            });
        }

        // Clear all game elements from DOM
        function clearAllGameElements() {
            // Remove all zombies
            document.querySelectorAll('.zombie').forEach(el => el.remove());

            // Remove all projectiles
            document.querySelectorAll('.projectile').forEach(el => el.remove());

            // Remove all suns
            document.querySelectorAll('.sun').forEach(el => el.remove());

            // Remove all plants from cells
            document.querySelectorAll('.cell .plant').forEach(el => el.remove());

            // Remove any floating particles or popups
            document.querySelectorAll('.particle, .points-popup, .instant-effect').forEach(el => el.remove());

            // Remove all lawnmovers
            document.querySelectorAll('.lawnmower').forEach(el => el.remove());

            // Remove all octopus
            document.querySelectorAll('.flying-octopus').forEach(el => el.remove());

            // Remove all craters
            document.querySelectorAll('.cell.crater').forEach(cell => cell.classList.remove('crater'));

            // Remove all graves
            document.querySelectorAll('.cell.grave').forEach(cell => cell.classList.remove('grave'));

            // Remove all ice trails
            document.querySelectorAll('.cell.iced').forEach(cell => cell.classList.remove('iced'));
        }

        // Calculate zombie damage with wave multiplier
        function getZombieDamage(baseZombieDamage) {
            return baseZombieDamage * gameState.zombieDamageMultiplier;
        }

        // Update damage multiplier display
        function updateDamageDisplay() {
            const bonusPercent = Math.round((gameState.zombieDamageMultiplier - 1) * 100);
            document.getElementById('damageBonus').textContent = bonusPercent;
        }

        // Update wave display
        function updateWaveDisplay() {
            document.getElementById('waveCount').textContent = gameState.wave;
            document.getElementById('maxWavesCount').textContent = gameState.maxWaves;
            const waveElement = document.getElementById('wave');
            if (gameState.wave === gameState.maxWaves) {
                waveElement.classList.add('final-wave');
            } else {
                waveElement.classList.remove('final-wave');
            }
        }

        // Format date and time for display
        function formatDateTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

            const timeStr = date.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
            });

            let dateStr;
            if (diffDays === 0) {
                dateStr = 'Today';
            } else if (diffDays === 1) {
                dateStr = 'Yesterday';
            } else if (diffDays < 7) {
                dateStr = `${diffDays} days ago`;
            } else {
                dateStr = date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
                });
            }

            return { date: dateStr, time: timeStr };
        }

        // Show save notification
        function showSaveNotification() {
            const notification = document.createElement('div');
            notification.className = 'save-notification';
            notification.textContent = 'âœ… Score Saved to Top 10!';
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        // Leaderboard Functions
        function getLeaderboard() {
            const saved = localStorage.getItem('pvz_leaderboard');
            return saved ? JSON.parse(saved) : [];
        }

        function saveToLeaderboard(score, wave, zombies) {
            let leaderboard = getLeaderboard();

            leaderboard.push({
                score: score,
                wave: wave,
                zombies: zombies,
                datetime: new Date().toISOString(),
                victory: gameState.isVictory
            });

            // Sort by score and keep top 10
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10);

            localStorage.setItem('pvz_leaderboard', JSON.stringify(leaderboard));

            // Show notification if score made it to top 10
            if (leaderboard.some(entry => entry.score === score && entry.datetime === leaderboard[leaderboard.length - 1].datetime)) {
                showSaveNotification();
            }

            return leaderboard;
        }

        function displayLeaderboard() {
            const leaderboard = getLeaderboard();
            const listElement = document.getElementById('leaderboardList');
            listElement.innerHTML = '';

            if (leaderboard.length === 0) {
                listElement.innerHTML = '<p style="color: #666;">No scores yet. Be the first!</p>';
                return;
            }

            leaderboard.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'leaderboard-entry';

                if (index === 0) entryDiv.classList.add('gold');
                else if (index === 1) entryDiv.classList.add('silver');
                else if (index === 2) entryDiv.classList.add('bronze');

                const medal = index === 0 ? 'ðŸ¥‡' : index === 1 ? 'ðŸ¥ˆ' : index === 2 ? 'ðŸ¥‰' : `#${index + 1}`;
                const { date, time } = formatDateTime(entry.datetime);
                const victoryBadge = entry.victory ? ' ðŸ‘‘' : '';

                entryDiv.innerHTML = `
                    <span class="leaderboard-rank">${medal}</span>
                    <div class="leaderboard-datetime">
                        <span class="leaderboard-date">${date}${victoryBadge}</span>
                        <span class="leaderboard-time">${time} &bull; Wave ${entry.wave}</span>
                    </div>
                    <span class="leaderboard-score">${entry.score.toLocaleString()}</span>
                `;

                listElement.appendChild(entryDiv);
            });
        }

        function showLeaderboard() {
            displayLeaderboard();
            togglePause();
            document.getElementById('modalOverlay').style.display = 'block';
            document.getElementById('leaderboard').style.display = 'block';
        }

        function closeLeaderboard() {
            togglePause();
            document.getElementById('modalOverlay').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none';
        }

        function recreateSun(sunData) {
            const sun = document.createElement('div');
            sun.className = 'sun';
            const sunValue = sunData.value || 50;
            const sunEmoji = sunData.emoji || 'â˜€ï¸';

            sun.innerHTML = `<span>${sunEmoji}</span><span class="sun-value">${sunValue}</span>`;

            sun.style.position = 'fixed';
            sun.style.left = (gameState.boardRect.left + sunData.x) + 'px';
            sun.style.top = (gameState.boardRect.top + sunData.y) + 'px';

            // Use the original ID from the save data
            const sunId = sunData.id;
            if (!sunId) {
                console.error("Sun data is missing an ID during recreation.", sunData);
                return;
            }
            sun.dataset.sunId = sunId;

            document.getElementById('gameContainer').appendChild(sun);

            sun.addEventListener('click', () => collectSun(sun, sunValue));
            sun.addEventListener('touchstart', (e) => { e.preventDefault(); collectSun(sun, sunValue); }, { passive: false });
        }

        //=================================================
        // --- FULL SAVE/LOAD SYSTEM ---
        //=================================================

        function saveFullGameState(slotNumber) {
            if (!slotNumber) {
                console.error("Save function called without a slot number!");
                return;
            }
            if (gameState.isGameOver) {
                showCustomDialog('Cannot Save', 'You cannot save the game once it is over.', [{ text: 'OK' }]);
                return;
            }

            // 1. Create a "serializable" version of the game state
            const serializableState = {
                // Simple values
                sun: gameState.sun,
                score: gameState.score,
                wave: gameState.wave,
                maxWaves: gameState.maxWaves,
                map: gameState.map,
                zombiesDefeated: gameState.zombiesDefeated,
                zombieDamageMultiplier: gameState.zombieDamageMultiplier,
                nextId: gameState.nextId,
                isSpawningComplete: gameState.isSpawningComplete,
                activeChallenges: activeChallenges,

                // Deck and cooldowns
                selectedPlantDeck: selectedPlantDeck,
                cardCooldowns: Array.from(document.querySelectorAll('#plantSelection .plantCard'))
                    .map(card => {
                        const timerId = card.dataset.cooldownTimerId;
                        if (timerId && gameState.timers[timerId]) {
                            const timer = gameState.timers[timerId]; // Get the full timer object
                            return {
                                plant: card.dataset.plant,
                                isImitated: card.dataset.isImitated === 'true',
                                remaining: timer.remaining,
                                delay: timer.delay
                            };
                        }
                        return null;
                    }).filter(Boolean),

                // Game Objects (stripped of DOM elements)
                plants: gameState.plants.map(p => ({
                    id: p.id,
                    type: p.type,
                    row: p.row,
                    col: p.col,
                    health: p.health,
                    maxHealth: p.maxHealth,
                    isImitated: p.isImitated || false,
                    isSleeping: p.isSleeping || false,
                    isMushroom: p.isMushroom || false,
                    isGrown: p.isGrown || false,
                    isChewing: p.isChewing || false,
                    chewTimer: p.chewTimer || 0,
                    isArmed: p.isArmed || false,
                    isArming: p.isArming || false,
                    sunCooldown: p.sunCooldown || 0,
                    shootCooldown: p.shootCooldown || 0,
                    isWrapped: p.isWrapped || false,
                    wrapTimer: p.wrapTimer || 0
                })),
                zombies: gameState.zombies.map(z => ({
                    id: z.id,
                    type: z.type,
                    row: z.row,
                    health: z.health,
                    x: z.x,
                    isFlying: z.isFlying,
                    armorBroken: z.armorBroken,
                    slowed: z.slowed,
                    slowTimer: z.slowTimer,
                    isFrozen: z.isFrozen,
                    freezeTimer: z.freezeTimer,
                    isStunned: z.isStunned,
                    stunTimer: z.stunTimer,
                    lastSummon: z.lastSummon || 0,
                    leaderId: z.leader ? z.leader.id : null,
                    hasThrownImp: z.hasThrownImp || false,
                    isBeingPushed: z.isBeingPushed || false,
                    throwCooldown: z.throwCooldown || 0,
                    shootCooldown: z.shootCooldown || 0
                })),
                projectiles: gameState.projectiles.map(p => ({
                    row: p.row,
                    x: p.x,
                    damage: p.damage,
                    slow: p.slow,
                    fire: p.fire,
                    pierce: p.pierce,
                    stunDuration: p.stunDuration,
                    emoji: p.element.textContent,
                    owner: p.owner,
                    splashDamage: p.splashDamage || 0,
                    splashRadiusY: p.splashRadiusY || 0,
                    hitZombies: p.hitZombies || [],
                    hitTorchwoods: p.hitTorchwoods || [],
                    range: p.range,
                    startX: p.startX
                })),

                flyingOctopuses: gameState.flyingOctopuses.map(o => ({
                    x: o.x,
                    y: o.y,
                    targetPlantId: o.targetPlantId
                })),

                // Board State
                graves: gameState.graves.map(g => ({ row: g.row, col: g.col })),
                craters: Array.from(document.querySelectorAll('.cell.crater')).map(cell => ({
                    row: parseInt(cell.dataset.row),
                    col: parseInt(cell.dataset.col)
                })),

                lawnmowers: gameState.lawnmowers
                    .filter(m => m.element !== null) // Only save mowers that are still on the board
                    .map(m => ({
                        row: m.row,
                        x: m.x,
                        moving: m.moving
                    })),

                suns: Array.from(document.querySelectorAll('.sun')).map(sunEl => {
                    const sunTimer = Object.values(gameState.timers).find(t => t.type === 'sunDespawn' && t.context === sunEl.dataset.sunId);
                    const rect = sunEl.getBoundingClientRect();
                    return {
                        id: sunEl.dataset.sunId,
                        value: parseInt(sunEl.querySelector('.sun-value')?.textContent || '50'),
                        emoji: sunEl.querySelector('span:first-child').textContent,
                        // Save position relative to the game container, not the whole window
                        x: rect.left - gameState.boardRect.left,
                        y: rect.top - gameState.boardRect.top,
                        remaining: sunTimer ? sunTimer.remaining : 7000 // Default life if timer not found
                    };
                }),

                // Timers
                timers: Object.values(gameState.timers)
                    .filter(t => t.type !== 'cardCooldown'
                        && t.type !== 'zombieEndThrowAnim'
                        && t.type !== 'octoLaunch'
                        && t.type !== 'remove_damage-effect'
                        && t.type !== 'remove_plant-damage-effect'
                        && t.type !== 'remove_shooting'
                        && t.type !== 'reset_zombie_transition'
                        && t.type !== 'add_chewing'
                        && t.type !== 'fadeout_fire_effect'
                        && t.type !== 'remove_fireEffect'
                        && t.type !== 'marker_remove'
                        && t.type !== 'windElement_remove'
                        && t.type !== 'fireElement_remove'
                        && t.type !== 'remove_flying_imp_visual'
                        && t.type !== 'flash_sun_counter_reset'
                        && t.type !== 'flash_sun_counter_cleanup'
                        && t.type !== 'remove_grave-spawn'
                        && t.type !== 'remove_explosionElement'
                        && t.type !== 'remove_doomshroom_visual'
                        && t.type !== 'remove_iceshroom_visual')
                    .map(t => ({
                        remaining: t.remaining,
                        delay: t.delay,
                        isInterval: t.isInterval,
                        type: t.type,
                        context: t.context
                    }))
            };

            // 2. Store in localStorage
            localStorage.setItem(`pvz_fullGameState_slot${slotNumber}`, JSON.stringify(serializableState));

            // 3. Show confirmation
            const notification = document.createElement('div');
            notification.className = 'save-notification';
            notification.textContent = 'ðŸ’¾ Game Saved!';
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2000);
        }

        function loadFullGameState(slotNumber) {
            if (!slotNumber) {
                console.error("Load function called without a slot number!");
                return;
            }
            const savedDataJSON = localStorage.getItem(`pvz_fullGameState_slot${slotNumber}`);

            if (!savedDataJSON) {
                showCustomDialog('No Save Data', 'There is no saved game to load.', [{ text: 'OK' }]);
                return;
            }

            try {
                const savedData = JSON.parse(savedDataJSON);

                // 1. Start a fresh game environment but don't start the loop yet
                if (gameState.gameLoopId) cancelAnimationFrame(gameState.gameLoopId);
                resetGame();
                createBoard();
                setupGameBoardListeners();
                setupZombieSpawner();

                // 2. Restore Challenges

                // Restore the active challenges from the save data FIRST
                if (savedData.activeChallenges) {
                    activeChallenges = savedData.activeChallenges;
                }

                // 3. Restore simple state
                gameState.sun = savedData.sun === null ? Infinity : savedData.sun;
                gameState.score = savedData.score;
                gameState.wave = savedData.wave;
                gameState.maxWaves = savedData.maxWaves === null ? Infinity : savedData.maxWaves;
                gameState.map = savedData.map;
                gameState.zombiesDefeated = savedData.zombiesDefeated;
                gameState.zombieDamageMultiplier = savedData.zombieDamageMultiplier;
                gameState.nextId = savedData.nextId;
                selectedPlantDeck = savedData.selectedPlantDeck;
                gameState.isSpawningComplete = savedData.isSpawningComplete;

                // 3. Set up the UI and board
                if (gameState.map === 'night') {
                    document.getElementById('gameContainer').classList.add('night-mode');
                }
                document.getElementById('plantSelectionScreen').style.display = 'none';
                document.getElementById('ui').style.visibility = 'visible';
                document.getElementById('wave').style.visibility = 'visible';

                populateInGameUI();
                updateBoardDimensions();
                updateSunDisplay();
                updateWaveDisplay();
                updateScoreDisplay();


                // --- LOGIC TO CONFIGURE THE UI BUTTON BASED ON GAME MODE ---
                const gameUiButton = document.getElementById('gameUiBtn');

                const newGameUiButton = gameUiButton.cloneNode(true);
                gameUiButton.parentNode.replaceChild(newGameUiButton, gameUiButton);

                if (activeChallenges.sandbox) {
                    // In Sandbox mode, it becomes the Zombie Spawner button.
                    newGameUiButton.innerHTML = 'ðŸ§Ÿ Spawner';
                    newGameUiButton.addEventListener('click', toggleSpawnerBar);
                } else {
                    // In Normal mode, it's the Leaderboard button.
                    newGameUiButton.innerHTML = 'ðŸ† Top 10';
                    newGameUiButton.addEventListener('click', showLeaderboard);
                }

                // 4a. Clear default lawnmowers and recreate from save data
                document.querySelectorAll('.lawnmower').forEach(el => el.remove()); // Remove the default mowers from the screen
                gameState.lawnmowers = []; // Clear the default mower objects from the game state

                savedData.lawnmowers.forEach(mowerData => {
                    const mower = document.createElement('div');
                    mower.className = 'lawnmower';
                    mower.textContent = 'ðŸšœ';

                    // Calculate the vertical position based on the saved row
                    const yPosition = gameState.boardRect.top + mowerData.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 20;

                    mower.style.position = 'fixed';
                    mower.style.top = yPosition + 'px';
                    // Set the horizontal position based on the saved 'x' value
                    mower.style.left = (gameState.boardRect.left + mowerData.x) + 'px';

                    document.getElementById('gameContainer').appendChild(mower);

                    // Add the fully restored lawnmower object back to the game state
                    gameState.lawnmowers.push({
                        element: mower,
                        row: mowerData.row,
                        x: mowerData.x,
                        moving: mowerData.moving
                    });
                });


                // 4b. Recreate all other game objects
                savedData.graves.forEach(g => {
                    const cell = document.querySelector(`.cell[data-row='${g.row}'][data-col='${g.col}']`);
                    if (cell) {
                        cell.classList.add('grave');
                        gameState.graves.push({ row: g.row, col: g.col, element: cell });
                    }
                });

                // Restore craters
                savedData.craters.forEach(craterData => {
                    const cell = document.querySelector(`.cell[data-row='${craterData.row}'][data-col='${craterData.col}']`);
                    if (cell) {
                        cell.classList.add('crater');
                    }
                });

                if (savedData.suns) {
                    savedData.suns.forEach(sunData => recreateSun(sunData));
                }

                savedData.projectiles.forEach(p => recreateProjectile(p));

                if (savedData.flyingOctopuses) {
                    savedData.flyingOctopuses.forEach(o => recreateFlyingOctopus(o));
                }

                // 5. Restore timers (this is the most complex part)
                gameState.timers = {}; // Clear any default timers
                savedData.timers.forEach(t => recreateTimer(t));

                savedData.plants.forEach(p => recreatePlant(p));
                savedData.zombies.forEach(z => recreateZombie(z));

                // 6. Restore card cooldowns
                savedData.cardCooldowns.forEach(cd => {
                    const card = document.querySelector(`#plantSelection .plantCard[data-plant='${cd.plant}'][data-is-imitated='${cd.isImitated}']`);
                    if (card) {
                        restoreCooldown(card, cd.remaining, cd.delay);
                    }
                });

                // 7. Relink dancers to their leaders
                relinkDancers();

                // 8. Resume the game
                resumeGame();
                startGameLoop();
            } catch (error) {
                // This code runs ONLY if an error occurred in the 'try' block

                console.error("Error loading saved game:", error);

                showCustomDialog(
                    'âš ï¸ Load Failed',
                    'The saved game data appears to be corrupted and could not be loaded. The game will restart.',
                    [{ text: 'OK', class: 'secondary', callback: restartGame }]
                );
            }
        }

        function recreatePlant(plantData) {
            const cell = document.querySelector(`.cell[data-row='${plantData.row}'][data-col='${plantData.col}']`);
            if (!cell) return;

            const plantTypeInfo = plantTypes[plantData.type];
            if (!plantTypeInfo) {
                console.warn(`Unknown plant: '${plantData.type}'. Skipped.`);
                return;
            }
            const plant = {
                ...plantData,
                element: null,
                healthBar: null,
                healthFill: null
            };

            const plantElement = document.createElement('div');
            plantElement.className = 'plant';
            plantElement.classList.add('plant-spawn');
            if (plant.isImitated) plantElement.classList.add('imitated');
            if (plantTypeInfo.isSpike) plantElement.classList.add('spike-plant');
            if (plantTypeInfo.isActivatingPlant) plantElement.classList.add('activating');
            plantElement.textContent = plantTypeInfo.emoji;

            if (plantTypeInfo.isGraveBuster) {
                plantElement.classList.add('eating-grave');
                plantElement.style.zIndex = '2';
            }

            const healthBar = document.createElement('div');
            healthBar.className = 'plant-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'plant-health-fill';
            healthBar.appendChild(healthFill);
            plantElement.appendChild(healthBar);

            cell.appendChild(plantElement);
            createTimer(500, () => {
                if (plantElement) {
                    plantElement.classList.remove('plant-spawn');
                }
            }, false, 'remove_spawn_animation_recreate');
            plant.element = plantElement;
            plant.healthBar = healthBar;
            plant.healthFill = healthFill;

            if (plant.isSleeping) plantElement.classList.add('sleeping');
            if (plant.isChewing) plantElement.classList.add('chewing');
            if (plant.isArming) plantElement.classList.add('arming');
            if (plant.isArmed) plantElement.classList.add('armed');

            if (plantData.isWrapped) {
                plant.isWrapped = true;
                plant.wrapTimer = plantData.wrapTimer;
                const octopusOverlay = document.createElement('div');
                octopusOverlay.className = 'plant-octopus-overlay';
                octopusOverlay.textContent = 'ðŸ™';
                plantElement.appendChild(octopusOverlay);
                plant.octopusElement = octopusOverlay;
            }

            if (plant.type === 'sunshroom') {
                if (plant.isGrown) {
                    plantElement.style.transform = 'translate(-50%, -50%) scale(1)';
                } else {
                    plantElement.classList.add('arming');
                }
            }

            updatePlantHealth(plant);
            gameState.plants.push(plant);
        }

        function recreateZombie(zombieData) {
            const zombieType = zombieTypes[zombieData.type];
            if (!zombieType) {
                console.warn(`Unknown zombie: '${zombieData.type}'. Skipped.`);
                return;
            }

            const zombieElement = document.createElement('div');
            zombieElement.className = 'zombie';

            // Add classes for specific zombie styles based on the saved type
            const typeKey = zombieData.type;
            if (typeKey === 'dancing') zombieElement.classList.add('dancing');
            if (typeKey === 'zomboni') zombieElement.classList.add('zomboni');
            if (typeKey === 'gargantuar' || typeKey === 'giga') zombieElement.classList.add('gargantuar');
            if (typeKey === 'imp') zombieElement.classList.add('imp');
            if (typeKey === 'jackInTheBox') zombieElement.classList.add('jackInTheBox');

            const baseEmoji = document.createElement('span');
            baseEmoji.textContent = zombieType.emoji;
            if (zombieData.type === 'balloon' && !zombieData.isFlying) {
                baseEmoji.textContent = 'ðŸ§Ÿ'; // Override the emoji to the normal one
            }
            zombieElement.appendChild(baseEmoji);

            if (zombieType.attachments && !zombieData.armorBroken) {
                zombieType.attachments.forEach(att => {
                    const attachmentEl = document.createElement('span');
                    attachmentEl.className = 'zombie-attachment';
                    attachmentEl.textContent = att.emoji;
                    attachmentEl.style.right = `${att.offset.x}px`;
                    attachmentEl.style.top = `${att.offset.y}px`;
                    zombieElement.appendChild(attachmentEl);
                });
            }

            const healthBar = document.createElement('div');
            healthBar.className = 'zombie-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'zombie-health-fill';
            healthBar.appendChild(healthFill);
            zombieElement.appendChild(healthBar);

            const yPosition = gameState.boardRect.top + zombieData.row * gameState.cellSize.height + (zombieData.isFlying ? -10 : gameState.cellSize.height / 2 - 20) + (zombieData.row * 2.5);
            zombieElement.style.position = 'fixed';
            zombieElement.style.left = (gameState.boardRect.left + zombieData.x) + 'px';
            zombieElement.style.top = yPosition + 'px';

            if (zombieData.slowed) zombieElement.classList.add('slowed');
            if (zombieData.isFrozen) zombieElement.classList.add('frozen');
            if (zombieData.isStunned) zombieElement.classList.add('stunned');

            if (zombieData.type === 'newspaper' && zombieData.armorBroken) {
                zombieElement.classList.add('enraged');
            }

            document.getElementById('gameContainer').appendChild(zombieElement);

            const zombieObj = {
                ...zombieData, // id, type, row, health, x, etc. (includes lastSummon and leaderId)
                element: zombieElement,
                healthBar: healthBar,
                healthFill: healthFill,
                attacking: false,
                attackCooldown: 0,
                dancers: []
            };

            updateZombieHealth(zombieObj);
            gameState.zombies.push(zombieObj);
        }

        function recreateProjectile(projData) {
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            if (projData.fire) projectile.classList.add('fire');
            projectile.textContent = projData.emoji;

            const rowY = gameState.boardRect.top + projData.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 10;
            projectile.style.left = (gameState.boardRect.left + projData.x) + 'px';
            projectile.style.top = rowY + 'px';
            projectile.style.position = 'fixed';

            document.getElementById('gameContainer').appendChild(projectile);

            const proj = {
                ...projData, // Copies all saved data like damage, slow, fire, splashDamage, etc.
                element: projectile,
                speed: projData.owner === 'zombie' ? -200 : 200,
                hitZombies: projData.hitZombies || [],
                hitTorchwoods: projData.hitTorchwoods || []
            };

            gameState.projectiles.push(proj);
        }

        function recreateFlyingOctopus(octopusData) {
            const octopusElement = document.createElement('div');
            octopusElement.className = 'flying-octopus';
            octopusElement.textContent = 'ðŸ™';
            octopusElement.style.position = 'fixed';
            octopusElement.style.left = octopusData.x + 'px';
            octopusElement.style.top = octopusData.y + 'px';

            document.getElementById('gameContainer').appendChild(octopusElement);

            gameState.flyingOctopuses.push({
                ...octopusData, // This carries over x, y, and targetPlantId
                element: octopusElement
            });
        }

        function relinkDancers() {
            const leaders = gameState.zombies.filter(z => z.type === 'dancing');
            const dancers = gameState.zombies.filter(z => z.leaderId !== null);

            dancers.forEach(dancer => {
                const leader = leaders.find(l => l.id === dancer.leaderId);
                if (leader) {
                    leader.dancers.push(dancer);
                    dancer.leader = leader;
                }
            });
        }

        function fireZombieProjectile(zombie) {
            if (!zombie || !zombie.element) return;

            const zombieType = zombieTypes[zombie.type];
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            projectile.textContent = zombieType.projectile;
            projectile.style.position = 'fixed';

            const zombieRect = zombie.element.getBoundingClientRect();
            const startX = zombieRect.left - gameState.boardRect.left - 20; // Spawn 20px in front
            const startY = zombieRect.top + (zombieRect.height / 2) - 10 - gameState.boardRect.top;

            projectile.style.left = (gameState.boardRect.left + startX) + 'px';
            projectile.style.top = (gameState.boardRect.top + startY) + 'px';

            document.getElementById('gameContainer').appendChild(projectile);

            gameState.projectiles.push({
                element: projectile,
                row: zombie.row,
                x: startX,
                damage: zombieType.damage,
                speed: -200,
                owner: 'zombie',
                hitZombies: [],
                hitTorchwoods: []
            });
        }

        function recreateTimer(timerData) {
            let callback = () => { };

            switch (timerData.type) {
                case 'waveTimer':
                    callback = () => {
                        if (!gameState.isGameOver && !gameState.isVictory && gameState.wave < gameState.maxWaves) {
                            gameState.wave++;
                            gameState.zombieDamageMultiplier = 1 + (gameState.wave - 1) * 0.02;
                            updateWaveDisplay();
                            updateDamageDisplay();
                            addScore(100 * gameState.wave);
                            saveGameState();
                            spawnZombieWave();
                        }
                    };
                    break;

                case 'plantActivation':
                    callback = () => {
                        const plant = gameState.plants.find(p => p.id === timerData.context);
                        if (plant) activatePlantEffect(plant);
                    };
                    break;

                case 'mushroomEffectTrigger':
                    callback = () => {
                        const plant = gameState.plants.find(p => p.id === timerData.context);
                        if (plant) triggerMushroomEffect(plant);
                    };
                    break;

                case 'sunInterval':
                    callback = () => spawnFallingSun();
                    break;

                case 'plantArming':
                    callback = () => {
                        const plant = gameState.plants.find(p => p.id === timerData.context);
                        if (plant) {
                            plant.isArmed = true;
                            plant.isArming = false;
                            if (plant.element) {
                                plant.element.classList.remove('arming');
                                plant.element.classList.add('armed');
                            }
                        }
                    };
                    break;

                case 'plantLifespan':
                    callback = () => {
                        const plantToExpire = gameState.plants.find(p => p.id === timerData.context);
                        if (plantToExpire && plantToExpire.element) {
                            plantToExpire.element.style.transition = 'opacity calc(1s / var(--game-speed)) ease-out';
                            plantToExpire.element.style.opacity = '0';
                            createTimer(1000, () => {
                                if (plantToExpire.element) plantToExpire.element.remove();
                                gameState.plants = gameState.plants.filter(p => p.id !== plantToExpire.id);
                            }, false, 'remove_temporary_plant');
                        }
                    };
                    break;

                case 'jackInTheBoxExplosion':
                    callback = () => {
                        const zombie = gameState.zombies.find(z => z.id === timerData.context);
                        if (zombie) explodeJackInTheBox(zombie);
                    };
                    break;

                case 'zombieBurstShot':
                    callback = () => {
                        const zombie = gameState.zombies.find(z => z.id === timerData.context);
                        if (zombie) fireZombieProjectile(zombie);
                    };
                    break;

                case 'zombieEndAttack':
                    callback = () => {
                        const zombie = gameState.zombies.find(z => z.id === timerData.context);
                        if (zombie) zombie.attacking = false;
                    };
                    break;

                case 'iceTrailMelt':
                    if (timerData.context && typeof timerData.context === 'object') {
                        const { row, col } = timerData.context;
                        const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
                        if (cell) {
                            cell.classList.add('iced');
                            callback = () => {
                                if (cell) cell.classList.remove('iced');
                                const index = gameState.iceTrails.findIndex(t => t.row === row && t.col === col);
                                if (index !== -1) gameState.iceTrails.splice(index, 1);
                            };
                        }
                    }
                    break;

                case 'graveBuster':
                    callback = () => {
                        const plant = gameState.plants.find(p => p.id === timerData.context);
                        if (!plant) return; // Plant might have been eaten before timer fired

                        const row = plant.row;
                        const col = plant.col;
                        const plantIndex = gameState.plants.indexOf(plant);
                        if (plantIndex === -1) return;

                        const graveIndex = gameState.graves.findIndex(g => g.row === row && g.col === col);
                        if (graveIndex !== -1) {
                            const graveToRemove = gameState.graves[graveIndex];
                            if (graveToRemove.element) graveToRemove.element.classList.remove('grave');
                            gameState.graves.splice(graveIndex, 1);
                        }

                        const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
                        if (cell) {
                            const sunValue = Math.random() < 0.2 ? 75 : 25;
                            const emoji = sunValue === 75 ? 'ðŸ’°' : 'ðŸµï¸';
                            const sun = document.createElement('div');
                            sun.className = 'sun';
                            sun.innerHTML = `<span>${emoji}</span><span class="sun-value" style="display: none;">${sunValue}</span>`;
                            const rect = cell.getBoundingClientRect();
                            sun.style.left = (rect.left + rect.width / 2 - 15) + 'px';
                            sun.style.top = (rect.top + rect.height / 2 - 15) + 'px';
                            sun.style.position = 'fixed';
                            document.getElementById('gameContainer').appendChild(sun);
                            sun.addEventListener('click', () => collectSun(sun, sunValue));
                            const sunId = `sun-${gameState.nextId++}`;
                            createTimer(7000, () => { if (sun.parentElement && !sun.dataset.collecting) { sun.style.opacity = '0'; createTimer(500, () => sun.remove(), false, 'sun_remove'); } }, false, 'sunDespawn', sunId);
                        }

                        if (plant.element) plant.element.remove();
                        gameState.plants.splice(plantIndex, 1);
                        updatePlantCardAvailability();
                    };
                    break;

                case 'nextWave':
                    callback = () => {
                        if (!gameState.isGameOver && !gameState.isVictory) {
                            gameState.wave++;
                            gameState.zombieDamageMultiplier = 1 + (gameState.wave - 1) * 0.02;
                            updateWaveDisplay();
                            updateDamageDisplay();
                            addScore(100 * gameState.wave);
                            saveGameState();
                            spawnZombieWave();
                        }
                    };
                    break;

                case 'craterRemoval':
                    if (timerData.context) {
                        const { row, col } = timerData.context;
                        callback = () => {
                            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
                            if (cell) cell.classList.remove('crater');
                        };
                    }
                    break;

                case 'waveZombieSpawn':
                    callback = () => {
                        if (!gameState.isGameOver && !gameState.isVictory) spawnZombie(timerData.context);
                    };
                    break;

                case 'waveSpawningComplete':
                    callback = () => { gameState.isSpawningComplete = true; };
                    break;

                case 'sunDespawn':
                    if (timerData.context) {
                        callback = () => {
                            const sun = document.querySelector(`.sun[data-sun-id='${timerData.context}']`);
                            if (sun && sun.parentElement && !sun.dataset.collecting) {
                                sun.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease-in, transform calc(0.5s / var(--game-speed)) ease-in';
                                sun.style.opacity = '0';
                                sun.style.transform = 'scale(0.5)';
                                createTimer(500, () => sun.remove(), false, 'sun_remove');
                            }
                        };
                    }
                    break;

                case 'graveZombieSpawn':
                    if (timerData.context) {
                        const { row, col } = timerData.context;
                        callback = () => {
                            if (!gameState.isGameOver && !gameState.isVictory) spawnZombieFromGrave(row, col);
                        };
                    }
                    break;
                case 'plantGrowth':
                    callback = () => {
                        const plant = gameState.plants.find(p => p.id === timerData.context);
                        if (plant && plant.element) {
                            plant.isGrown = true;
                            plant.element.classList.remove('arming');
                            plant.element.style.transform = 'translate(-50%, -50%) scale(1)';
                        }
                    };
                    break;
            }

            if (callback) {
                const timerId = createTimer(timerData.delay, callback, timerData.isInterval, timerData.type, timerData.context);
                if (gameState.timers[timerId]) {
                    gameState.timers[timerId].remaining = timerData.remaining;
                }

                if (timerData.type === 'waveTimer') {
                    gameState.waveTimerId = timerId;
                }

                if (timerData.type === 'iceTrailMelt') {
                    const { row, col } = timerData.context;
                    const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
                    if (cell) {
                        gameState.iceTrails.push({ row, col, cellElement: cell, timerId: timerId });
                    }
                }
            }
        }

        let currentSaveLoadMode = 'save';

        /**
         * Opens and populates the save/load menu.
         * This function now creates a more complex UI with delete buttons.
         */
        function openSaveLoadMenu(mode) {
            currentSaveLoadMode = mode;
            const menu = document.getElementById('saveLoadMenu');
            const title = document.getElementById('saveLoadTitle');
            const slotsContainer = document.getElementById('slotListContainer');
            slotsContainer.innerHTML = ''; // Clear previous slots

            title.textContent = (mode === 'save') ? 'Save Game' : 'Load Game';

            // Loop up to 9 for the maximum number of slots
            for (let i = 1; i <= 9; i++) {
                const slotKey = `pvz_fullGameState_slot${i}`;
                const savedData = localStorage.getItem(slotKey);
                let slotInfo = 'Empty';

                if (savedData) {
                    try {
                        const parsedData = JSON.parse(savedData);
                        slotInfo = `Wave: ${parsedData.wave} | Score: ${parsedData.score.toLocaleString()}`;
                    } catch (e) {
                        slotInfo = 'Corrupted Data';
                    }
                }

                // Create the main container for the slot
                const slotEntry = document.createElement('div');
                slotEntry.className = 'slot-entry';

                // Create the main save/load button
                const slotButton = document.createElement('button');
                slotButton.className = 'btn slot-button';
                slotButton.innerHTML = `<strong>Slot ${i}</strong><br><small style="font-weight: normal;">${slotInfo}</small>`;
                slotButton.onclick = () => handleSlotClick(i);

                if (mode === 'load' && !savedData) {
                    slotButton.disabled = true;
                }

                // Create the delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'btn delete-slot-btn';
                deleteButton.innerHTML = 'ðŸ—‘ï¸';
                deleteButton.disabled = !savedData;
                deleteButton.onclick = (event) => {
                    event.stopPropagation();
                    deleteSaveSlot(i);
                };

                slotEntry.appendChild(slotButton);
                slotEntry.appendChild(deleteButton);
                slotsContainer.appendChild(slotEntry);
            }

            menu.style.display = 'flex';
        }

        /**
         * Handles the click on a main slot button, including overwrite confirmation.
         */
        function handleSlotClick(slotNumber) {
            if (currentSaveLoadMode === 'load') {
                loadFullGameState(slotNumber);
                closeSaveLoadMenu();
            } else {
                const slotKey = `pvz_fullGameState_slot${slotNumber}`;
                const existingData = localStorage.getItem(slotKey);

                if (existingData) {
                    showCustomDialog(
                        'Confirm Overwrite',
                        `<strong>Slot ${slotNumber}</strong> already contains saved data. Are you sure you want to overwrite it?`,
                        [
                            { text: 'Cancel' },
                            {
                                text: 'Overwrite',
                                class: 'secondary',
                                callback: () => {
                                    saveFullGameState(slotNumber);
                                    closeSaveLoadMenu();
                                }
                            }
                        ]
                    );
                } else {
                    // If the slot is empty, save directly
                    saveFullGameState(slotNumber);
                    closeSaveLoadMenu();
                }
            }
        }

        /**
         * Deletes a save file from a specific slot after confirmation.
         */
        function deleteSaveSlot(slotNumber) {
            showCustomDialog(
                'Confirm Deletion',
                `Are you sure you want to permanently delete the save in Slot ${slotNumber}? This cannot be undone.`,
                [
                    { text: 'Cancel' },
                    {
                        text: 'Delete',
                        class: 'restart',
                        callback: () => {
                            localStorage.removeItem(`pvz_fullGameState_slot${slotNumber}`);
                            openSaveLoadMenu(currentSaveLoadMode);
                        }
                    }
                ]
            );
        }

        function closeSaveLoadMenu() {
            document.getElementById('saveLoadMenu').style.display = 'none';
        }
        document.getElementById('closeSaveLoadMenuBtn').addEventListener('click', closeSaveLoadMenu);

        // --- FPS GRAPH LOGIC ---

        const fpsHistory = new Array(150).fill(60); // Store last 150 frames (approx 2.5 seconds)
        let fpsRecordingData = [];
        let isRecordingFPS = false;
        let recordingStartTime = 0;

        window.startFPSrec = function () {
            fpsRecordingData = [];
            isRecordingFPS = true;
            recordingStartTime = Date.now();
            console.log('%c ðŸ”´ FPS Recording Started...', 'color: red; font-weight: bold;');
            console.log('Type finishFPSrec() to stop and download.');
        };

        window.finishFPSrec = function () {
            if (!isRecordingFPS) {
                console.warn('FPS recording is not active.');
                return;
            }
            isRecordingFPS = false;
            const duration = ((Date.now() - recordingStartTime) / 1000).toFixed(2);

            console.log(`%c â¹ï¸ Recording Finished. Duration: ${duration}s. Frames: ${fpsRecordingData.length}`, 'color: green; font-weight: bold;');

            let fileContent = `FPS Recording Log\nDate: ${new Date().toLocaleString()}\nDuration: ${duration} seconds\nTotal Frames Captured: ${fpsRecordingData.length}\n\nTimestamp(ms)\tFPS\n`;

            fpsRecordingData.forEach(entry => {
                fileContent += `${entry.time}\t${entry.fps}\n`;
            });

            const fpsValues = fpsRecordingData.map(e => e.fps);
            const avg = Math.round(fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length);
            const min = Math.min(...fpsValues);
            const max = Math.max(...fpsValues);
            const onePercentLow = fpsValues.sort((a, b) => a - b)[Math.floor(fpsValues.length * 0.01)];

            fileContent = fileContent.replace('Timestamp(ms)', `Session Min: ${min} | Max: ${max} | Avg: ${avg} | 1% Low: ${onePercentLow}\n\nTimestamp(ms)`);

            const blob = new Blob([fileContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pvz_fps_log_${Date.now()}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        function updateFpsGraph(currentFps) {
            const canvas = document.getElementById('fpsGraph');
            const ctx = canvas.getContext('2d', { alpha: false });

            // 1. Update Data
            fpsHistory.push(currentFps);
            fpsHistory.shift();

            // 2. Clear
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 3. Draw Graph
            ctx.beginPath();

            // Dynamic scaling: Logic implies 60fps is "top" of graph (0 y), 0fps is bottom (height)
            const maxFps = 65;
            const w = canvas.width;
            const h = canvas.height;
            const step = w / (fpsHistory.length - 1);

            for (let i = 0; i < fpsHistory.length; i++) {
                const fps = fpsHistory[i];
                const y = h - (Math.min(fps, maxFps) / maxFps) * h;

                if (i === 0) {
                    ctx.moveTo(0, y);
                } else {
                    ctx.lineTo(i * step, y);
                }
            }

            // 4. Style & Stroke
            if (currentFps > 50) ctx.strokeStyle = '#00ff00'; // Green
            else if (currentFps > 30) ctx.strokeStyle = '#ffff00'; // Yellow
            else ctx.strokeStyle = '#ff0000'; // Red

            ctx.lineWidth = 1.5;
            ctx.stroke();

            // 5. Draw 30 FPS and 60 FPS guide lines
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            const y30 = h - (30 / maxFps) * h;
            ctx.fillRect(0, y30, w, 1);
        }

        // --- ALMANAC FUNCTIONS ---

        function showAlmanac() {
            populateAlmanac();
            document.getElementById('almanacScreen').style.display = 'flex';
        }

        function closeAlmanac() {
            document.getElementById('almanacScreen').style.display = 'none';
        }

        function getSpeedText(speedValue) {
            if (speedValue <= 5) return 'Very Slow';
            if (speedValue <= 12) return 'Slow';
            if (speedValue <= 16) return 'Normal';
            if (speedValue <= 20) return 'Fast';
            return 'Very Fast';
        }

        const almanacData = {
            normal: { name: 'Zombie', description: 'Just your standard, garden-variety, brain-eating zombie. A classic for a reason.' },
            flag: { name: 'Flag Zombie', description: 'The Flag Zombie marks the arrival of a huge wave. He\'s no tougher than a regular zombie, but what he represents is.' },
            cone: { name: 'Conehead Zombie', description: 'The traffic cone on his head provides more protection than you\'d think, almost tripling his toughness.' },
            fast: { name: 'Pole Vault Zombie', description: 'Moves quickly and uses his pole to leap over the first plant he encounters, making him a tricky initial threat.', special: 'Cant leap at all...' },
            newspaper: { name: 'Newspaper Zombie', description: 'He just wants to be left alone to read his paper. Destroy it, and he\'ll unleash a burst of speed and fury.', special: 'Enrages when newspaper is destroyed.' },
            bucket: { name: 'Buckethead Zombie', description: 'The metal bucket on his head offers extreme protection, allowing him to absorb a massive amount of damage.' },
            jackInTheBox: { name: 'Jack-in-the-Box Zombie', description: 'This zombie is a ticking time bomb. He\'ll randomly pop, destroying all plants and zombies in a wide area.', special: 'Explodes randomly.' },
            balloon: { name: 'Balloon Zombie', description: 'The Balloon Zombie floats serenely over your defenses, immune to most attacks. Only sharp projectiles or a strong gust of wind can bring him down.', special: 'Floats over plants.' },
            dancing: { name: 'Dancing Zombie', description: 'The life of the party, the Dancing Zombie moonwalks across the lawn, summoning a troupe of Backup Dancers to protect him.', special: 'Summons Backup Dancers.' },
            backupDancer: { name: 'Backup Dancer', description: 'These zombies appear suddenly on the dance floor, ready to backup their leader.' },
            football: { name: 'Football Zombie', description: 'Clad in full gear, the Football Zombie charges down the field with incredible speed and toughness. He\'s a one-zombie wrecking crew.' },
            zomboni: { name: 'Zomboni', description: 'This ice-resurfacing machine will crush any plant in its path, leaving a trail of ice that cannot be planted on.', special: 'Crushes plants & leaves ice trail.' },
            trashCanZombie: { name: 'Trash Can Zombie', description: 'His trash can acts as a shield, absorbing a lot of damage. While holding it, he\'s also immune to slowing and fire splash effects.', special: 'Unaffected by snow and fire while has a can' },
            gargantuar: { name: 'Gargantuar', description: 'A colossal zombie that crushes your plants with a single smash. When badly wounded, he will hurl a small Imp deep into your defenses.', special: 'Crushes plants & throws an Imp.' },
            imp: { name: 'Imp', description: 'Small, fast, and annoying. The Imp is often seen being hurled deep into your defenses by a Gargantuar.' },
            octoZombie: { name: 'Octo Zombie', description: 'This deep-sea menace lobs octopuses at your plants, wrapping them up and completely disabling their abilities for a while.', special: 'Throws octopuses to disable plants.' },
            peashooterZombie: { name: 'Peashooter Zombie', description: 'It seems some zombies have learned to fight back. This one uses its own Peashooter head to fire peas at your plants.', special: 'Shoots peas at your plants.' },
            giga: { name: 'Giga-Gargantuar', description: 'If you thought the Gargantuar was bad, wait until you meet his bigger, meaner cousin. The Giga-Gargantuar is incredibly tough and just as destructive.', special: 'Crushes plants & throws an Imp.' },
            wallnutZombie: { name: 'Wall-nut Zombie', description: 'This clever zombie uses a Wall-nut as a helmet, giving it a huge amount of health.' },
            gatlingZombie: { name: 'Gatling Zombie', description: 'An upgraded version of the Peashooter Zombie, this one fires a rapid four-pea burst, quickly overwhelming single targets.', special: 'Shoots a burst of four peas.' },
            tallnutZombie: { name: 'Tall-nut Zombie', description: 'Sporting a Tall-nut for a helmet, this zombie is extremely durable and is too tall for Pole Vaulting Zombies to jump over.' },
            gigafootball: { name: 'Giga-Football Zombie', description: 'The all-star of the undead league. He\'s even faster and tougher than the regular Football Zombie, making him a high-priority threat.' },
            rally: { name: 'Rally Zombie', description: 'A tougher version of the Flag Zombie, appearing only during the most intense final waves. He\'s faster, stronger, and signals a massive assault.' },
            zomboss: { name: 'Dr. Zomboss', description: 'The mastermind behind the invasion. Dr. Zomboss pilots a massive Zombot that can crush plants, summon zombies, and unleash devastating elemental attacks.', special: 'Summons zombies & attacks lanes.' }
        };

        function getHealthText(health) {
            if (health <= 10) return 'Very Low';
            if (health <= 20) return 'Low';
            if (health <= 70) return 'Medium';
            if (health <= 150) return 'High';
            if (health <= 300) return 'Very High';
            return 'Extreme';
        }

        function getHealthBarHTML(health) {
            let barClass = 'low';
            if (health > 20) barClass = 'medium';
            if (health > 70) barClass = 'high';
            if (health > 300) barClass = 'extreme';

            const maxHealthValue = 300; // Cap for visual representation, giga is 300, zomboss is 2000
            const widthPercent = Math.min(100, (health / maxHealthValue) * 100);

            return `
                <div class="almanac-health-bar">
                    <div class="almanac-health-fill ${barClass}" style="width: ${widthPercent}%"></div>
                </div>
            `;
        }

        // Reusable zombie visual creator
        function createZombieVisual(typeKey) {
            const zombieType = zombieTypes[typeKey];
            if (!zombieType) return null;

            const zombieVisual = document.createElement('div');
            zombieVisual.className = 'zombie';

            // Apply specific classes for sizing and styling
            if (typeKey === 'zomboni') zombieVisual.classList.add('zomboni');
            if (typeKey === 'gargantuar' || typeKey === 'giga') zombieVisual.classList.add('gargantuar');
            if (typeKey === 'imp') zombieVisual.classList.add('imp');

            // These styles are for standalone display
            zombieVisual.style.position = 'relative';
            zombieVisual.style.transform = 'scaleX(-1)';
            zombieVisual.style.pointerEvents = 'none';

            const baseEmoji = document.createElement('span');
            baseEmoji.textContent = zombieType.emoji;
            zombieVisual.appendChild(baseEmoji);

            if (zombieType.attachments) {
                zombieType.attachments.forEach(att => {
                    const attachmentEl = document.createElement('span');
                    attachmentEl.className = 'zombie-attachment';
                    attachmentEl.textContent = att.emoji;
                    attachmentEl.style.right = `${att.offset.x}px`;
                    attachmentEl.style.top = `${att.offset.y}px`;
                    zombieVisual.appendChild(attachmentEl);
                });
            }
            return zombieVisual;
        }

        function populateAlmanac() {
            const list = document.getElementById('almanacZombieList');
            list.innerHTML = '';
            document.getElementById('almanacZombieDetails').innerHTML = ''; // Clear details
            document.getElementById('almanacZombieDetails').style.display = 'none'; // Hide details

            const encountered = JSON.parse(localStorage.getItem('pvz_encountered_zombies')) || [];
            let firstEncounteredType = null;

            for (const typeKey in zombieTypes) {
                if (zombieTypes.hasOwnProperty(typeKey)) {
                    const iconCard = document.createElement('div');
                    iconCard.className = 'almanac-icon-card';
                    iconCard.dataset.zombieType = typeKey;

                    const visualContainer = document.createElement('div');
                    visualContainer.className = 'almanac-visual';
                    const zombieVisual = createZombieVisual(typeKey);
                    if (zombieVisual) {
                        visualContainer.appendChild(zombieVisual);
                    }
                    iconCard.appendChild(visualContainer);

                    if (encountered.includes(typeKey)) {
                        if (!firstEncounteredType) {
                            firstEncounteredType = typeKey;
                        }
                        iconCard.addEventListener('click', () => displayAlmanacDetails(typeKey));
                    } else {
                        iconCard.classList.add('hidden');
                        iconCard.addEventListener('click', () => displayAlmanacDetails(typeKey)); // Still allow clicking to see "???"
                    }

                    list.appendChild(iconCard);
                }
            }

            // Automatically display the first zombie in the list that has been encountered
            if (firstEncounteredType) {
                displayAlmanacDetails(firstEncounteredType);
            }
        }

        function displayAlmanacDetails(typeKey) {
            const detailsPanel = document.getElementById('almanacZombieDetails');
            detailsPanel.innerHTML = ''; // Clear previous content

            // Highlight the correct icon in the list
            document.querySelectorAll('.almanac-icon-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.zombieType === typeKey);
            });

            const encountered = JSON.parse(localStorage.getItem('pvz_encountered_zombies')) || [];
            const zombie = zombieTypes[typeKey];
            const zombieInfo = almanacData[typeKey] || {};

            const visualContainer = document.createElement('div');
            visualContainer.className = 'almanac-visual';
            const zombieVisual = createZombieVisual(typeKey);
            if (zombieVisual) {
                zombieVisual.style.transform = 'scale(1.5) scaleX(-1)'; // Make it larger
                visualContainer.appendChild(zombieVisual);
            }
            detailsPanel.appendChild(visualContainer);

            const detailContent = document.createElement('div');
            detailContent.id = 'almanacDetailContent';

            if (encountered.includes(typeKey)) {
                const waveData = zombieWaveData[typeKey];
                let spawnText = (waveData && waveData.weight > 0) ? `From Wave ${waveData.minWave}` : (zombieInfo.spawnWave || 'Special');

                detailContent.innerHTML = `
                    <div class="almanac-name">${zombieInfo.name || typeKey}</div>
                    <div class="almanac-stats">
                        <div><span>Toughness:</span><span>${getHealthText(zombie.maxHealth)}</span></div>
                        ${getHealthBarHTML(zombie.maxHealth)}
                        <div><span>Speed:</span><span>${getSpeedText(zombie.speed)}</span></div>
                        <div><span>Spawns:</span><span>${spawnText}</span></div>
                        ${zombieInfo.special ? `<div><span>Special:</span><span>${zombieInfo.special}</span></div>` : ''}
                    </div>
                    <div class="almanac-desc">${zombieInfo.description || 'No data available.'}</div>
                `;
            } else {
                visualContainer.style.filter = 'brightness(0)';
                visualContainer.style.opacity = '0.5';
                detailContent.innerHTML = `
                    <div class="almanac-name">???</div>
                    <div class="almanac-desc">This zombie has not been encountered yet.</div>
                `;
            }

            detailsPanel.appendChild(detailContent);
            detailsPanel.style.display = 'flex';
        }

        function markZombieAsEncountered(zombieType) {
            let encounteredZombies = JSON.parse(localStorage.getItem('pvz_encountered_zombies')) || [];
            if (!encounteredZombies.includes(zombieType)) {
                encounteredZombies.push(zombieType);
                localStorage.setItem('pvz_encountered_zombies', JSON.stringify(encounteredZombies));
            }
        }

        // This function now only sets up listeners for dynamic or game-session-specific elements.
        function setupGameBoardListeners() {
            let lastTouchTime = 0;

            document.querySelectorAll('.cell').forEach(cell => {
                cell.addEventListener('click', () => {
                    if (Date.now() - lastTouchTime < 500) {
                        return;
                    }
                    placePlant(cell);
                });

                cell.addEventListener('touchstart', (e) => {
                    lastTouchTime = Date.now();
                    placePlant(cell);
                }, { passive: true });
            });

            document.getElementById('startGameBtn').addEventListener('click', confirmAndStartGame);
        }

        // This function sets up listeners for permanent UI elements and is only called ONCE.
        function setupUIEventListeners() {
            document.getElementById('pauseBtn').addEventListener('click', togglePause);

            document.getElementById('speedBtn').addEventListener('click', () => {
                gameState.gameSpeed = gameState.gameSpeed === 1 ? 2 : gameState.gameSpeed === 2 ? 3 : 1;
                const btn = document.getElementById('speedBtn');
                btn.textContent = `âš¡ x${gameState.gameSpeed}`;
                btn.classList.toggle('active', gameState.gameSpeed > 1);
                document.getElementById('gameContainer').style.setProperty('--game-speed', gameState.gameSpeed);
            });

            document.getElementById('leaderBtn').addEventListener('click', showLeaderboard);
            document.getElementById('almanacBtn').addEventListener('click', showAlmanac);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

            window.addEventListener('resize', updateBoardDimensions);

            document.addEventListener('fullscreenchange', () => {
                setTimeout(updateBoardDimensions, 100);
            });

            document.addEventListener('webkitfullscreenchange', () => {
                setTimeout(updateBoardDimensions, 100);
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'd' || e.key === 'D') {
                    const debugInfo = document.getElementById('debugInfo');
                    debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
                }
                if (e.key === 'z' || e.key === 'Z') {
                    toggleZombieSpawner();
                }
            });

            document.getElementById('challengesBtn').addEventListener('click', () => {
                document.getElementById('challengesScreen').style.display = 'flex';
            });

            document.getElementById('closeChallengesBtn').addEventListener('click', () => {
                document.getElementById('challengesScreen').style.display = 'none';
                resetGame();
                setupZombieSpawner();
            });

            document.querySelectorAll('.challenge-toggle input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const challenge = e.target.dataset.challenge;
                    activeChallenges[challenge] = e.target.checked;

                    // Handle mutually exclusive challenges
                    const fortyWavesCheckbox = document.getElementById('fortyWaves');
                    const endlessCheckbox = document.getElementById('endless');

                    if (challenge === 'fortyWaves' && e.target.checked) {
                        endlessCheckbox.checked = false;
                        activeChallenges.endless = false;
                    }
                    if (challenge === 'endless' && e.target.checked) {
                        fortyWavesCheckbox.checked = false;
                        activeChallenges.fortyWaves = false;
                    }
                });
            });
        }

        // Function to handle mouseover event for plant cards
        function handlePlantCardMouseOver(event) {
            const card = event.target.closest('.plantCard');
            if (!card || activeTooltip) return;

            if (card.classList.contains('in-library-hidden')) return;

            const plantName = card.dataset.plant;
            if (!plantName || !plantTypes[plantName] || !plantTypes[plantName].description) return;

            const description = plantTypes[plantName].description;

            activeTooltip = document.createElement('div');
            activeTooltip.className = 'plant-tooltip';
            activeTooltip.innerHTML = description;
            document.body.appendChild(activeTooltip);

            const cardRect = card.getBoundingClientRect();
            const tooltipRect = activeTooltip.getBoundingClientRect();
            const libraryContainer = document.getElementById('plantLibrary');
            const libraryRect = libraryContainer.getBoundingClientRect();
            const arrowSize = 8;
            const margin = 5;

            let top, left;
            left = cardRect.left + (cardRect.width / 2) - (tooltipRect.width / 2);

            if (cardRect.bottom + tooltipRect.height + arrowSize + margin < libraryRect.bottom) {
                top = cardRect.bottom + arrowSize;
                activeTooltip.classList.add('bottom');
            } else {
                top = cardRect.top - tooltipRect.height - arrowSize;
                activeTooltip.classList.add('top');
            }

            if (left < margin) left = margin;
            if (left + tooltipRect.width > window.innerWidth - margin) {
                left = window.innerWidth - tooltipRect.width - margin;
            }

            activeTooltip.style.top = `${top}px`;
            activeTooltip.style.left = `${left}px`;

            if (mobileDevice) {
                document.addEventListener('touchstart', handlePlantCardMouseOut, { once: true });
            }
        }

        // Function to handle mouseout event for plant cards
        function handlePlantCardMouseOut() {
            if (activeTooltip) {
                activeTooltip.remove();
                activeTooltip = null;
            }
            if (mobileDevice) {
                document.removeEventListener('touchstart', handlePlantCardMouseOut);
            }
        }

        // Sets up the plant selection listeners ONCE
        function setupPlantSelectionListeners() {
            const libraryGrid = document.getElementById('plantLibraryGrid');
            const deckBar = document.getElementById('deckBar');

            // Map chooser logic
            document.querySelectorAll('.mapOption').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelector('.mapOption.active').classList.remove('active');
                    option.classList.add('active');
                    gameState.map = option.dataset.map;
                });
            });

            // Main click listener for the library (using event delegation)
            libraryGrid.addEventListener('click', (event) => {
                const clickedCard = event.target.closest('.plantCard');
                if (!clickedCard || clickedCard.classList.contains('in-library-hidden')) return;

                const plantName = clickedCard.dataset.plant;
                const plantInfo = plantTypes[plantName];

                if (plantInfo.isImitater) {
                    // --- IMITATER LOGIC ---
                    if (!lastSelectedPlantForImitater) {
                        showCustomDialog(
                            'Imitater Plant',
                            'Please select a regular plant from the library first, which the Imitater will copy.',
                            [{ text: 'OK', class: 'secondary' }]
                        );
                        return;
                    }
                    if (plantTypes[lastSelectedPlantForImitater.type].isUpgrade) {
                        showCustomDialog(
                            'Imitater Plant',
                            `The Imitater cannot copy upgrade plants like <strong>${getPlantDisplayName(lastSelectedPlantForImitater.type)}</strong>.`,
                            [{ text: 'OK', class: 'secondary' }]
                        );
                        return;
                    }

                    const targetInfo = plantTypes[lastSelectedPlantForImitater.type];
                    const targetCost = lastSelectedPlantForImitater.cost;
                    const targetName = lastSelectedPlantForImitater.name;

                    const imitaterCardClone = clickedCard.cloneNode(true);
                    imitaterCardClone.dataset.plant = lastSelectedPlantForImitater.type;
                    imitaterCardClone.dataset.cost = targetCost;
                    imitaterCardClone.dataset.isImitated = 'true';
                    imitaterCardClone.classList.add('imitated');

                    imitaterCardClone.querySelector('.emoji').textContent = targetInfo.emoji;
                    imitaterCardClone.querySelector('.cost').textContent = targetCost;
                    imitaterCardClone.querySelector('.name').textContent = targetName;

                    deckBar.appendChild(imitaterCardClone);
                    selectedPlantDeck.push({ type: lastSelectedPlantForImitater.type, cost: targetCost, isImitated: true });

                    clickedCard.classList.add('in-library-hidden');
                } else {
                    // --- REGULAR PLANT LOGIC ---
                    const newDeckCard = clickedCard.cloneNode(true);
                    const plantNameText = clickedCard.querySelector('.name').textContent;
                    deckBar.appendChild(newDeckCard);
                    selectedPlantDeck.push({ type: plantName, cost: clickedCard.dataset.cost, isImitated: false });
                    lastSelectedPlantForImitater = { type: plantName, cost: clickedCard.dataset.cost, name: plantNameText };

                    clickedCard.classList.add('in-library-hidden');
                }

                document.getElementById('selectedPlantCount').textContent = selectedPlantDeck.length;
            });

            // Click listener for removing plants from the deck (using event delegation)
            deckBar.addEventListener('click', (event) => {
                const clickedCard = event.target.closest('.plantCard');
                if (clickedCard) {
                    handleRemoveFromDeck(clickedCard);
                }
            });

            // --- LOGIC FOR TOOLTIPS ---
            if (mobileDevice) {
                let touchStartX = 0;
                let touchStartY = 0;
                let isDragging = false;
                const dragThreshold = 10;

                libraryGrid.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    isDragging = false;
                }, { passive: true });

                libraryGrid.addEventListener('touchmove', (e) => {
                    if (isDragging) return;
                    const touch = e.touches[0];
                    const deltaX = Math.abs(touch.clientX - touchStartX);
                    const deltaY = Math.abs(touch.clientY - touchStartY);
                    if (deltaX > dragThreshold || deltaY > dragThreshold) {
                        isDragging = true;
                        // If it's a drag, hide any tooltip that might be visible
                        handlePlantCardMouseOut();
                    }
                }, { passive: true });

                libraryGrid.addEventListener('touchend', (e) => {
                    if (isDragging) return;

                    // If it was not a drag, it's a tap
                    const card = e.target.closest('.plantCard');
                    if (card) {
                        handlePlantCardMouseOut();
                        e.stopPropagation();
                        handlePlantCardMouseOver({ target: card });
                    }
                });

            } else {
                // On desktop, use the existing mouse hover behavior
                libraryGrid.addEventListener('mouseover', handlePlantCardMouseOver);
                libraryGrid.addEventListener('mouseout', handlePlantCardMouseOut);
            }
        }


        // --- Initialize Game ---
        function init() {
            createBoard();
            loadGameState();
            setupGameBoardListeners();
            setupUIEventListeners();
            setupPlantSelectionListeners();
            setupZombieSpawner();
            showPlantSelectionScreen();
            togglePause();
        }

        // --- Plant Selection Logic ---
        function handleRemoveFromDeck(deckCard) {
            const plantName = deckCard.dataset.plant;
            const isImitated = deckCard.dataset.isImitated === 'true';

            // Find the library card to unhide
            const libraryCardToShow = document.querySelector(`#plantLibraryGrid .plantCard[data-plant="${isImitated ? 'imitater' : plantName}"]`);
            if (libraryCardToShow) {
                libraryCardToShow.classList.remove('in-library-hidden');
            }

            // Remove from the internal deck array
            const indexToRemove = selectedPlantDeck.findIndex(card => card.isImitated === isImitated && card.type === plantName);
            if (indexToRemove > -1) {
                selectedPlantDeck.splice(indexToRemove, 1);
            }

            // Remove from the DOM and update state
            deckCard.remove();
            document.getElementById('selectedPlantCount').textContent = selectedPlantDeck.length;
            lastSelectedPlantForImitater = selectedPlantDeck.length > 0 ? selectedPlantDeck[selectedPlantDeck.length - 1] : null;
        }

        function showPlantSelectionScreen() {
            // Check if any save slot exists
            let saveExists = false;
            for (let i = 1; i <= 9; i++) {
                if (localStorage.getItem(`pvz_fullGameState_slot${i}`)) {
                    saveExists = true;
                    break;
                }
            }

            const loadBtn = document.getElementById('loadGameBtn');
            if (saveExists) {
                loadBtn.style.display = 'block';
                const newLoadBtn = loadBtn.cloneNode(true);
                loadBtn.parentNode.replaceChild(newLoadBtn, loadBtn);
                newLoadBtn.addEventListener('click', () => openSaveLoadMenu('load'));
            } else {
                loadBtn.style.display = 'none';
            }

            const screen = document.getElementById('plantSelectionScreen');
            const libraryGrid = document.getElementById('plantLibraryGrid');
            const deckBar = document.getElementById('deckBar');
            const templates = document.getElementById('plantCardTemplates');

            // Reset state for new selection
            libraryGrid.innerHTML = '';
            deckBar.innerHTML = '';
            selectedPlantDeck = [];
            lastSelectedPlantForImitater = null;
            wavePointsForCurrentWave = null;
            document.getElementById('selectedPlantCount').textContent = '0'; // Reset count display

            document.getElementById('ui').style.visibility = 'hidden';
            document.getElementById('wave').style.visibility = 'hidden';
            screen.style.display = 'flex';

            // Populate the library
            templates.querySelectorAll('.plantCard').forEach(cardTemplate => {
                if (cardTemplate.id === 'shovelCard') return;
                const libraryCard = cardTemplate.cloneNode(true);
                libraryGrid.appendChild(libraryCard);
            });

            // Mobile-only tip
            if (mobileDevice && !document.fullscreenElement) {
                showCustomDialog(
                    'Fullscreen Recommended',
                    'For the best experience on mobile, it\'s better to play in fullscreen.',
                    [
                        { text: 'Go Fullscreen', class: 'secondary', callback: enterFullscreen },
                        { text: 'Maybe later' }
                    ]
                );
            }
        }


        function populateInGameUI() {
            const plantBar = document.getElementById('plantSelection');
            const templates = document.getElementById('plantCardTemplates');
            plantBar.innerHTML = '';

            selectedPlantDeck.forEach(deckItem => {
                const plantName = deckItem.type;
                const cardTemplate = templates.querySelector(`.plantCard[data-plant="${plantName}"]`);
                if (cardTemplate) {
                    const newCard = cardTemplate.cloneNode(true);
                    newCard.dataset.isImitated = deckItem.isImitated ? 'true' : 'false';
                    if (deckItem.isImitated) {
                        newCard.classList.add('imitated');
                    }
                    plantBar.appendChild(newCard);
                }
            });

            const shovelTemplate = templates.querySelector('#shovelCard');
            if (shovelTemplate) {
                plantBar.appendChild(shovelTemplate.cloneNode(true));
            }

            setupInGameCardListeners();
        }

        function applyInitialCooldowns() {
            // A list of all plants that must recharge at the start of a level.
            const plantsToRecharge = [
                'cherrybomb',
                'wallnut',
                'potatomine',
                'iceshroom',
                'doomshroom',
                'jalapeno',
                'tallnut',
                'marigold'
            ];

            const inGameCards = document.querySelectorAll('#plantSelection .plantCard');

            inGameCards.forEach(card => {
                const plantName = card.dataset.plant;
                if (!plantName) return;

                const isUpgrade = card.dataset.upgrade === 'true';
                const isInList = plantsToRecharge.includes(plantName);

                if (isUpgrade || isInList) {
                    const plantInfo = plantTypes[plantName];
                    if (plantInfo && plantInfo.cooldown) {
                        startCooldown(card, plantInfo.cooldown);
                    }
                }
            });
        }

        // Get plant display name from type key
        function getPlantDisplayName(plantType) {
            const nameMap = {
                'gatling': 'Gatling Pea',
                'twinSunflower': 'Twin Sunflower',
                'gloomshroom': 'Gloom-shroom',
                'wintermelon': 'Winter Melon',
                'spikerock': 'Spikerock',
                'repeater': 'Repeater',
                'sunflower': 'Sunflower',
                'fumeshroom': 'Fume-shroom',
                'melonpult': 'Melon-pult',
                'spikeweed': 'Spikeweed'
            };
            return nameMap[plantType] || plantType;
        }

        // Check for strange plant combinations
        function checkStrangePlantCombinations() {
            const warnings = [];
            const isDay = gameState.map === 'day';
            const isNight = gameState.map === 'night';

            // Get plant types from deck
            const deckPlantTypes = selectedPlantDeck.map(item => item.type);
            const hasCoffeeBean = deckPlantTypes.includes('coffeebean');
            const hasGraveBuster = deckPlantTypes.includes('gravebuster');
            const hasMushrooms = deckPlantTypes.some(type => {
                const plant = plantTypes[type];
                return plant && plant.isMushroom;
            });

            // Check for any sun-producing plants (sunflower, twinSunflower, suncheat)
            const hasSunProducer = deckPlantTypes.some(type => {
                const plant = plantTypes[type];
                return plant && plant.produces === 'sun';
            });

            // Check for balloon zombie fighter
            const hasBalloonZombieFighter = deckPlantTypes.some(type => {
                return deckPlantTypes.includes('cherrybomb') || deckPlantTypes.includes('jalapeno') || deckPlantTypes.includes('doomshroom') || deckPlantTypes.includes('cactus') || deckPlantTypes.includes('blover') || deckPlantTypes.includes('hurrikale');
            });

            // No balloon zombie fighter
            if (!hasBalloonZombieFighter) {
                warnings.push('You didn\'t take any plant that can defeat <strong>Balloon Zombie</strong> on a level. <strong>Balloon Zombies</strong> are imune to most plants attacks, Its next to impossible to survive without them.');
            }

            // No gravebuster
            if (!hasGraveBuster) {
                warnings.push('You didn\'t take a <strong>Grave Buster</strong> on a level. Grave Busters are essential for clearing graves. You can survive without them, but it will be much harder.');
            }

            // No sunflower
            if (!hasSunProducer) {
                warnings.push('You didn\'t take a <strong>Sunflower</strong> on a level. Sunflowers produce sun which is essential for planting.');
            }

            // Coffee bean on night level
            if (isNight && hasCoffeeBean) {
                warnings.push('You took <strong>Coffee Bean</strong> on a night level. It will be useless since mushrooms don\'t sleep at night.');
            }

            // Mushrooms on day level without coffee bean
            if (isDay && hasMushrooms && !hasCoffeeBean) {
                warnings.push('You took mushrooms on a day level without <strong>Coffee Bean</strong>. Mushrooms will sleep during the day and won\'t be usable.');
            }

            // Coffee bean without mushrooms
            if (isDay && !hasMushrooms && hasCoffeeBean) {
                warnings.push('You took <strong>Coffee Bean</strong> without mushrooms. It will be useless since it should be planted on mushrooms.');
            }

            // Upgrade plants without base plants
            deckPlantTypes.forEach(plantType => {
                const plant = plantTypes[plantType];
                if (plant && plant.isUpgrade && plant.upgradesFrom) {
                    const basePlantType = plant.upgradesFrom;
                    if (!deckPlantTypes.includes(basePlantType)) {
                        const upgradeName = getPlantDisplayName(plantType);
                        const baseName = getPlantDisplayName(basePlantType);
                        warnings.push(`You picked <strong>${upgradeName}</strong>, but didn't pick <strong>${baseName}</strong>. <strong>${upgradeName}</strong> must be planted on <strong>${baseName}</strong>.`);
                    }
                }
            });

            return warnings;
        }

        function startGame() {
            // Wave Count Challenge
            if (activeChallenges.endless) {
                gameState.maxWaves = Infinity;
            } else if (activeChallenges.fortyWaves) {
                gameState.maxWaves = 40;
            } else {
                gameState.maxWaves = 20; // Default
            }

            if (activeChallenges.sandbox) {
                gameState.sun = Infinity;
            }

            // Set map visuals
            if (gameState.map === 'night') {
                document.getElementById('gameContainer').classList.add('night-mode');
            } else {
                document.getElementById('gameContainer').classList.remove('night-mode');
            }

            document.getElementById('plantSelectionScreen').style.display = 'none';
            document.getElementById('ui').style.visibility = 'visible';
            document.getElementById('wave').style.visibility = 'visible';

            populateInGameUI();
            applyInitialCooldowns();
            updatePlantCardAvailability();

            // --- LOGIC TO CONFIGURE THE UI BUTTON BASED ON GAME MODE ---
            const gameUiButton = document.getElementById('gameUiBtn');

            const newGameUiButton = gameUiButton.cloneNode(true);
            gameUiButton.parentNode.replaceChild(newGameUiButton, gameUiButton);

            if (activeChallenges.sandbox) {
                // In Sandbox mode, it becomes the Zombie Spawner button.
                newGameUiButton.innerHTML = 'ðŸ§Ÿ Spawner';
                newGameUiButton.addEventListener('click', toggleSpawnerBar);
            } else {
                // In Normal mode, it's the Leaderboard button.
                newGameUiButton.innerHTML = 'ðŸ† Top 10';
                newGameUiButton.addEventListener('click', showLeaderboard);
            }

            updateBoardDimensions();
            createLawnmowers();
            resumeGame();
            startGameLoop();
            spawnSunPeriodically();
            updateDamageDisplay();
            updateSunDisplay();
            updateWaveDisplay();
            if (!activeChallenges.sandbox) {
                createTimer(25000, () => spawnZombieWave(), false, 'waveTimer');
            }
        }

        function confirmAndStartGame() {
            if (selectedPlantDeck.length === 0) {
                showCustomDialog(
                    'Choose Your Plants',
                    'Please select at least one plant for your deck before starting the game.',
                    [{ text: 'OK', class: 'secondary' }]
                );
                return;
            }

            // Check for strange plant combinations
            const warnings = checkStrangePlantCombinations();

            if (warnings.length > 0) {
                // Combine all warnings into one message with HTML line breaks
                const warningMessage = warnings.join('<br><br>') + '<br><br>Are you sure you want to continue?';

                showCustomDialog(
                    'Strange Plant Combination',
                    warningMessage,
                    [
                        {
                            text: 'Continue',
                            class: 'secondary',
                            callback: () => {
                                startGame();
                            }
                        },
                        {
                            text: 'Re-Pick',
                            callback: () => {

                            }
                        }
                    ]
                );
                return;
            }

            // No warnings, start game directly
            startGame();
        }

        // Check if mobile device
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                (window.innerWidth <= 768);
        }

        const mobileDevice = isMobile();

        // Enter fullscreen
        function enterFullscreen() {
            const elem = document.documentElement;

            const requestFS = elem.requestFullscreen ||
                elem.webkitRequestFullscreen ||
                elem.mozRequestFullScreen ||
                elem.msRequestFullscreen;

            if (requestFS && !document.fullscreenElement) {
                requestFS.call(elem).then(() => {
                    gameState.wasFullscreen = true;
                    localStorage.setItem('pvz_fullscreen', 'true');
                    if (window.screen && window.screen.orientation && window.screen.orientation.lock) {
                        window.screen.orientation.lock('landscape').catch(err => {
                            console.log('Orientation lock not supported:', err);
                        });
                    }
                    setTimeout(updateBoardDimensions, 100);
                }).catch(err => {
                    console.log('Fullscreen error:', err);
                });
            }
        }

        // Create Lawnmowers
        function createLawnmowers() {
            if (activeChallenges.hardMode) return;
            if (!gameState.boardRect || gameState.lawnmowers.length > 0) return;

            for (let i = 0; i < 5; i++) {
                const mower = document.createElement('div');
                mower.className = 'lawnmower';
                mower.textContent = 'ðŸšœ';

                const yPosition = gameState.boardRect.top + i * gameState.cellSize.height + gameState.cellSize.height / 2 - 20;
                const xPosition = gameState.boardRect.left - gameState.cellSize.width * 0.4;

                mower.style.position = 'fixed';
                mower.style.top = yPosition + 'px';
                mower.style.left = xPosition + 'px';

                document.getElementById('gameContainer').appendChild(mower);

                gameState.lawnmowers.push({
                    element: mower,
                    row: i,
                    x: xPosition - gameState.boardRect.left,
                    moving: false
                });
            }
        }

        // Create Game Board
        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';

            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    board.appendChild(cell);
                }
            }

            setTimeout(updateBoardDimensions, 100);
        }

        // Update board dimensions
        function updateBoardDimensions() {
            const board = document.getElementById('gameBoard');
            gameState.boardRect = board.getBoundingClientRect();
            const cells = board.getElementsByClassName('cell');
            if (cells.length > 0) {
                const cellRect = cells[0].getBoundingClientRect();
                gameState.cellSize = {
                    width: cellRect.width,
                    height: cellRect.height
                };
            }

            // Reposition existing lawnmowers on resize
            gameState.lawnmowers.forEach(mower => {
                if (mower.element && !mower.moving) {
                    const yPosition = gameState.boardRect.top + mower.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 20;
                    const xPosition = gameState.boardRect.left - gameState.cellSize.width * 0.4;
                    mower.element.style.top = yPosition + 'px';
                    mower.element.style.left = xPosition + 'px';
                    mower.x = xPosition - gameState.boardRect.left;
                }
            });

            // Update existing zombie and projectile positions
            gameState.zombies.forEach(zombie => {
                if (zombie.element) {
                    const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + (zombie.isFlying ? -10 : gameState.cellSize.height / 2 - 20) + (zombie.row * 2.5);
                    zombie.element.style.top = yPosition + 'px';
                }
            });
        }

        // --- Separated listener setup for in-game cards ---
        function setupInGameCardListeners() {
            document.querySelectorAll('#plantSelection .plantCard').forEach(card => {
                // The main function to call when a card is successfully selected
                const handleSelect = () => {
                    if (card.id === 'shovelCard') {
                        selectShovel();
                    } else {
                        selectPlant(card);
                    }
                };

                // --- Mobile-Specific Logic ---
                if (mobileDevice) {
                    let isDragging = false;
                    let touchStartX = 0;
                    let touchStartY = 0;
                    const scrollThreshold = 10; // How far a finger must move to be considered a scroll

                    card.addEventListener('touchstart', (e) => {
                        const touch = e.touches[0];
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        isDragging = false;
                    }, { passive: true });

                    card.addEventListener('touchmove', (e) => {
                        if (isDragging) return;
                        const touch = e.touches[0];
                        const deltaX = Math.abs(touch.clientX - touchStartX);
                        const deltaY = Math.abs(touch.clientY - touchStartY);

                        if (deltaX > scrollThreshold && deltaX > deltaY) {
                            isDragging = true;
                        }
                    }, { passive: true });

                    card.addEventListener('touchend', (e) => {
                        // If the touch ended without being flagged as a drag, it's a tap.
                        if (!isDragging) {
                            if (e.cancelable) {
                                e.preventDefault();
                            }
                            handleSelect();
                        }
                    });

                    // --- Desktop-Specific Logic ---
                } else {
                    card.addEventListener('click', handleSelect);
                }
            });
        }

        // Setup Event Listeners
        function setupEventListeners() {
            // This now only sets up listeners for elements that exist on page load
            document.querySelectorAll('.cell').forEach(cell => {
                cell.addEventListener('click', () => placePlant(cell));
                cell.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    placePlant(cell);
                });
            });

            document.getElementById('startGameBtn').addEventListener('click', confirmAndStartGame);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);

            document.getElementById('speedBtn').addEventListener('click', () => {
                gameState.gameSpeed = gameState.gameSpeed === 1 ? 2 : gameState.gameSpeed === 2 ? 3 : 1;
                const btn = document.getElementById('speedBtn');
                btn.textContent = `âš¡ x${gameState.gameSpeed}`;
                btn.classList.toggle('active', gameState.gameSpeed > 1);
                document.getElementById('gameContainer').style.setProperty('--game-speed', gameState.gameSpeed);
            });

            document.getElementById('leaderBtn').addEventListener('click', showLeaderboard);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

            window.addEventListener('resize', updateBoardDimensions);

            document.addEventListener('fullscreenchange', () => {
                setTimeout(updateBoardDimensions, 100);
            });

            document.addEventListener('webkitfullscreenchange', () => {
                setTimeout(updateBoardDimensions, 100);
            });

            // --- DEBUG KEY LISTENERS ---
            document.addEventListener('keydown', (e) => {
                // Debug info toggle with 'D' key
                if (e.key === 'd' || e.key === 'D') {
                    const debugInfo = document.getElementById('debugInfo');
                    debugInfo.style.display = debugInfo.style.display === 'none' ? 'block' : 'none';
                }

                // Zombie spawner toggle with 'Z' key
                if (e.key === 'z' || e.key === 'Z') {
                    toggleZombieSpawner();
                }
            });
        }

        // --- Setup Zombie Spawner UI ---
        function setupZombieSpawner() {
            const spawner = document.getElementById('zombieSpawner');
            spawner.innerHTML = ''; // Clear any existing

            Object.keys(zombieTypes).forEach(typeKey => {
                const zombieInfo = almanacData[typeKey] || {}; // Get data from new object
                const card = document.createElement('div');
                card.className = 'zombieCard';
                card.dataset.zombieType = typeKey;

                const zombieVisual = createZombieVisual(typeKey);
                zombieVisual.style.transform = 'scale(0.64) scaleX(-1)';
                zombieVisual.style.margin = '-10px 0';

                const nameDiv = document.createElement('div');
                nameDiv.className = 'name';
                nameDiv.textContent = zombieInfo.name || typeKey; // Use name from almanacData

                card.appendChild(zombieVisual);
                card.appendChild(nameDiv);

                card.addEventListener('click', () => selectZombie(card, typeKey));
                spawner.appendChild(card);
            });
        }

        // --- Toggle Zombie Spawner UI ---
        function toggleZombieSpawner() {
            gameState.isZombieSpawnMode = !gameState.isZombieSpawnMode;
            const spawner = document.getElementById('zombieSpawner');

            if (gameState.isZombieSpawnMode) {
                spawner.style.display = 'flex';
            } else {
                spawner.style.display = 'none';
                // Clean up selection when closing
                gameState.selectedZombie = null;
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
            }
        }

        // --- Select Zombie from Spawner ---
        function selectZombie(card, typeKey) {
            if (gameState.isPaused) return;

            // Deselect any active plant or shovel
            gameState.selectedPlant = null;
            gameState.isShovelActive = false;
            document.querySelectorAll('.plantCard.selected').forEach(c => c.classList.remove('selected'));
            document.getElementById('gameBoard').classList.remove('shovel-mode');

            // Handle zombie selection
            if (gameState.selectedZombie === typeKey) {
                // Deselecting
                gameState.selectedZombie = null;
                card.classList.remove('selected');
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
            } else {
                // Selecting
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
                gameState.selectedZombie = typeKey;
                card.classList.add('selected');
                document.getElementById('gameBoard').classList.add('zombie-spawn-mode');
            }
        }

        function populateBarWithZombies() {
            const plantBar = document.getElementById('plantSelection');
            plantBar.innerHTML = ''; // Clear out the plants and shovel

            Object.keys(zombieTypes).forEach(typeKey => {
                const zombieInfo = almanacData[typeKey] || {};
                const card = document.createElement('div');
                card.className = 'zombieCard';
                card.dataset.zombieType = typeKey;

                const zombieVisual = createZombieVisual(typeKey);
                zombieVisual.style.transform = 'scale(0.64) scaleX(-1)';
                zombieVisual.style.margin = '-10px 0';

                const nameDiv = document.createElement('div');
                nameDiv.className = 'name';
                nameDiv.textContent = zombieInfo.name || typeKey;

                card.appendChild(zombieVisual);
                card.appendChild(nameDiv);

                card.addEventListener('click', () => selectZombie(card, typeKey));
                plantBar.appendChild(card);
            });
        }

        function toggleSpawnerBar() {
            const gameUiButton = document.getElementById('gameUiBtn');

            if (isShowingZombiesInPlantBar) {
                // --- Switch back to showing plants ---
                populateInGameUI();
                isShowingZombiesInPlantBar = false;
                gameUiButton.innerHTML = 'ðŸ§Ÿ Spawner';

                // Deselect any active zombie
                if (gameState.selectedZombie) {
                    gameState.selectedZombie = null;
                    document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                }
            } else {
                // --- Switch to showing zombies ---
                populateBarWithZombies();
                isShowingZombiesInPlantBar = true;
                gameUiButton.innerHTML = 'ðŸŒ± Spawner';

                // Deselect any active plant or shovel
                if (gameState.selectedPlant) {
                    gameState.selectedPlant = null;
                    document.querySelectorAll('.plantCard.selected').forEach(c => c.classList.remove('selected'));
                }
                if (gameState.isShovelActive) {
                    selectShovel(); // Toggles it off
                }
            }
        }

        // Select Shovel
        function selectShovel() {
            if (gameState.isPaused) return;

            // Deselect zombie if active
            if (gameState.selectedZombie) {
                gameState.selectedZombie = null;
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
            }

            gameState.isShovelActive = !gameState.isShovelActive;
            const shovelCard = document.getElementById('shovelCard');
            const gameBoard = document.getElementById('gameBoard');

            if (gameState.isShovelActive) {
                // Deselect any plant
                gameState.selectedPlant = null;
                document.querySelectorAll('.plantCard').forEach(c => c.classList.remove('selected'));

                shovelCard.classList.add('selected');
                gameBoard.classList.add('shovel-mode');
            } else {
                shovelCard.classList.remove('selected');
                gameBoard.classList.remove('shovel-mode');
            }
        }

        // Select Plant
        function selectPlant(card) {
            if (card.classList.contains('disabled') || card.classList.contains('on-cooldown') || gameState.isPaused) return;

            // Deselect zombie if active
            if (gameState.selectedZombie) {
                gameState.selectedZombie = null;
                document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
            }

            // Deactivate shovel if it's active
            if (gameState.isShovelActive) {
                gameState.isShovelActive = false;
                document.getElementById('shovelCard').classList.remove('selected');
                document.getElementById('gameBoard').classList.remove('shovel-mode');
            }

            if (card.classList.contains('selected')) {
                card.classList.remove('selected');
                gameState.selectedPlant = null;
            } else {
                document.querySelectorAll('#plantSelection .plantCard').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');

                gameState.selectedPlant = {
                    type: card.dataset.plant,
                    cost: parseInt(card.dataset.cost),
                    isImitated: card.dataset.isImitated === 'true',
                    cardElement: card
                };
            }
        }

        // Function to remove a plant from a cell
        function removePlant(cell) {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            let actionTaken = false;

            const plantIndex = gameState.plants.findIndex(p => p.row === row && p.col === col);
            if (plantIndex !== -1) {
                const plantToRemove = gameState.plants[plantIndex];

                if (plantToRemove.graveBusterTimerId) {
                    clearTimer(plantToRemove.graveBusterTimerId);
                }
                if (plantToRemove.armingTimerId) {
                    clearTimer(plantToRemove.armingTimerId);
                }
                if (plantToRemove.activationTimerId) {
                    clearTimer(plantToRemove.activationTimerId);
                }
                if (plantToRemove.mushroomActivationTimerId) {
                    clearTimer(plantToRemove.mushroomActivationTimerId);
                }

                if (plantToRemove.element) {
                    createParticleEffect(plantToRemove.element, 'â›ï¸');
                    plantToRemove.element.remove();
                }
                gameState.plants.splice(plantIndex, 1);
                actionTaken = true;
            }

            // Deactivate shovel after use
            if (actionTaken) {
                gameState.isShovelActive = false;
                document.getElementById('shovelCard').classList.remove('selected');
                document.getElementById('gameBoard').classList.remove('shovel-mode');
                updatePlantCardAvailability();
            }
        }

        // Start Cooldown on Plant Card
        function startCooldown(card, duration) {
            if (activeChallenges.sandbox) return;
            if (!card) return;

            card.classList.add('on-cooldown');

            const timerId = createTimer(duration, () => {
                card.classList.remove('on-cooldown');
                delete card.dataset.cooldownTimerId;
            }, false, 'cardCooldown');

            card.dataset.cooldownTimerId = timerId;
        }

        function restoreCooldown(card, remaining, delay) {
            if (!card) return;
            card.classList.add('on-cooldown');

            // Create a timer with the original full duration
            const timerId = createTimer(delay, () => {
                card.classList.remove('on-cooldown');
                delete card.dataset.cooldownTimerId;
            }, false, 'cardCooldown');

            // Crucially, override the 'remaining' time with the saved value
            if (gameState.timers[timerId]) {
                gameState.timers[timerId].remaining = remaining;
            }

            card.dataset.cooldownTimerId = timerId;
        }

        // --- PLANTING LOGIC ---

        /**
         * Checks if a plant can be placed on a specific cell.
         * This is the new central logic hub for planting rules.
         * @returns {object} { canPlant: boolean, reason: string, action: 'regular' | 'upgrade' | 'gravebust' | 'wakeup' | 'none' }
         */
        function canPlantOnCell(row, col, plantTypeInfo) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            const hasGrave = gameState.graves.some(g => g.row === row && g.col === col);
            const existingPlant = gameState.plants.find(p => p.row === row && p.col === col);

            // 1. Check for unplantable terrain
            if (cell.classList.contains('crater') || cell.classList.contains('iced')) {
                return { canPlant: false, reason: 'Cell is blocked', action: 'none' };
            }

            // 2. Handle Coffee Bean
            if (plantTypeInfo.isWakeUp) {
                if (existingPlant && existingPlant.isMushroom && existingPlant.isSleeping) {
                    return { canPlant: true, reason: 'Waking up mushroom', action: 'wakeup' };
                } else {
                    return { canPlant: false, reason: 'Can only be used on sleeping mushrooms', action: 'none' };
                }
            }

            // 3. Handle Grave Buster
            if (plantTypeInfo.isGraveBuster) {
                return hasGrave && !existingPlant ? { canPlant: true, reason: 'Planting Grave Buster', action: 'gravebust' } :
                    { canPlant: false, reason: 'Must be planted on a grave', action: 'none' };
            }

            // 4. Handle Upgrades
            if (plantTypeInfo.isUpgrade) {
                if (existingPlant && existingPlant.type === plantTypeInfo.upgradesFrom) {
                    return { canPlant: true, reason: 'Upgrading plant', action: 'upgrade' };
                } else {
                    return { canPlant: false, reason: 'Can only upgrade specific plants', action: 'none' };
                }
            }

            // 5. Handle Regular planting
            if (hasGrave || existingPlant) {
                return { canPlant: false, reason: 'Cell is occupied', action: 'none' };
            }

            // 6. If all checks pass
            return { canPlant: true, reason: 'Cell is clear', action: 'regular' };
        }


        /**
         * Handles the logic for planting a Grave Buster.
         */
        function plantGraveBuster(row, col, plantToPlaceType, selectedPlantTypeInfo) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);

            const plant = {
                id: gameState.nextId++,
                type: plantToPlaceType,
                row: row,
                col: col,
                health: selectedPlantTypeInfo.health,
                maxHealth: selectedPlantTypeInfo.maxHealth,
                element: null,
                healthBar: null,
                healthFill: null,
                shootCooldown: selectedPlantTypeInfo.shootInterval || 0,
                sunCooldown: 0,
            };

            const plantElement = document.createElement('div');
            plantElement.className = 'plant eating-grave';
            if (gameState.selectedPlant.isImitated) {
                plantElement.classList.add('imitated');
            }
            plantElement.textContent = selectedPlantTypeInfo.emoji;
            plantElement.style.zIndex = '2'; // Ensure it's above the grave emoji

            const healthBar = document.createElement('div');
            healthBar.className = 'plant-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'plant-health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            plantElement.appendChild(healthBar);

            cell.appendChild(plantElement);
            plant.element = plantElement;
            plant.healthBar = healthBar;
            plant.healthFill = healthFill;

            gameState.plants.push(plant);

            const graveBusterTimerId = createTimer(5000, () => {
                // Check if plant still exists (wasn't eaten)
                const plantIndex = gameState.plants.indexOf(plant);
                if (plantIndex === -1) return; // Plant was eaten, do nothing

                const currentGraveIndex = gameState.graves.findIndex(g => g.row === row && g.col === col);
                if (currentGraveIndex !== -1) {
                    const graveToRemove = gameState.graves[currentGraveIndex];
                    if (graveToRemove.element) {
                        graveToRemove.element.classList.remove('grave');
                    }
                    gameState.graves.splice(currentGraveIndex, 1);
                }

                const sunValue = Math.random() < 0.2 ? 75 : 25; // 20% chance for 75, 80% for 25
                const emoji = sunValue === 75 ? 'ðŸ’°' : 'ðŸµï¸';

                const sun = document.createElement('div');
                sun.className = 'sun';
                sun.innerHTML = `<span>${emoji}</span><span class="sun-value" style="display: none;">${sunValue}</span>`;

                const rect = cell.getBoundingClientRect();
                sun.style.left = (rect.left + rect.width / 2 - 15) + 'px';
                sun.style.top = (rect.top + rect.height / 2 - 15) + 'px';
                sun.style.position = 'fixed';
                document.getElementById('gameContainer').appendChild(sun);

                sun.addEventListener('click', () => collectSun(sun, sunValue));
                sun.addEventListener('touchstart', (e) => { e.preventDefault(); collectSun(sun, sunValue); }, { passive: false });

                const sunId = `sun-${gameState.nextId++}`;

                // Auto-fade sun
                createTimer(7000, () => {
                    if (sun.parentElement && !sun.dataset.collecting) {
                        sun.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease-in, transform calc(0.5s / var(--game-speed)) ease-in';
                        sun.style.opacity = '0';
                        sun.style.transform = 'scale(0.5)';
                        createTimer(500, () => sun.remove(), false, 'sun_remove');
                    }
                }, false, 'sunDespawn', sunId);

                if (plant.element) {
                    plant.element.remove();
                }
                gameState.plants.splice(plantIndex, 1);

                updatePlantCardAvailability(); // Check if gravebuster should be disabled
            }, false, 'graveBuster', plant.id);

            // Store timer ID on plant in case it gets eaten
            plant.graveBusterTimerId = graveBusterTimerId;
        }

        /**
         * Handles the logic for planting an Upgrade plant.
         */
        function plantUpgrade(row, col, plantToPlaceType, selectedPlantTypeInfo) {
            const plantToUpgrade = gameState.plants.find(p => p.row === row && p.col === col);
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);

            // We already checked if plantToUpgrade exists and is the correct type in canPlantOnCell
            if (!plantToUpgrade) return;

            // Defensively preserve the ID to prevent it from ever being lost.
            const originalId = plantToUpgrade.id;

            // Morph the existing plant
            plantToUpgrade.type = plantToPlaceType;
            plantToUpgrade.health = selectedPlantTypeInfo.health;
            plantToUpgrade.maxHealth = selectedPlantTypeInfo.maxHealth;
            plantToUpgrade.shootCooldown = selectedPlantTypeInfo.shootInterval || 0;
            plantToUpgrade.id = originalId;

            if (selectedPlantTypeInfo.produces === 'sun' || selectedPlantTypeInfo.produces === 'coin') {
                plantToUpgrade.sunCooldown = (selectedPlantTypeInfo.baseInterval - 2000) + (Math.random() * 4000);
            }

            if (plantToUpgrade.element) {
                plantToUpgrade.element.textContent = selectedPlantTypeInfo.emoji;
                plantToUpgrade.element.appendChild(plantToUpgrade.healthBar); // Re-append health bar
            }
            updatePlantHealth(plantToUpgrade);

            // If the upgraded plant was an imitater, remove the grayscale effect
            if (plantToUpgrade.isImitated && plantToUpgrade.element) {
                plantToUpgrade.element.classList.remove('imitated');
                plantToUpgrade.isImitated = false;
            }

            createParticleEffect(cell, 'ðŸŒŸ');
        }

        /**
         * Handles the logic for waking up a mushroom with a Coffee Bean.
         */
        function wakeUpMushroom(row, col) {
            const mushroom = gameState.plants.find(p => p.row === row && p.col === col);
            if (!mushroom || !mushroom.isSleeping) return;

            // Get the plant's properties to check its type
            const plantTypeInfo = plantTypes[mushroom.type];

            // Wake the mushroom up visually
            mushroom.isSleeping = false;
            if (mushroom.element) {
                mushroom.element.classList.remove('sleeping');
                createParticleEffect(mushroom.element, 'â˜•');
            }

            // Differentiate between single-use and shooter mushrooms
            if (plantTypeInfo.freezes || plantTypeInfo.radiusX) {
                const activationTimerId = createTimer(500, () => {
                    triggerMushroomEffect(mushroom);
                }, false, 'mushroomEffectTrigger', mushroom.id);
                mushroom.mushroomActivationTimerId = activationTimerId;
            }
        }


        /**
         * Handles the logic for planting a Regular or Instant plant.
         */
        function plantRegular(row, col, plantToPlaceType, selectedPlantTypeInfo) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);

            const plant = {
                id: gameState.nextId++,
                type: plantToPlaceType,
                row: row,
                col: col,
                health: selectedPlantTypeInfo.health,
                maxHealth: selectedPlantTypeInfo.maxHealth,
                element: null,
                healthBar: null,
                healthFill: null,
                shootCooldown: selectedPlantTypeInfo.shootInterval || 0,
                sunCooldown: 0,
                isImitated: gameState.selectedPlant.isImitated || false,
                isMushroom: selectedPlantTypeInfo.isMushroom || false,
                isSleeping: false
            };

            if (plant.type === 'chomper') {
                plant.isChewing = false;
                plant.chewTimer = 0;
                plant.lastChomp = 0;
            }

            if (selectedPlantTypeInfo.produces === 'sun' || selectedPlantTypeInfo.produces === 'coin') {
                plant.sunCooldown = 7000 + (Math.random() * 5000);
            }

            const plantElement = document.createElement('div');
            plantElement.className = 'plant';
            plantElement.classList.add('plant-spawn');
            if (plant.isImitated) {
                plantElement.classList.add('imitated');
            }
            if (selectedPlantTypeInfo.isSpike) {
                plantElement.classList.add('spike-plant');
            }
            plantElement.textContent = selectedPlantTypeInfo.emoji;

            const healthBar = document.createElement('div');
            healthBar.className = 'plant-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'plant-health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            plantElement.appendChild(healthBar);

            cell.appendChild(plantElement);
            createTimer(500, () => {
                if (plantElement) {
                    plantElement.classList.remove('plant-spawn');
                }
            }, false, 'remove_spawn_animation');
            plant.element = plantElement;
            plant.healthBar = healthBar;
            plant.healthFill = healthFill;

            if (plant.type === 'sunshroom') {
                plant.isGrown = false;
                plant.element.classList.add('arming'); // Reusing
                plant.element.style.transition = 'transform calc(0.5s / var(--game-speed)) ease'; // For smooth growth
                plant.growthTimerId = createTimer(selectedPlantTypeInfo.growthTime, () => {
                    if (plant && plant.element) {
                        plant.isGrown = true;
                        plant.element.classList.remove('arming');
                        plant.element.style.transform = 'translate(-50%, -50%) scale(1)';
                    }
                }, false, 'plantGrowth', plant.id);
            }

            // Mushroom sleeping logic
            if (selectedPlantTypeInfo.isMushroom) {
                if (gameState.map === 'day') {
                    plant.isSleeping = true;
                    plantElement.classList.add('sleeping');
                } else {
                    // At night, check if it's a SINGLE-USE mushroom before activating its effect
                    if (selectedPlantTypeInfo.freezes || selectedPlantTypeInfo.radiusX) {
                        const activationTimerId = createTimer(1200, () => triggerMushroomEffect(plant), false, 'mushroomEffectTrigger', plant.id);
                        plant.mushroomActivationTimerId = activationTimerId;
                    }
                }
            }

            if (plant.type === 'potatomine') {
                plant.isArmed = false;
                plant.isArming = true;
                plant.element.classList.add('arming');

                const armingTimerId = createTimer(selectedPlantTypeInfo.armTime, () => {
                    const mineIndex = gameState.plants.indexOf(plant);
                    if (mineIndex !== -1) {
                        plant.isArmed = true;
                        plant.isArming = false;
                        if (plant.element) {
                            plant.element.classList.remove('arming');
                            plant.element.classList.add('armed');
                        }
                    }
                }, false, 'plantArming', plant.id);
                plant.armingTimerId = armingTimerId;

            } else if (selectedPlantTypeInfo.isActivatingPlant) {
                const activationTimerId = createTimer(selectedPlantTypeInfo.armTime, () => activatePlantEffect(plant), false, 'plantActivation', plant.id);
                plant.activationTimerId = activationTimerId;

                createTimer(500, () => {
                    if (plant.element) {
                        plant.element.classList.add('activating');
                    }
                }, false, 'add_activating_class', plant.id);
            }

            gameState.plants.push(plant);

            if (selectedPlantTypeInfo.lifespan) {
                plant.lifespanTimerId = createTimer(selectedPlantTypeInfo.lifespan, () => {
                    const currentPlant = gameState.plants.find(p => p.id === plant.id);
                    if (currentPlant && currentPlant.element) {
                        currentPlant.element.style.transition = 'opacity calc(1s / var(--game-speed)) ease-out';
                        currentPlant.element.style.opacity = '0';
                        createTimer(1000, () => {
                            if (currentPlant.element) currentPlant.element.remove();
                            gameState.plants = gameState.plants.filter(p => p.id !== plant.id);
                        }, false, 'remove_temporary_plant');
                    }
                }, false, 'plantLifespan', plant.id);
            }

            createParticleEffect(cell, 'âœ¨');
        }

        // Spawn Zombie on Tile (from Debug)
        function spawnZombieOnTile(cell) {
            if (gameState.isPaused || !gameState.selectedZombie) return;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            spawnZombieAt(row, col, gameState.selectedZombie);
            // We don't deselect, as per user request (no cost, no cooldown)
        }

        // Place Plant
        function placePlant(cell) {
            if (gameState.selectedZombie) {
                spawnZombieOnTile(cell);
                return;
            }
            if (gameState.isShovelActive) {
                removePlant(cell);
                return;
            }
            if (!gameState.selectedPlant || gameState.isPaused) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const plantToPlaceType = gameState.selectedPlant.type;
            const selectedPlantTypeInfo = plantTypes[plantToPlaceType];

            const plantingCheck = canPlantOnCell(row, col, selectedPlantTypeInfo);
            if (!plantingCheck.canPlant) return;

            if (gameState.sun < gameState.selectedPlant.cost) {
                flashSunCounter();
                return;
            }

            gameState.sun -= gameState.selectedPlant.cost;

            switch (plantingCheck.action) {
                case 'gravebust':
                    plantGraveBuster(row, col, plantToPlaceType, selectedPlantTypeInfo);
                    break;
                case 'upgrade':
                    plantUpgrade(row, col, plantToPlaceType, selectedPlantTypeInfo);
                    break;
                case 'wakeup':
                    wakeUpMushroom(row, col);
                    break;
                case 'regular':
                    plantRegular(row, col, plantToPlaceType, selectedPlantTypeInfo);
                    break;
                default:
                    gameState.sun += gameState.selectedPlant.cost; // Refund
                    return;
            }

            const plantCard = gameState.selectedPlant.cardElement;
            if (plantCard && selectedPlantTypeInfo.cooldown) {
                startCooldown(plantCard, selectedPlantTypeInfo.cooldown);
            }

            addScore(25);
            gameState.selectedPlant = null;
            document.querySelectorAll('.plantCard').forEach(c => c.classList.remove('selected'));
            updateSunDisplay();
        }

        // --- Function to trigger insta-plants ---
        function activatePlantEffect(plant) {
            // Failsafe: if plant was dug up just as the timer fired, do nothing.
            if (!plant.element || !gameState.plants.includes(plant)) {
                return;
            }

            const plantType = plantTypes[plant.type];
            const row = plant.row;
            const col = plant.col;
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            if (!cell) return;

            // --- Effect Logic ---
            const zombiesToDamage = [];

            if (plantType.radius) { // Cherry Bomb Logic
                const explosionElement = document.createElement('div');
                explosionElement.className = 'instant-effect';
                explosionElement.textContent = 'ðŸ’¥';
                if (mobileDevice) {
                    explosionElement.style.cssText = `position: absolute; font-size: 7em; z-index: 10; filter: drop-shadow(0 0 15px red); transform: translate(-50%, -50%); top: 50%; left: 50%; pointer-events: none;`;
                } else {
                    explosionElement.style.cssText = `position: absolute; font-size: 10em; z-index: 10; filter: drop-shadow(0 0 15px red); transform: translate(-50%, -50%); top: 50%; left: 50%; pointer-events: none;`;
                }
                cell.appendChild(explosionElement);
                createTimer(600, () => explosionElement.remove(), false, 'remove_explosionElement');

                // Visual markers and zombie targeting
                for (let r = row - plantType.radius; r <= row + plantType.radius; r++) {
                    for (let c = col - plantType.radius; c <= col + plantType.radius; c++) {
                        if (r >= 0 && r < 5 && c >= 0 && c < 9) {
                            const affectedCell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
                            if (affectedCell) {
                                const marker = document.createElement('div');
                                marker.className = 'instant-effect';
                                marker.textContent = 'ðŸ’¥';
                                marker.style.cssText = `color: red; font-weight: bold; position: absolute; z-index: 11; animation: pointsFloat calc(1s / var(--game-speed)) ease-out; pointer-events: none;`;
                                affectedCell.appendChild(marker);
                                createTimer(1000, () => marker.remove(), false, 'marker_remove');
                            }
                        }
                    }
                }
                gameState.zombies.forEach(zombie => {
                    const zombieCol = Math.floor(zombie.x / gameState.cellSize.width);
                    if (zombie.row >= row - plantType.radius && zombie.row <= row + plantType.radius &&
                        zombieCol >= col - plantType.radius && zombieCol <= col + plantType.radius) {
                        if (!zombiesToDamage.includes(zombie)) zombiesToDamage.push(zombie);
                    }
                });
            } else if (plantType.laneWide) { // Jalapeno AND Hurrikale Logic
                if (plantType.isPusher) { // Hurrikale
                    const windElement = document.createElement('div');
                    windElement.className = 'instant-effect';
                    windElement.textContent = 'ðŸ’¨';
                    if (mobileDevice) {
                        windElement.style.cssText = `position: fixed; font-size: 3em; z-index: 10; opacity: 0.7; top: ${gameState.boardRect.top + row * gameState.cellSize.height + 10}px; left: ${gameState.boardRect.left}px; animation: windBlow calc(0.8s / var(--game-speed)) ease-out forwards;`;
                    } else {
                        windElement.style.cssText = `position: fixed; font-size: 4em; z-index: 10; opacity: 0.7; top: ${gameState.boardRect.top + row * gameState.cellSize.height + 20}px; left: ${gameState.boardRect.left}px; animation: windBlow calc(0.8s / var(--game-speed)) ease-out forwards;`;
                    }
                    document.getElementById('gameContainer').appendChild(windElement);
                    createTimer(800, () => windElement.remove(), false, 'windElement_remove');
                    const zombiesToPush = gameState.zombies.filter(zombie => zombie.row === row);
                    zombiesToPush.forEach(zombie => {
                        if (!zombie.element) return;
                        zombie.isBeingPushed = true;
                        zombie.element.classList.remove('eating');
                        if (!zombie.isFrozen) {
                            zombie.slowed = true;
                            zombie.slowTimer = 8000;
                            if (zombie.element) zombie.element.classList.add('slowed');
                        }
                    });
                } else { // Jalapeno
                    for (let c = 0; c < 9; c++) {
                        const affectedCell = document.querySelector(`.cell[data-row='${row}'][data-col='${c}']`);
                        if (affectedCell) {
                            const fireElement = document.createElement('div');
                            fireElement.className = 'instant-effect';
                            fireElement.textContent = 'ðŸ”¥';
                            if (mobileDevice) {
                                fireElement.style.cssText = `position: absolute; font-size: 2.5em; z-index: 10; animation: fireGlow calc(0.5s / var(--game-speed)) infinite alternate;`;
                            } else {
                                fireElement.style.cssText = `position: absolute; font-size: 3.5em; z-index: 10; animation: fireGlow calc(0.5s / var(--game-speed)) infinite alternate;`;
                            }
                            affectedCell.appendChild(fireElement);
                            createTimer(1000, () => fireElement.remove(), false, 'fireElement_remove');
                            const iceTrailIndex = gameState.iceTrails.findIndex(t => t.row === row && t.col === c);
                            if (iceTrailIndex !== -1) {
                                const iceTrail = gameState.iceTrails[iceTrailIndex];
                                clearTimer(iceTrail.timerId);
                                iceTrail.cellElement.classList.remove('iced');
                                gameState.iceTrails.splice(iceTrailIndex, 1);
                            }
                        }
                    }
                    gameState.zombies.forEach(zombie => {
                        if (zombie.row === row) {
                            if (!zombiesToDamage.includes(zombie)) zombiesToDamage.push(zombie);
                        }
                    });
                }
            } else if (plantType.isBlower) { // Blover Logic
                for (let i = 0; i < 5; i++) {
                    const windElement = document.createElement('div');
                    windElement.className = 'instant-effect';
                    windElement.textContent = 'ðŸ’¨';
                    if (mobileDevice) {
                        windElement.style.cssText = `position: fixed; font-size: 3em; z-index: 10; opacity: 0.7; top: ${gameState.boardRect.top + i * gameState.cellSize.height + 10}px; left: ${gameState.boardRect.left}px; animation: windBlow calc(0.5s / var(--game-speed)) ease-out forwards;`;
                    } else {
                        windElement.style.cssText = `position: fixed; font-size: 4em; z-index: 10; opacity: 0.7; top: ${gameState.boardRect.top + i * gameState.cellSize.height + 20}px; left: ${gameState.boardRect.left}px; animation: windBlow calc(0.5s / var(--game-speed)) ease-out forwards;`;
                    }
                    document.getElementById('gameContainer').appendChild(windElement);
                    createTimer(800, () => windElement.remove(), false, 'windElement_remove');
                }
                const zombiesToBlow = gameState.zombies.filter(z => z.isFlying);
                zombiesToBlow.forEach(zombie => {
                    zombie.health = 0;
                    handleZombieDefeat(zombie, 'ðŸ’¨');
                });
                gameState.zombies = gameState.zombies.filter(z => z.element !== null);
            }

            // Damage application and cleanup
            zombiesToDamage.forEach(zombie => {
                zombie.health -= plantType.damage;
                checkZombieStateChange(zombie);

                // Thaw/unfreeze logic from the old function
                if (zombie.isFrozen) {
                    zombie.isFrozen = false;
                    zombie.freezeTimer = 0;
                    if (zombie.element) {
                        zombie.element.classList.remove('frozen');
                        createParticleEffect(zombie.element, 'ðŸ’¨');
                    }
                } else if (zombie.slowed) {
                    zombie.slowed = false;
                    zombie.slowTimer = 0;
                    if (zombie.element) {
                        zombie.element.classList.remove('slowed');
                        createParticleEffect(zombie.element, 'ðŸ’¨');
                    }
                }

                if (zombie.health <= 0) handleZombieDefeat(zombie);
                else {
                    if (zombie.element) {
                        updateZombieHealth(zombie);
                        zombie.element.classList.add('damage-effect');
                        createTimer(300, () => {
                            if (zombie.element) zombie.element.classList.remove('damage-effect');
                        }, false, 'remove_damage-effect');
                    }
                }
            });
            gameState.zombies = gameState.zombies.filter(z => z.element !== null);

            // --- Plant Self-Destruction ---
            if (plant.element) {
                plant.element.remove();
            }
            const plantIndex = gameState.plants.indexOf(plant);
            if (plantIndex > -1) {
                gameState.plants.splice(plantIndex, 1);
            }
        }

        // --- Central function for mushroom effects ---
        function triggerMushroomEffect(plant) {
            if (!plant) return;

            const plantType = plantTypes[plant.type];
            const cell = document.querySelector(`.cell[data-row='${plant.row}'][data-col='${plant.col}']`);
            if (!cell) return;

            if (plantType.type === 'doomshroom' || plantType.radiusX) {
                const explosionElement = document.createElement('div');
                explosionElement.className = 'instant-effect';
                explosionElement.textContent = 'ðŸ’¥';
                if (mobileDevice) {
                    explosionElement.style.cssText = `position: absolute; font-size: 17em; z-index: 10; filter: drop-shadow(0 0 25px purple); transform: translate(-50%, -50%); top: 50%; left: 50%; pointer-events: none;`;
                } else {
                    explosionElement.style.cssText = `position: absolute; font-size: 22em; z-index: 10; filter: drop-shadow(0 0 25px purple); transform: translate(-50%, -50%); top: 50%; left: 50%; pointer-events: none;`;
                }
                cell.appendChild(explosionElement);
                createTimer(800, () => explosionElement.remove(), false, 'remove_doomshroom_visual');

                if (plantType.createsCrater) {
                    cell.classList.add('crater');
                    createTimer(180000, () => {
                        cell.classList.remove('crater');
                    }, false, 'craterRemoval', { row: plant.row, col: plant.col });
                }

                const minRow = plant.row - plantType.radiusY;
                const maxRow = plant.row + plantType.radiusY;
                const minCol = plant.col - plantType.radiusX;
                const maxCol = plant.col + plantType.radiusX;

                gameState.zombies.forEach(zombie => {
                    if (!zombie.element) return;

                    const zombieCol = Math.floor(zombie.x / gameState.cellSize.width);

                    if (zombie.row >= minRow && zombie.row <= maxRow && zombieCol >= minCol && zombieCol <= maxCol) {
                        zombie.health -= plantType.damage;
                        checkZombieStateChange(zombie);
                        updateZombieHealth(zombie);
                        if (zombie.health <= 0) handleZombieDefeat(zombie);
                    }
                });
            } else if (plantType.type === 'iceshroom' || plantType.freezes) {
                const explosionElement = document.createElement('div');
                explosionElement.className = 'instant-effect';
                explosionElement.textContent = 'â„ï¸';
                if (mobileDevice) {
                    explosionElement.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); font-size: 15em; z-index: 50; color: lightblue; opacity: 0.8; animation: freezeFlash calc(0.75s / var(--game-speed)) ease-out;`;
                } else {
                    explosionElement.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0); font-size: 20em; z-index: 50; color: lightblue; opacity: 0.8; animation: freezeFlash calc(0.75s / var(--game-speed)) ease-out;`;
                }
                document.getElementById('gameContainer').appendChild(explosionElement);
                createTimer(1000, () => explosionElement.remove(), false, 'remove_iceshroom_visual');

                gameState.zombies.forEach(zombie => {
                    if (zombie.element) {
                        zombie.health -= plantType.damage;
                        checkZombieStateChange(zombie);
                        zombie.isFrozen = true;
                        zombie.freezeTimer = 4000;
                        zombie.element.classList.remove('slowed');
                        zombie.element.classList.add('frozen');
                        zombie.element.classList.remove('eating');
                        updateZombieHealth(zombie);
                        if (zombie.health <= 0) handleZombieDefeat(zombie);
                    }
                });
            }

            // Clean up the plant from the board and game state
            if (plant.element) {
                plant.element.remove();
            }
            const plantIndex = gameState.plants.indexOf(plant);
            if (plantIndex > -1) {
                gameState.plants.splice(plantIndex, 1);
            }

            // Filter zombies array
            gameState.zombies = gameState.zombies.filter(z => z.health > 0);
        }

        // Update Plant Health
        function updatePlantHealth(plant) {
            if (!plant.element || !plant.healthFill) return;

            const healthPercent = Math.max(0, plant.health / plant.maxHealth);
            plant.healthFill.style.width = (healthPercent * 100) + '%';

            if (healthPercent < 0.3) {
                plant.healthFill.style.background = 'linear-gradient(90deg, #ff0000, #ff6600)';
            } else if (healthPercent < 0.6) {
                plant.healthFill.style.background = 'linear-gradient(90deg, #FFA500, #FFD700)';
            } else {
                plant.healthFill.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
            }
        }

        // Produce Sun
        function produceSun(plant) {
            if (!plant.element || !plant.element.parentElement) return;

            const cell = plant.element.parentElement;
            const rect = cell.getBoundingClientRect();
            const plantType = plantTypes[plant.type];
            let sunValue;
            if (plant.type === 'sunshroom') {
                sunValue = plant.isGrown ? plantType.sunAmount : 30;
            } else {
                sunValue = plantType.sunAmount || 50;
            }

            const sun = document.createElement('div');
            sun.className = 'sun';

            const sunEmoji = document.createElement('span');
            sunEmoji.textContent = plantType.produces === 'coin' ? 'ðŸ’°' : 'â˜€ï¸';
            sun.appendChild(sunEmoji);

            const sunValueElement = document.createElement('span');
            sunValueElement.className = 'sun-value';
            sunValueElement.textContent = sunValue;
            if (plantType.produces === 'coin') {
                sunValueElement.style.display = 'none';
            }
            sun.appendChild(sunValueElement);

            // Give the sun element a unique ID for tracking its timer
            const sunId = `sun-${gameState.nextId++}`;
            sun.dataset.sunId = sunId;

            const startLeft = rect.left + rect.width / 2 - 15 + (Math.random() * 40 - 20);
            const startTop = rect.top;

            sun.style.left = startLeft + 'px';
            sun.style.top = startTop + 'px';
            sun.style.animation = 'none';
            sun.style.position = 'fixed';

            sun.style.transform = 'scale(0) translateY(20px)';
            sun.style.opacity = '0';
            sun.style.transition = 'transform calc(0.4s / var(--game-speed)) cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity calc(0.3s / var(--game-speed)) ease-out, top calc(0.3s / var(--game-speed)) ease-out';

            document.getElementById('gameContainer').appendChild(sun);

            setTimeout(() => {
                sun.style.transform = 'scale(1)';
                sun.style.opacity = '1';
                sun.style.top = (startTop - 15) + 'px';
            }, 10);

            sun.addEventListener('click', () => collectSun(sun, sunValue));
            sun.addEventListener('touchstart', (e) => { e.preventDefault(); collectSun(sun, sunValue); }, { passive: false });

            createTimer(7000, () => {
                if (sun.parentElement && !sun.dataset.collecting) {
                    sun.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease-in, transform calc(0.5s / var(--game-speed)) ease-in';
                    sun.style.opacity = '0';
                    sun.style.transform = 'scale(0.5)';
                    createTimer(500, () => sun.remove(), false, 'sun_remove');
                }
            }, false, 'sunDespawn', sunId);
        }

        // Shoot Projectile
        function shoot(plant) {
            if (!plant.element || !plant.element.parentElement) return;

            const plantType = plantTypes[plant.type];
            if (!plantType.shoots || plant.shootCooldown > 0) return;

            // Scaredy-Shroom Logic
            if (plantType.isScaredy) {
                const isScared = gameState.zombies.some(zombie => {
                    // Check if the zombie's row is adjacent (or the same)
                    const isRowClose = Math.abs(zombie.row - plant.row) <= 1;
                    if (!isRowClose) return false;

                    const zombieCol = Math.floor(zombie.x / gameState.cellSize.width);

                    const isColClose = Math.abs(zombieCol - plant.col) <= 1;

                    return isColClose;
                });

                if (isScared) {
                    plant.element.classList.add('spike-plant'); // Use spikeweed style for hiding
                    return; // Don't shoot
                } else {
                    plant.element.classList.remove('spike-plant');
                }
            }

            let targetRows = [plant.row];
            if (plantType.triple) {
                targetRows = [plant.row - 1, plant.row, plant.row + 1].filter(r => r >= 0 && r < 5);
            }

            const hasTarget = targetRows.some(row =>
                gameState.zombies.some(z => {
                    if (z.row !== row || !z.element || z.x <= plant.col * gameState.cellSize.width) return false;

                    // Range Logic (for Puff-shroom & Fume-shroom)
                    if (plantType.range) {
                        const maxRange = (plant.col + plantType.range + 0.5) * gameState.cellSize.width;
                        if (z.x > maxRange) return false;
                    }

                    return plant.type === 'cactus' || !z.isFlying;
                })
            );


            if (!hasTarget) return;

            plant.shootCooldown = plantType.shootInterval;
            plant.element.classList.add('shooting');
            createTimer(300, () => {
                if (plant.element) plant.element.classList.remove('shooting');
            }, false, 'remove_shooting');

            const cell = plant.element.parentElement;
            const rect = cell.getBoundingClientRect();

            const createProjectileForRow = (targetRow) => {
                const hasRowTarget = gameState.zombies.some(z => {
                    if (z.row !== targetRow || !z.element) return false;
                    return plant.type === 'cactus' || !z.isFlying;
                });

                if (!hasRowTarget) return;

                const projectile = document.createElement('div');
                projectile.className = 'projectile';
                if (plantType.fire) projectile.classList.add('fire');
                projectile.textContent = plantType.projectile || 'ðŸŸ¢';

                const rowY = gameState.boardRect.top + targetRow * gameState.cellSize.height + gameState.cellSize.height / 2 - 10;

                projectile.style.left = (rect.left + rect.width * 0.7) + 'px';
                projectile.style.top = rowY + 'px';
                projectile.style.position = 'fixed';

                document.getElementById('gameContainer').appendChild(projectile);

                let projectileDamage = plantType.damage;
                let stunDuration = 0;
                if (plantType.hasButter && plant.type === 'kernelpult') {
                    if (Math.random() < 0.25) {
                        projectile.textContent = 'ðŸ§ˆ';
                        projectileDamage = 2;
                        stunDuration = 5000;
                    }
                }

                const startX = rect.left + rect.width * 0.7 - gameState.boardRect.left;
                const proj = {
                    element: projectile,
                    row: targetRow,
                    damage: projectileDamage,
                    splashDamage: plantType.splashDamage,
                    splashRadiusY: plantType.splashRadiusY,
                    slow: plantType.slow,
                    fire: plantType.fire,
                    stunDuration: stunDuration,
                    pierce: plantType.pierce,
                    x: startX,
                    startX: startX, // Store the starting position
                    range: plantType.range, // Pass range to projectile
                    speed: 200,
                    hitZombies: [],
                    hitTorchwoods: []
                };

                gameState.projectiles.push(proj);
            };

            targetRows.forEach(row => {
                createProjectileForRow(row);
            });

            if (plantType.double) {
                createTimer(200, () => {
                    targetRows.forEach(row => {
                        createProjectileForRow(row);
                    });
                });
            }

            if (plantType.quad) {
                createTimer(133, () => {
                    targetRows.forEach(row => {
                        createProjectileForRow(row);
                    });
                });
                createTimer(266, () => {
                    targetRows.forEach(row => {
                        createProjectileForRow(row);
                    });
                });
                createTimer(399, () => {
                    targetRows.forEach(row => {
                        createProjectileForRow(row);
                    });
                });
            }
        }

        // Move Projectiles
        function moveProjectiles(deltaTime) {
            const adjustedDelta = deltaTime * gameState.gameSpeed;
            gameState.projectiles = gameState.projectiles.filter(proj => {
                if (!proj.element || !proj.element.parentElement) return false;

                proj.x += proj.speed * adjustedDelta / 1000;
                proj.element.style.left = (gameState.boardRect.left + proj.x) + 'px';

                // Logic for sequential Torchwood interaction
                const projCol = Math.floor(proj.x / gameState.cellSize.width);
                const torchwood = gameState.plants.find(p =>
                    p.type === 'torchwood' &&
                    p.row === proj.row &&
                    p.col === projCol
                );

                if (torchwood) {
                    const torchwoodId = `${torchwood.row}-${torchwood.col}`;
                    if (!proj.hitTorchwoods.includes(torchwoodId)) {
                        proj.hitTorchwoods.push(torchwoodId);

                        if (torchwood.element) {
                            torchwood.element.classList.add('shooting');
                            createTimer(300, () => {
                                if (torchwood.element) torchwood.element.classList.remove('shooting');
                            }, false, 'remove_shooting');
                        }

                        if (proj.element.textContent === 'â„ï¸' || proj.element.textContent === 'ðŸ§Š') {
                            proj.element.textContent = 'ðŸŸ¢';
                            proj.slow = false;
                        } else if (proj.element.textContent === 'ðŸŸ¢') {
                            proj.damage *= 2;
                            proj.element.textContent = 'ðŸ”¥';
                            proj.element.classList.add('fire');
                            proj.splashDamage = 0.65; // Add splash damage
                            proj.splashRadiusY = 0;   // 3x1 radius
                            proj.fire = true;
                        }
                    }
                }

                const rowY = gameState.boardRect.top + proj.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 10;
                proj.element.style.top = rowY + 'px';

                const projRect = proj.element.getBoundingClientRect();
                let hit = false;

                // Only check for collisions with zombies if the projectile is NOT from a zombie
                if (proj.owner !== 'zombie') {
                    for (const zombie of gameState.zombies) {
                        if (hit) break; // If projectile has already hit, stop checking
                        if (!zombie.element || zombie.row !== proj.row || proj.hitZombies.includes(zombie)) continue;

                        const zombieRect = zombie.element.getBoundingClientRect();

                        if (projRect.left < zombieRect.right && projRect.right > zombieRect.left) {
                            // Flying zombies can only be hit by piercing projectiles (e.g., Cactus)
                            if (zombie.isFlying && !proj.pierce) {
                                continue;
                            }

                            // Balloon Zombie Logic: popping the balloon
                            if (proj.pierce && zombie.isFlying) {
                                zombie.isFlying = false;

                                const zombieEmoji = zombie.element.firstChild;
                                if (zombieEmoji) {
                                    zombieEmoji.textContent = 'ðŸ§Ÿ';
                                }
                                zombie.element.style.transition = `top calc(0.3s / var(--game-speed)) ease-in`;
                                const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + gameState.cellSize.height / 2 - 20;
                                zombie.element.style.top = yPosition + 'px';

                                zombie.element.appendChild(zombie.healthBar);

                                createTimer(300, () => {
                                    if (zombie.element) zombie.element.style.transition = '';
                                }, false, 'reset_zombie_transition');
                            }

                            // Apply stun from butter before damage processing
                            if (proj.stunDuration > 0) {
                                zombie.isStunned = true;
                                zombie.stunTimer = proj.stunDuration;
                                if (zombie.element) {
                                    zombie.element.classList.add('stunned');
                                }
                            }

                            // --- SPLASH DAMAGE LOGIC (Melon-pult & Winter Melon) ---
                            if (proj.splashDamage) {
                                hit = true; // Splash projectiles are consumed on first hit

                                // Use existing particle mechanic for splash effect
                                createParticleEffect(zombie.element, proj.slow ? 'â„ï¸' : (proj.fire ? 'ðŸ”¥' : 'ðŸ’§'));

                                // Damage primary target
                                zombie.health -= proj.damage;
                                checkZombieStateChange(zombie);
                                updateZombieHealth(zombie);
                                if (zombie.element) zombie.element.classList.add('damage-effect');
                                createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); }, false, 'remove_damage-effect');

                                if (proj.slow && !zombie.isFrozen) {
                                    zombie.slowed = true;
                                    zombie.slowTimer = 3000;
                                    if (zombie.element) zombie.element.classList.add('slowed');
                                }

                                if (proj.fire && zombie.element) {
                                    if (zombie.isFrozen) {
                                        zombie.isFrozen = false;
                                        zombie.freezeTimer = 0;
                                        zombie.element.classList.remove('frozen');
                                        createParticleEffect(zombie.element, 'ðŸ’¨'); // Melt effect
                                    } else if (zombie.slowed) {
                                        zombie.slowed = false;
                                        zombie.slowTimer = 0;
                                        zombie.element.classList.remove('slowed');
                                        createParticleEffect(zombie.element, 'ðŸ’¨');
                                    }
                                }

                                if (zombie.health <= 0) handleZombieDefeat(zombie);

                                const impactX = zombie.x;
                                const splashRadiusX = gameState.cellSize.width * 0.75; // Splash width

                                // Find and damage/slow splash targets based on proximity
                                gameState.zombies.forEach(splashTarget => {
                                    if (proj.fire && splashTarget.type === 'trashCanZombie' && !splashTarget.armorBroken) return;
                                    if (splashTarget === zombie || !splashTarget.element || splashTarget.isFlying) return;

                                    // Check if the target is within the horizontal and vertical splash radius
                                    const isHorizontallyClose = Math.abs(splashTarget.x - impactX) <= splashRadiusX;
                                    const isVerticallyClose = Math.abs(splashTarget.row - proj.row) <= proj.splashRadiusY;

                                    if (isHorizontallyClose && isVerticallyClose) {
                                        // Apply splash damage
                                        splashTarget.health -= proj.splashDamage;
                                        checkZombieStateChange(splashTarget);
                                        updateZombieHealth(splashTarget);
                                        if (splashTarget.element) splashTarget.element.classList.add('damage-effect');
                                        createTimer(300, () => { if (splashTarget.element) splashTarget.element.classList.remove('damage-effect'); }, false, 'remove_damage-effect');

                                        // Apply slow effect if projectile has it
                                        if (proj.slow && !splashTarget.isFrozen) {
                                            splashTarget.slowed = true;
                                            splashTarget.slowTimer = 3000; // Standard slow duration
                                            if (splashTarget.element) splashTarget.element.classList.add('slowed');
                                        }

                                        if (proj.fire && splashTarget.element) {
                                            if (splashTarget.isFrozen) {
                                                splashTarget.isFrozen = false;
                                                splashTarget.freezeTimer = 0;
                                                splashTarget.element.classList.remove('frozen');
                                                createParticleEffect(splashTarget.element, 'ðŸ’¨');
                                            } else if (splashTarget.slowed) {
                                                splashTarget.slowed = false;
                                                splashTarget.slowTimer = 0;
                                                splashTarget.element.classList.remove('slowed');
                                                createParticleEffect(splashTarget.element, 'ðŸ’¨');
                                            }
                                        }

                                        if (splashTarget.health <= 0) handleZombieDefeat(splashTarget);
                                    }
                                });

                            } else { // --- STANDARD/PIERCING DAMAGE LOGIC ---
                                zombie.health -= proj.damage;
                                checkZombieStateChange(zombie);
                                updateZombieHealth(zombie);
                                zombie.element.classList.add('damage-effect');

                                if (proj.slow && !zombie.isFrozen && !(zombie.type === 'trashCanZombie' && !zombie.armorBroken)) {
                                    zombie.slowed = true;
                                    zombie.slowTimer = 3000;
                                    zombie.element.classList.add('slowed');
                                }

                                if (proj.fire && zombie.element) {
                                    if (zombie.isFrozen) {
                                        zombie.isFrozen = false;
                                        zombie.freezeTimer = 0;
                                        zombie.element.classList.remove('frozen');
                                        createParticleEffect(zombie.element, 'ðŸ’¨');
                                    } else if (zombie.slowed) {
                                        zombie.slowed = false;
                                        zombie.slowTimer = 0;
                                        zombie.element.classList.remove('slowed');
                                        createParticleEffect(zombie.element, 'ðŸ’¨');
                                    } else {
                                        createParticleEffect(zombie.element, 'ðŸ”¥');
                                    }
                                }

                                createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); }, false, 'remove_damage-effect');

                                if (zombie.health <= 0) handleZombieDefeat(zombie);

                                if (!proj.pierce) {
                                    hit = true;
                                } else {
                                    proj.hitZombies.push(zombie);
                                }
                            }
                        }
                    }
                }
                if (proj.owner === 'zombie') {
                    const projRect = proj.element.getBoundingClientRect();
                    for (const plant of gameState.plants) {
                        if (!plant.element || plant.row !== proj.row) continue;

                        const plantType = plantTypes[plant.type];
                        if (plantType.isSpike) continue; // Peas fly over spike plants

                        const plantRect = plant.element.getBoundingClientRect();

                        if (projRect.right > plantRect.left && projRect.left < plantRect.right) {
                            plant.health -= proj.damage;
                            updatePlantHealth(plant);
                            plant.element.classList.remove('plant-spawn');
                            plant.element.classList.add('plant-damage-effect');
                            createTimer(300, () => { if (plant.element) plant.element.classList.remove('plant-damage-effect'); });

                            if (plant.health <= 0) {
                                if (plant.armingTimerId) clearTimer(plant.armingTimerId);
                                if (plant.graveBusterTimerId) clearTimer(plant.graveBbusterTimerId);
                                createParticleEffect(plant.element, 'ðŸ’¥');
                                plant.element.remove();
                                plant.element = null;
                            }
                            hit = true; // Mark projectile as hit
                            break; // Stop checking other plants
                        }
                    }
                    gameState.plants = gameState.plants.filter(p => p.element);
                }

                // Check for projectiles with a limited range
                if (proj.range) {
                    const distanceTraveled = proj.x - proj.startX;
                    const maxDistance = proj.range * gameState.cellSize.width;
                    if (distanceTraveled > maxDistance) {
                        proj.element.remove();
                        return false;
                    }
                }

                if (hit || proj.x > window.innerWidth || proj.x < -20) {
                    proj.element.remove();
                    return false;
                }

                return true;
            });
        }

        // Move Lawnmowers
        function updateLawnmowers(deltaTime) {
            let zombiesKilledByMower = false;
            gameState.lawnmowers.forEach(mower => {
                if (!mower.moving || !mower.element) return;

                // Move mower
                const mowerSpeed = 500;
                mower.x += mowerSpeed * deltaTime / 1000 * gameState.gameSpeed;
                mower.element.style.left = (gameState.boardRect.left + mower.x) + 'px';

                // Check for collision with zombies in the same lane
                gameState.zombies.forEach(zombie => {
                    if (zombie.element && zombie.row === mower.row && zombie.x < mower.x + mower.element.offsetWidth) {
                        zombie.health = 0;
                        handleZombieDefeat(zombie, 'ðŸ’¥');
                        zombiesKilledByMower = true;
                    }
                });

                // Remove mower after it goes off screen
                if (mower.x > gameState.boardRect.width) {
                    mower.element.remove();
                    mower.element = null;
                }
            });

            // If any zombies were killed, filter the main array once
            if (zombiesKilledByMower) {
                gameState.zombies = gameState.zombies.filter(z => z.element);
            }
        }

        // Update Zombie Health Bar
        function updateZombieHealth(zombie) {
            if (!zombie.element || !zombie.healthBar) return;

            const healthPercent = Math.max(0, zombie.health / zombieTypes[zombie.type].maxHealth);
            zombie.healthFill.style.width = (healthPercent * 100) + '%';
        }

        // Check for zombie state changes after taking damage (e.g., armor breaking)
        function checkZombieStateChange(zombie) {
            if (!zombie.element || zombie.armorBroken) return;

            const isConehead = zombie.type === 'cone';
            const isbuckethead = zombie.type === 'bucket';
            const isNewspaper = zombie.type === 'newspaper';
            const isTrashCan = zombie.type === 'trashCanZombie';

            // Only proceed if it's one of the armored types we're handling
            if (!isConehead && !isbuckethead && !isNewspaper && !isTrashCan) return;

            let breakHealth;
            let particleEmoji;

            // Set the specific properties for each armor type
            if (isNewspaper) {
                breakHealth = zombieTypes.normal.maxHealth;
                particleEmoji = 'ðŸ’¢';
            } else if (isTrashCan) {
                breakHealth = zombieTypes.normal.maxHealth;
                particleEmoji = 'ðŸ—‘ï¸';
            } else if (isConehead) {
                breakHealth = zombieTypes.normal.maxHealth;
                particleEmoji = 'âš ï¸';
            } else if (isbuckethead) {
                breakHealth = zombieTypes.normal.maxHealth;
                particleEmoji = 'ðŸŽ“';
            }

            // Check if the health is below the specific breaking point
            if (zombie.health <= breakHealth) {
                zombie.armorBroken = true;
                const attachment = zombie.element.querySelector('.zombie-attachment');

                if (attachment) {
                    createParticleEffect(attachment, particleEmoji);
                    attachment.remove();
                }

                // Add the enraged class only for the newspaper zombie
                if (isNewspaper) {
                    zombie.element.classList.add('enraged');
                }
            }
        }

        // Create Ice Trail
        function createIceTrail(row, col) {
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            if (!cell || cell.classList.contains('iced')) return;

            cell.classList.add('iced');

            const timerId = createTimer(90000, () => {
                cell.classList.remove('iced');
                const index = gameState.iceTrails.findIndex(t => t.row === row && t.col === col);
                if (index !== -1) {
                    gameState.iceTrails.splice(index, 1);
                }
            }, false, 'iceTrailMelt', { row, col });

            gameState.iceTrails.push({ row, col, cellElement: cell, timerId });
        }

        // Summon Backup Dancers
        function summonBackupDancers(leader) {
            if (!leader || !leader.element) return;

            const now = Date.now();
            leader.lastSummon = now;

            const leaderCol = Math.floor(leader.x / gameState.cellSize.width);

            // Define relative positions
            const positions = [
                { r: leader.row - 1, c: leaderCol }, // Above
                { r: leader.row + 1, c: leaderCol }, // Below
                { r: leader.row, c: leaderCol - 1 }, // Behind
                { r: leader.row, c: leaderCol + 1 }  // In front
            ];

            // Filter out dead or non-existent dancers
            leader.dancers = leader.dancers.filter(d => d.element);

            positions.forEach(pos => {
                // Check if position is valid
                if (pos.r < 0 || pos.r > 4 || pos.c < 0 || pos.c > 8) return;

                // Check if a dancer (from this leader) is already there
                const dancerExists = leader.dancers.some(d => d.row === pos.r && d.spawnCol === pos.c);
                if (dancerExists) return;

                // Check if the cell is blocked (crater, ice)
                const cell = document.querySelector(`.cell[data-row='${pos.r}'][data-col='${pos.c}']`);
                if (!cell || cell.classList.contains('crater')) return;

                // Only spawn if dancer count is less than 4
                if (leader.dancers.length < 4) {
                    const newDancer = spawnZombieAt(pos.r, pos.c, 'backupDancer');
                    if (newDancer) {
                        newDancer.leader = leader;
                        newDancer.spawnCol = pos.c; // Store original spawn col for tracking
                        leader.dancers.push(newDancer);
                    }
                }
            });
        }


        // Move Zombies
        function moveZombies(deltaTime) {
            const adjustedDelta = deltaTime * gameState.gameSpeed;
            const now = Date.now();

            // --- Dancing Zombie Group Logic ---
            const dancingLeaders = gameState.zombies.filter(z => z.type === 'dancing' && z.element);

            dancingLeaders.forEach(leader => {
                // 1. Check if group is slowed or attacking
                let isGroupSlowed = leader.slowed;
                let isGroupAttacking = leader.attacking;

                // Filter out dead dancers
                leader.dancers = leader.dancers.filter(d => d.element && d.health > 0);

                leader.dancers.forEach(dancer => {
                    if (dancer.slowed) isGroupSlowed = true;
                    if (dancer.attacking) isGroupAttacking = true;
                });

                // 2. Apply group state to leader and all dancers
                leader.isGroupSlowed = isGroupSlowed;
                leader.isGroupAttacking = isGroupAttacking;
                leader.dancers.forEach(dancer => {
                    dancer.isGroupSlowed = isGroupSlowed;
                    dancer.isGroupAttacking = isGroupAttacking;
                });

                // 3. Summon logic
                if (now - leader.lastSummon > leader.summonCooldown && leader.dancers.length < 4) {
                    summonBackupDancers(leader);
                }
            });

            gameState.zombies = gameState.zombies.filter(zombie => {
                if (!zombie.element) return false;

                const zombieCol = Math.floor(zombie.x / gameState.cellSize.width);

                if (zombie.isBeingPushed) {
                    zombie.x += 600 * adjustedDelta / 1000;

                    if (zombie.x >= gameState.boardRect.width) {
                        if (zombie.isFlying) {
                            zombie.health = 0;
                            handleZombieDefeat(zombie, 'ðŸ’¨');
                            return false;
                        } else {
                            zombie.x = gameState.boardRect.width;
                            zombie.isBeingPushed = false;
                        }
                    }

                    zombie.element.style.left = (gameState.boardRect.left + zombie.x) + 'px';
                    return true;
                }

                // Decrement all active cooldowns first
                if (zombie.attackCooldown > 0) {
                    zombie.attackCooldown -= adjustedDelta;
                }

                // Handle stun timers
                if (zombie.isStunned) {
                    zombie.stunTimer -= adjustedDelta;
                    if (zombie.stunTimer <= 0) {
                        zombie.isStunned = false;
                        if (zombie.element) zombie.element.classList.remove('stunned');
                    }
                }

                if (zombie.isFrozen) {
                    zombie.freezeTimer -= adjustedDelta;
                    if (zombie.freezeTimer <= 0) {
                        zombie.isFrozen = false;
                        zombie.element.classList.remove('frozen');
                        zombie.slowed = true;
                        zombie.slowTimer = 6000;
                        zombie.element.classList.add('slowed');
                    }
                }

                // --- Jack-in-the-Box Timer Pause/Resume Logic ---
                if (zombie.type === 'jackInTheBox') {
                    const isStopped = zombie.isFrozen || zombie.isStunned;

                    // Pause logic: If stopped and a timer is running
                    if (isStopped && zombie.explosionTimerId) {
                        const timer = gameState.timers[zombie.explosionTimerId];
                        if (timer) {
                            zombie.remainingExplosionTime = timer.remaining;
                            clearTimer(zombie.explosionTimerId);
                            zombie.explosionTimerId = null;
                        }
                    }
                    // Resume logic: If not stopped and has remaining time stored
                    else if (!isStopped && zombie.remainingExplosionTime) {
                        zombie.explosionTimerId = createTimer(zombie.remainingExplosionTime, () => explodeJackInTheBox(zombie), false, 'jackInTheBoxExplosion', zombie.id);
                        delete zombie.remainingExplosionTime; // Clear the stored time
                    }
                }

                // If stunned or frozen, skip all movement and attack logic for this frame
                if (zombie.element && zombie.isStunned || zombie.isFrozen) {
                    zombie.element.classList.remove('eating');
                    return true;
                }

                if ((zombie.type === 'gargantuar' || zombie.type === 'giga') && !zombie.hasThrownImp && zombie.health <= zombieTypes[zombie.type].maxHealth / 2 && zombieCol >= 4) {
                    zombie.hasThrownImp = true;
                    zombie.isThrowingImp = true;

                    if (zombie.element) {
                        zombie.element.classList.add('gargantuar-throwing');
                    }

                    createTimer(400, () => {
                        if (zombie.element) {
                            createFlyingImpVisual(zombie.element);
                        }
                    }, false, 'create_flying_imp_visual');

                    createTimer(1000, () => {
                        if (!zombie.element) {
                            return;
                        }

                        zombie.element.classList.remove('gargantuar-throwing');

                        const gargCol = Math.floor(zombie.x / gameState.cellSize.width);
                        const impSpawnCol = gargCol - 2;
                        if (impSpawnCol >= 0) {
                            spawnZombieAt(zombie.row, impSpawnCol, 'imp');
                        }

                        zombie.isThrowingImp = false;
                    }, false, 'spawn_thrown_imp');
                }

                if (zombie.slowTimer > 0) {
                    zombie.slowTimer -= adjustedDelta;
                    if (zombie.slowTimer <= 0) {
                        zombie.slowed = false;
                        zombie.element.classList.remove('slowed');
                    }
                }

                // Determine speed and attacking state (handles group logic and Gargantuar cooldown)
                const isSlowed = zombie.isGroupSlowed || zombie.slowed;
                let isAttacking = zombie.isGroupAttacking || zombie.attacking;
                const isFlyingAndNotAttacking = zombie.isFlying && !isAttacking;

                // Gargantuars on cooldown are considered 'attacking' to halt their movement.
                if (zombie.attackCooldown > 0 && (zombie.type === 'gargantuar' || zombie.type === 'giga')) {
                    isAttacking = true;
                }

                // Check for armed potato mines before moving
                const zombieColBeforeMove = Math.floor(zombie.x / gameState.cellSize.width);
                const mineOnTile = gameState.plants.find(p => p.type === 'potatomine' && p.isArmed && p.row === zombie.row && p.col === zombieColBeforeMove);

                if (mineOnTile && !zombie.isFlying) {
                    isAttacking = true;
                }

                // Only perform regular movement logic if not in the middle of a lane change or attacking
                if (!zombie.isChangingLane && !isAttacking && !zombie.isThrowingImp && !zombie.isThrowing) {
                    let baseSpeed = zombieTypes[zombie.type].speed;

                    if (zombie.type === 'newspaper' && zombie.armorBroken) {
                        baseSpeed *= zombieTypes.newspaper.rageSpeedMultiplier;
                    }

                    if (zombie.type === 'balloon' && !zombie.isFlying) {
                        baseSpeed = zombieTypes['normal'].speed;
                    }
                    const currentSpeed = isSlowed ? baseSpeed * 0.5 : baseSpeed;

                    zombie.x -= currentSpeed * adjustedDelta / 1000;
                    zombie.element.style.left = (gameState.boardRect.left + zombie.x) + 'px';

                    const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + (zombie.isFlying ? -10 : gameState.cellSize.height / 2 - 20) + (zombie.row * 2.5);
                    if (zombie.element.style.top !== yPosition + 'px' && !zombie.element.style.transition.includes('top')) {
                        zombie.element.style.top = yPosition + 'px';
                    }

                    if (zombieTypes[zombie.type].leavesIceTrail) {
                        const zomboniCenter = zombie.x + (gameState.cellSize.width / 2);
                        const zomboniCol = Math.floor(zomboniCenter / gameState.cellSize.width);
                        if (zomboniCol >= 0 && zomboniCol < 9) {
                            createIceTrail(zombie.row, zomboniCol);
                        }
                    }
                }

                zombie.attacking = false; // Reset attack flag, will be re-evaluated based on plant proximity
                const zombieTypeInfo = zombieTypes[zombie.type];

                gameState.plants.forEach(plant => {
                    if (!plant.element || plant.row !== zombie.row || zombie.isFlying || plant.isWrapped) return;

                    if (plant.col === zombieCol) {

                        if (plant.type === 'potatomine' && plant.isArmed) return;



                        const plantTypeInfo = plantTypes[plant.type];
                        const isSpikePlant = plantTypeInfo.isSpike;
                        const isCrusher = zombieTypeInfo.crushes || zombieTypeInfo.uneatable;

                        // --- ZOMBONI vs SPIKE INTERACTION ---
                        if (zombie.type === 'zomboni' && isSpikePlant) {
                            zombie.health = 0; // Zomboni is destroyed
                            if (plant.type === 'spikerock') {
                                plant.health -= plant.maxHealth / 3;
                                updatePlantHealth(plant);
                            } else {
                                plant.health = 0; // Spikeweed is destroyed
                            }
                            createParticleEffect(plant.element, 'ðŸ’¥');
                        }
                        // --- GARGANTUAR/GIGA CRUSHING INTERACTION ---
                        else if (zombie.type === 'gargantuar' || zombie.type === 'giga') {
                            zombie.attacking = true; // Stop movement

                            if (zombie.attackCooldown <= 0) { // Can it attack now?
                                zombie.attackCooldown = isSlowed ? 4000 : 2000;  // Set 2-second cooldown

                                const isInvinciblePlant = plantTypeInfo.isActivatingPlant || (plantTypeInfo.isMushroom && !plant.isSleeping && (plantTypeInfo.freezes || plantTypeInfo.radiusX));

                                if (!isInvinciblePlant) {
                                    if (plant.type === 'spikerock') {
                                        plant.health -= plant.maxHealth / 3;
                                        updatePlantHealth(plant);
                                    } else {
                                        plant.health = 0; // Insta-kill other plants
                                    }
                                    plant.element.classList.remove('plant-spawn');
                                    plant.element.classList.add('plant-damage-effect');
                                    createTimer(300, () => { if (plant.element) plant.element.classList.remove('plant-damage-effect'); }, false, 'remove_plant-damage-effect');
                                }
                            }
                        }
                        // --- OTHER CRUSHERS (Zomboni on non-spikes) ---
                        else if (isCrusher) {
                            const isInvinciblePlant = plantTypeInfo.isActivatingPlant || (plantTypeInfo.isMushroom && !plant.isSleeping && (plantTypeInfo.freezes || plantTypeInfo.radiusX));

                            if (!isInvinciblePlant) {
                                zombie.attacking = false; // Zomboni doesn't stop for non-spikes
                                plant.health = 0; // Insta-kill
                                plant.element.classList.remove('plant-spawn');
                                plant.element.classList.add('plant-damage-effect');
                                createTimer(300, () => { if (plant.element) plant.element.classList.remove('plant-damage-effect'); }, false, 'remove_plant-damage-effect');
                            }
                        }
                        // --- NORMAL ZOMBIE on SPIKE ---
                        else if (isSpikePlant) {
                            return; // Ignores for eating purposes
                        }
                        // --- NORMAL ZOMBIE EATING ---
                        else {
                            zombie.attacking = true;
                            zombie.element.classList.add('eating');
                            let animationSpeed = isSlowed ? 1 : 0.5;
                            if (zombie.type === 'newspaper' && zombie.armorBroken) {
                                animationSpeed /= zombieTypes.newspaper.rageSpeedMultiplier;
                            }
                            zombie.element.style.animationDuration = `calc(${animationSpeed}s / var(--game-speed))`;

                            if (zombie.attackCooldown <= 0) {
                                let baseCooldown = isSlowed ? 2000 : 1000;
                                if (zombie.type === 'newspaper' && zombie.armorBroken) {
                                    baseCooldown /= zombieTypes.newspaper.rageSpeedMultiplier;
                                }
                                zombie.attackCooldown = baseCooldown;

                                if (!(plantTypes[plant.type].isMushroom && !plant.isSleeping && (plantTypeInfo.freezes || plantTypeInfo.radiusX))) {
                                    const damage = getZombieDamage(zombieTypeInfo.damage);
                                    plant.health -= damage;
                                    updatePlantHealth(plant);
                                    plant.element.classList.remove('plant-spawn');
                                    plant.element.classList.add('plant-damage-effect');
                                    createTimer(300, () => { if (plant.element) plant.element.classList.remove('plant-damage-effect'); }, false, 'remove_plant-damage-effect');
                                }

                                if (plantTypes[plant.type].diverts && !zombie.isChangingLane) {
                                    zombie.isChangingLane = true;
                                    createTimer(200, () => {
                                        if (!zombie.element) { zombie.isChangingLane = false; return; }
                                        let possibleRows = [];
                                        if (zombie.row === 0) possibleRows.push(1);
                                        else if (zombie.row === 4) possibleRows.push(3);
                                        else possibleRows.push(zombie.row - 1, zombie.row + 1);
                                        zombie.row = possibleRows[Math.floor(Math.random() * possibleRows.length)];
                                        zombie.attacking = false;
                                        zombie.x -= gameState.cellSize.width * 0.375;
                                        const yPosition = gameState.boardRect.top + zombie.row * gameState.cellSize.height + (zombie.isFlying ? -10 : gameState.cellSize.height / 2 - 20) + (zombie.row * 2.5);
                                        zombie.element.style.transition = `top calc(0.3s / var(--game-speed)) ease, left calc(0.3s / var(--game-speed)) ease`;
                                        zombie.element.style.top = yPosition + 'px';
                                        zombie.element.style.left = (gameState.boardRect.left + zombie.x) + 'px';
                                        createTimer(300, () => {
                                            if (zombie.element) zombie.element.style.transition = '';
                                            zombie.isChangingLane = false;
                                        }, false, 'zombie_lane_change_finish');
                                    }, false, 'zombie_lane_change_start');
                                }
                            }
                        }

                        if (plant.health <= 0) {
                            if (plant.armingTimerId) clearTimer(plant.armingTimerId);
                            if (plant.graveBusterTimerId) clearTimer(plant.graveBusterTimerId);
                            createParticleEffect(plant.element, 'ðŸ’¥');
                            plant.element.remove();
                            plant.element = null;
                        }
                    }
                });

                if (zombie.health <= 0) handleZombieDefeat(zombie);
                if (zombie.element && !zombie.attacking) { zombie.element.classList.remove('eating'); zombie.element.style.animationDuration = ''; }
                if (zombie.x <= 0) {
                    const mower = gameState.lawnmowers.find(m => m.row === zombie.row);
                    if (mower && !mower.moving && mower.element) mower.moving = true;
                }
                if (zombie.x <= -gameState.cellSize.width && !activeChallenges.sandbox) gameOver();
                if (zombie.x <= -gameState.cellSize.width - 50) {
                    if (zombie.element) {
                        zombie.element.remove();
                    }
                    zombie.element = null;
                }
                return zombie.element !== null;
            });
        }

        // --- Jack-in-the-Box Zombie Logic ---

        function startJackInTheBoxTimer(zombie) {
            let delay;
            // 5% chance of fast explosion
            if (Math.random() < 0.05) {
                // 4.4 to 7.54 seconds
                delay = 4400 + Math.random() * (7540 - 4400);
            } else {
                // 95% chance of slow explosion
                // 13.22 to 22.68 seconds
                delay = 13220 + Math.random() * (22680 - 13220);
            }
            zombie.explosionTimerId = createTimer(delay, () => explodeJackInTheBox(zombie), false, 'jackInTheBoxExplosion', zombie.id);
        }

        function explodeJackInTheBox(zombie) {
            if (!zombie.element) return;

            const row = zombie.row;
            const col = Math.floor(zombie.x / gameState.cellSize.width);

            // Create visual explosion effect
            const cell = document.querySelector(`.cell[data-row='${row}'][data-col='${col}']`);
            if (cell) {
                const explosionElement = document.createElement('div');
                explosionElement.className = 'instant-effect';
                explosionElement.textContent = 'ðŸ’¥';
                explosionElement.style.cssText = `position: absolute; font-size: 7em; z-index: 10; filter: drop-shadow(0 0 15px red); transform: translate(-50%, -50%); top: 50%; left: 50%; pointer-events: none;`;
                cell.appendChild(explosionElement);
                createTimer(600, () => explosionElement.remove(), false, 'remove_explosionElement');
            }

            // Damage plants in 3x3 radius
            for (let r = row - 1; r <= row + 1; r++) {
                for (let c = col - 1; c <= col + 1; c++) {
                    if (r >= 0 && r < 5 && c >= 0 && c < 9) {
                        const plant = gameState.plants.find(p => p.row === r && p.col === c);
                        if (plant && plant.element) {
                            plant.health = 0;
                            if (plant.armingTimerId) clearTimer(plant.armingTimerId);
                            if (plant.graveBusterTimerId) clearTimer(plant.graveBusterTimerId);
                            plant.element.remove();
                            plant.element = null;
                        }
                    }
                }
            }

            // Clean up plants array
            gameState.plants = gameState.plants.filter(p => p.element);

            // Kill the Jack-in-the-Box zombie itself
            zombie.health = 0;
            handleZombieDefeat(zombie, 'ðŸ’¥');
        }

        // Generic function to spawn a zombie at a specific grid location
        function spawnZombieAt(row, col, typeKey) {
            if (gameState.cellSize.width === 0) return null; // Board not ready

            const zombieType = zombieTypes[typeKey];
            if (!zombieType) return null;

            markZombieAsEncountered(typeKey);

            const zombie = document.createElement('div');
            zombie.className = 'zombie';

            const baseEmoji = document.createElement('span');
            baseEmoji.textContent = zombieType.emoji;
            zombie.appendChild(baseEmoji);

            if (zombieType.attachments) {
                zombieType.attachments.forEach(att => {
                    const attachmentEl = document.createElement('span');
                    attachmentEl.className = 'zombie-attachment';
                    attachmentEl.textContent = att.emoji;
                    attachmentEl.style.right = `${att.offset.x}px`;
                    attachmentEl.style.top = `${att.offset.y}px`;
                    zombie.appendChild(attachmentEl);
                });
            }

            // Add classes for specific zombie styles
            if (typeKey === 'dancing') zombie.classList.add('dancing');
            if (typeKey === 'zomboni') zombie.classList.add('zomboni');
            if (typeKey === 'gargantuar' || typeKey === 'giga') zombie.classList.add('gargantuar');
            if (typeKey === 'imp') zombie.classList.add('imp');
            if (typeKey === 'jackInTheBox') zombie.classList.add('jackInTheBox');

            const healthBar = document.createElement('div');
            healthBar.className = 'zombie-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'zombie-health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            zombie.appendChild(healthBar);

            // Spawn *at* the cell's column
            const startX = col * gameState.cellSize.width + (gameState.cellSize.width * 0.2);
            const yPosition = gameState.boardRect.top + row * gameState.cellSize.height + (zombieType.isFlying ? -10 : gameState.cellSize.height / 2 - 20) + (row * 2.5);

            zombie.style.position = 'fixed';
            zombie.style.left = (gameState.boardRect.left + startX) + 'px';
            zombie.style.top = yPosition + 'px';

            // Rise from ground animation
            zombie.style.opacity = '0';
            zombie.style.transform = 'scaleX(-1) translateY(20px)';
            zombie.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease, transform calc(0.5s / var(--game-speed)) ease';

            document.getElementById('gameContainer').appendChild(zombie);

            setTimeout(() => {
                zombie.style.opacity = '1';
                zombie.style.transform = 'scaleX(-1) translateY(0)';
            }, 50);

            const zombieObj = {
                id: gameState.nextId++,
                element: zombie,
                healthBar: healthBar,
                healthFill: healthFill,
                row: row,
                health: zombieType.health,
                type: typeKey,
                x: startX,
                attacking: false,
                attackCooldown: 0,
                slowed: false,
                slowTimer: 0,
                isFrozen: false,
                freezeTimer: 0,
                isFlying: !!zombieType.isFlying,
                lastChomped: 0,
                isChangingLane: false,
                isStunned: false,
                stunTimer: 0,
                isBeingPushed: false
            };

            if (typeKey === 'cone' || typeKey === 'bucket' || typeKey === 'newspaper' || typeKey === 'trashCanZombie') {
                zombieObj.armorBroken = false;
            }

            if (typeKey === 'gargantuar' || typeKey === 'giga') {
                zombieObj.hasThrownImp = false;
                zombieObj.isThrowingImp = false;
            }

            // Add special properties for Dancing Zombie
            if (typeKey === 'dancing') {
                zombieObj.dancers = [];
                // Set lastSummon time to trigger first summon after 3 seconds
                zombieObj.lastSummon = Date.now() - (zombieType.summonCooldown - 3000);
                zombieObj.summonCooldown = zombieType.summonCooldown;
            }

            if (zombieType.isExplosive) {
                startJackInTheBoxTimer(zombieObj);
            }

            gameState.zombies.push(zombieObj);
            return zombieObj;
        }

        // Spawn Zombie with Health Bar (from edge)
        function spawnZombie(forceType = null) {
            const row = Math.floor(Math.random() * 5);
            let typeKey = forceType;

            // Failsafe: If spawnZombie is ever called without a type, default to 'normal' to prevent a crash.
            if (!typeKey) {
                console.error("spawnZombie was called without a type! Defaulting to 'normal'.");
                typeKey = 'normal';
            }

            const zombieType = zombieTypes[typeKey];
            if (!zombieType) {
                console.error(`Invalid zombie type "${typeKey}" passed to spawnZombie! Defaulting to 'normal'.`);
                typeKey = 'normal';
                zombieType = zombieTypes[typeKey];
            }

            markZombieAsEncountered(typeKey);

            const zombie = document.createElement('div');
            zombie.className = 'zombie';

            const baseEmoji = document.createElement('span');
            baseEmoji.textContent = zombieType.emoji;
            zombie.appendChild(baseEmoji);

            if (zombieType.attachments) {
                zombieType.attachments.forEach(att => {
                    const attachmentEl = document.createElement('span');
                    attachmentEl.className = 'zombie-attachment';
                    attachmentEl.textContent = att.emoji;
                    attachmentEl.style.right = `${att.offset.x}px`;
                    attachmentEl.style.top = `${att.offset.y}px`;
                    zombie.appendChild(attachmentEl);
                });
            }

            // Add classes for specific zombie styles
            if (typeKey === 'dancing') zombie.classList.add('dancing');
            if (typeKey === 'zomboni') zombie.classList.add('zomboni');
            if (typeKey === 'gargantuar' || typeKey === 'giga') zombie.classList.add('gargantuar');
            if (typeKey === 'imp') zombie.classList.add('imp');
            if (typeKey === 'jackInTheBox') zombie.classList.add('jackInTheBox');

            const healthBar = document.createElement('div');
            healthBar.className = 'zombie-health-bar';
            const healthFill = document.createElement('div');
            healthFill.className = 'zombie-health-fill';
            healthFill.style.width = '100%';
            healthBar.appendChild(healthFill);
            zombie.appendChild(healthBar);

            const startX = gameState.boardRect.width;
            const yPosition = gameState.boardRect.top + row * gameState.cellSize.height + (zombieType.isFlying ? -10 : gameState.cellSize.height / 2 - 20) + (row * 2.5);

            zombie.style.position = 'fixed';
            zombie.style.left = (gameState.boardRect.left + startX) + 'px';
            zombie.style.top = yPosition + 'px';

            document.getElementById('gameContainer').appendChild(zombie);

            const zombieObj = {
                id: gameState.nextId++,
                element: zombie,
                healthBar: healthBar,
                healthFill: healthFill,
                row: row,
                health: zombieType.health,
                type: typeKey,
                x: startX,
                attacking: false,
                attackCooldown: 0,
                slowed: false,
                slowTimer: 0,
                isFrozen: false,
                freezeTimer: 0,
                isFlying: !!zombieType.isFlying,
                lastChomped: 0,
                isChangingLane: false,
                isStunned: false,
                stunTimer: 0,
                isBeingPushed: false
            };

            if (typeKey === 'cone' || typeKey === 'bucket' || typeKey === 'newspaper' || typeKey === 'trashCanZombie') {
                zombieObj.armorBroken = false;
            }

            if (typeKey === 'gargantuar' || typeKey === 'giga') {
                zombieObj.hasThrownImp = false;
                zombieObj.isThrowingImp = false;
            }

            // Add special properties for Dancing Zombie
            if (typeKey === 'dancing') {
                zombieObj.dancers = [];
                zombieObj.lastSummon = Date.now() - (zombieType.summonCooldown - 3000);
                zombieObj.summonCooldown = zombieType.summonCooldown;
            }

            if (zombieType.isExplosive) {
                startJackInTheBoxTimer(zombieObj);
            }

            gameState.zombies.push(zombieObj);
        }

        // Spawn Zombie from a Grave
        function spawnZombieFromGrave(row, col) {
            // Only spawn basic types from graves
            const possibleTypes = ['normal', 'cone', 'bucket'];
            const randomTypeKey = possibleTypes[Math.floor(Math.random() * possibleTypes.length)];
            spawnZombieAt(row, col, randomTypeKey);
        }


        // Spawn Graves
        function spawnGraves(count) {
            const board = document.getElementById('gameBoard');
            const allCells = Array.from(board.getElementsByClassName('cell'));

            // Find cells that are free (no plant, no grave, not a crater, not iced)
            const freeCells = allCells.filter(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                // Only spawn graves in last 4 columns (5, 6, 7, 8)
                if (col < 5) return false;

                const hasPlant = gameState.plants.some(p => p.row === row && p.col === col);
                const hasGrave = gameState.graves.some(g => g.row === row && g.col === col);
                const isCrater = cell.classList.contains('crater');
                const isIced = cell.classList.contains('iced');

                return !hasPlant && !hasGrave && !isCrater && !isIced;
            });

            freeCells.sort(() => 0.5 - Math.random());

            const cellsToGrave = freeCells.slice(0, count);

            cellsToGrave.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                cell.classList.add('grave', 'grave-spawn');
                gameState.graves.push({ row, col, element: cell });

                createTimer(500, () => {
                    if (cell) {
                        cell.classList.remove('grave-spawn');
                    }
                }, false, 'remove_grave-spawn');
            });
        }

        // Show Points Popup
        function showPointsPopup(element, points) {
            const rect = element.getBoundingClientRect();
            const popup = document.createElement('div');
            popup.className = 'points-popup';
            popup.textContent = `+${points}`;
            popup.style.left = rect.left + 'px';
            popup.style.top = rect.top + 'px';
            popup.style.position = 'fixed';

            document.body.appendChild(popup);

            setTimeout(() => popup.remove(), 1500 / gameState.gameSpeed);
        }

        // Add Score
        function addScore(points) {
            gameState.score += points;
            updateScoreDisplay();

            if (gameState.score % 1000 < points) {
                gameState.sun += 50;
                updateSunDisplay();
                showPointsPopup(document.getElementById('sunCounter'), '+50 â˜€ï¸');
            }
        }

        // Spawn Zombie Wave
        function spawnZombieWave() {
            if (gameState.isGameOver || gameState.isVictory) return;

            gameState.isSpawningComplete = false;
            let zombiesToSpawn = [];
            const isHugeWave = gameState.wave % 5 === 0;

            // 1. Calculate the point budget for this wave
            let wavePoints;
            if (activeChallenges.hardMode) {
                wavePoints = 4 + (gameState.wave * 2.5); // 25% more budget, higher base
            } else {
                wavePoints = 2 + (gameState.wave * 2); // Original calculation
            }
            if (gameState.wave >= 11) {
                wavePoints *= 1.2;
            }
            if (isHugeWave) {
                wavePoints *= 1.5; // Huge waves are 50% stronger
            }
            wavePoints = Math.floor(wavePoints);
            wavePointsForCurrentWave = Math.floor(wavePoints);

            // 2. Handle Grave Spawning (no change to this logic)
            if (gameState.map === 'night' && Math.random() < 0.6) spawnGraves(Math.floor(Math.random() * 3) + 1);
            else if (gameState.wave > 7 && Math.random() < 0.3) spawnGraves(Math.floor(Math.random() * 3) + 1);

            gameState.graves.forEach(grave => {
                createTimer(Math.random() * 5000 + 1000, () => spawnZombieFromGrave(grave.row, grave.col), false, 'graveZombieSpawn', { row: grave.row, col: grave.col });
            });

            // 3. Add the Flag Zombie on Huge Waves
            if (isHugeWave) {
                if (gameState.wave < 20) {
                    zombiesToSpawn.push('flag');
                    wavePoints -= zombieWaveData['flag'].cost;
                } else {
                    zombiesToSpawn.push('rally');
                    wavePoints -= zombieWaveData['rally'].cost;
                }
            }

            // 4. "Buy" zombies until the wave point budget is spent
            let attempts = 0;
            while (wavePoints > 0 && attempts < 100) {
                // Get a list of all zombies we can currently afford and that are allowed on this wave
                let availableZombies = Object.keys(zombieWaveData)
                    .filter(type => {
                        const data = zombieWaveData[type];
                        return data.weight > 0 && gameState.wave >= data.minWave && data.cost <= wavePoints;
                    })
                    .map(type => ({ type, ...zombieWaveData[type] }));

                if (availableZombies.length === 0) break; // No more zombies can be afforded

                const totalWeight = availableZombies.reduce((sum, zombie) => sum + zombie.weight, 0);
                let randomWeight = Math.random() * totalWeight;

                for (const zombie of availableZombies) {
                    randomWeight -= zombie.weight;
                    if (randomWeight <= 0) {
                        zombiesToSpawn.push(zombie.type);
                        wavePoints -= zombie.cost;
                        break;
                    }
                }
                attempts++; // Failsafe to prevent infinite loops
            }

            // 5. Schedule the spawning of the generated wave
            const baseSpawnDelay = Math.max(2500 - gameState.wave * 50, 400);
            // Determine the correct spawn delay to use for this wave
            const spawnDelay = isHugeWave ? baseSpawnDelay * 0.6 : baseSpawnDelay;

            zombiesToSpawn.forEach((zombieType, index) => {
                // Use the consistent spawnDelay variable for each timer
                createTimer(spawnDelay * index, () => {
                    if (!gameState.isGameOver && !gameState.isVictory) {
                        spawnZombie(zombieType);
                    }
                }, false, 'waveZombieSpawn', zombieType);
            });

            // 6. Set the completion timer using the SAME spawnDelay variable
            const totalSpawnDuration = zombiesToSpawn.length * spawnDelay;

            createTimer(totalSpawnDuration, () => {
                gameState.isSpawningComplete = true;
            }, false, 'waveSpawningComplete');

            clearTimer(gameState.waveTimerId);

            gameState.waveTimerId = createTimer(30000, () => {
                if (!gameState.isGameOver && !gameState.isVictory && gameState.wave < gameState.maxWaves) {
                    gameState.wave++;
                    gameState.zombieDamageMultiplier = 1 + (gameState.wave - 1) * 0.02;
                    updateWaveDisplay();
                    updateDamageDisplay();
                    addScore(100 * gameState.wave);
                    saveGameState();
                    spawnZombieWave();
                }
            }, false, 'waveTimer');
        }

        // Victory function
        function victory() {
            if (gameState.isVictory) return;
            gameState.isVictory = true;
            gameState.isGameOver = true;

            // Add victory bonus
            const victoryBonus = 5000;
            gameState.score += victoryBonus;

            // Auto-save score
            saveToLeaderboard(gameState.score, gameState.wave, gameState.zombiesDefeated);

            // Show victory screen
            document.getElementById('victoryMaxWaves').textContent = gameState.maxWaves;
            document.getElementById('victoryScore').textContent = gameState.score.toLocaleString();
            document.getElementById('victoryZombies').textContent = gameState.zombiesDefeated;
            document.getElementById('victoryScreen').style.display = 'block';
        }

        // Spawn Sun Periodically
        function spawnSunPeriodically() {
            clearTimer(gameState.sunIntervalId);

            // Only spawn falling sun during the day
            if (gameState.map === 'day') {
                gameState.sunIntervalId = createTimer(8000, () => {
                    if (!gameState.isGameOver) {
                        spawnFallingSun();
                    }
                }, true, 'sunInterval');
            }
        }

        // Spawn Falling Sun
        function spawnFallingSun() {
            const gameContainer = document.getElementById('gameContainer');
            const containerRect = gameContainer.getBoundingClientRect();

            const padding = 100;
            const spawnWidth = containerRect.width - (padding * 2);
            if (spawnWidth <= 0) return;

            const startLeft = containerRect.left + padding + (Math.random() * spawnWidth);
            const startTop = containerRect.top + 15;

            const boardTopMargin = 150 / 700;
            const boardBottomMargin = 50 / 700;

            const landMinY = containerRect.top + (containerRect.height * boardTopMargin);
            const landMaxY = containerRect.top + containerRect.height - (containerRect.height * boardBottomMargin) - 50;
            const endTop = landMinY + (Math.random() * (landMaxY - landMinY));

            const sun = document.createElement('div');
            sun.className = 'sun';

            const sunEmoji = document.createElement('span');
            sunEmoji.textContent = 'â˜€ï¸';
            sun.appendChild(sunEmoji);

            const sunValue = document.createElement('span');
            sunValue.className = 'sun-value';
            sunValue.textContent = '25';
            sun.appendChild(sunValue);

            // Give the sun element a unique ID for tracking its timer
            const sunId = `sun-${gameState.nextId++}`;
            sun.dataset.sunId = sunId;

            sun.style.position = 'fixed';
            sun.style.left = startLeft + 'px';
            sun.style.top = startTop + 'px';
            sun.style.opacity = '1';
            sun.style.transform = 'scale(1)';
            sun.style.transition = `top calc(10s / var(--game-speed)) cubic-bezier(0.3, 0, 0.7, 1), opacity calc(0.5s / var(--game-speed)) ease-out, transform calc(0.5s / var(--game-speed)) ease-out`;

            document.getElementById('gameContainer').appendChild(sun);

            void sun.offsetHeight;
            sun.style.top = endTop + 'px';

            sun.addEventListener('click', () => collectSun(sun, 25));
            sun.addEventListener('touchstart', (e) => { e.preventDefault(); collectSun(sun, 25); }, { passive: false });

            const timeToFall = 10000;
            const lifeOnGround = 7000;

            // The full timer now includes the fall time and ground time
            createTimer(timeToFall + lifeOnGround, () => {
                if (sun.parentElement && !sun.dataset.collecting) {
                    sun.style.transition = 'opacity calc(0.5s / var(--game-speed)) ease-in, transform calc(0.5s / var(--game-speed)) ease-in';
                    sun.style.opacity = '0';
                    sun.style.transform = 'scale(0.5)';
                    createTimer(500, () => sun.remove());
                }
            }, false, 'sunDespawn', sunId);
        }

        // Collect Sun
        function collectSun(sunElement, value) {
            if (gameState.isPaused) return;

            if (!sunElement.parentElement || sunElement.dataset.collecting) return;

            sunElement.dataset.collecting = 'true';
            sunElement.style.pointerEvents = 'none';

            const sunCounter = document.getElementById('sunCounter');
            const counterRect = sunCounter.getBoundingClientRect();

            const sunRect = sunElement.getBoundingClientRect();

            sunElement.style.zIndex = '31';
            sunElement.style.transition = 'left calc(0.5s / var(--game-speed)) ease-in, top calc(0.5s / var(--game-speed)) ease-out, transform calc(0.5s / var(--game-speed)) ease-in, opacity calc(0.5s / var(--game-speed)) ease-in';
            sunElement.style.left = (counterRect.left + counterRect.width / 2 - sunRect.width / 2) + 'px';
            sunElement.style.top = (counterRect.top + counterRect.height / 2 - sunRect.height / 2) + 'px';
            sunElement.style.opacity = '0.5';

            createTimer(500, () => {
                if (sunElement.parentElement) {
                    sunElement.remove();
                }
                gameState.sun += value;
                updateSunDisplay();
                addScore(10);
            }, false, 'finalize_sun_collection');
        }


        // Update Plant Card Availability
        function updatePlantCardAvailability() {
            const repeaterOnBoard = gameState.plants.some(p => p.type === 'repeater');
            const sunflowerOnBoard = gameState.plants.some(p => p.type === 'sunflower');
            const fumeshroomOnBoard = gameState.plants.some(p => p.type === 'fumeshroom');
            const melonpultOnBoard = gameState.plants.some(p => p.type === 'melonpult');
            const spikeweedOnBoard = gameState.plants.some(p => p.type === 'spikeweed');

            document.querySelectorAll('#plantSelection .plantCard').forEach(card => {
                if (!card.dataset.plant) return; // Skip shovel

                const cost = parseInt(card.dataset.cost);
                const plantTypeInfo = plantTypes[card.dataset.plant];

                let canAfford = gameState.sun >= cost;
                let meetsSpecialReq = true;

                if (plantTypeInfo.isUpgrade) {
                    const upgradesFrom = plantTypeInfo.upgradesFrom;
                    if (upgradesFrom === 'repeater') meetsSpecialReq = repeaterOnBoard;
                    else if (upgradesFrom === 'sunflower') meetsSpecialReq = sunflowerOnBoard;
                    else if (upgradesFrom === 'fumeshroom') meetsSpecialReq = fumeshroomOnBoard;
                    else if (upgradesFrom === 'melonpult') meetsSpecialReq = melonpultOnBoard;
                    else if (upgradesFrom === 'spikeweed') meetsSpecialReq = spikeweedOnBoard;
                }

                if (canAfford && meetsSpecialReq) {
                    card.classList.remove('disabled');
                } else {
                    card.classList.add('disabled');
                }
            });
        }


        // Update Sun Display
        function updateSunDisplay() {
            document.getElementById('sunCount').textContent = gameState.sun;
            updatePlantCardAvailability();
            saveGameState();
        }

        // Update Score Display
        function updateScoreDisplay() {
            document.getElementById('scoreCount').textContent = gameState.score.toLocaleString();
        }

        // Flash Sun Counter when not enough sun
        function flashSunCounter() {
            const sunCounter = document.getElementById('sunCounter');
            sunCounter.style.transition = 'transform 0.1s ease, background 0.1s ease';
            sunCounter.style.transform = 'scale(1.1)';
            sunCounter.style.background = 'linear-gradient(135deg, #FF6B6B, #E91E63)'; // Flash red

            createTimer(100, () => {
                sunCounter.style.transform = 'scale(1)';
                sunCounter.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)'; // Return to normal

                createTimer(100, () => {
                    sunCounter.style.transition = 'transform 0.1s ease'; // Restore original transition
                }, false, 'flash_sun_counter_cleanup');
            }, false, 'flash_sun_counter_reset');
        }

        // Create Particle Effect
        function createParticleEffect(element, emoji) {
            if (document.body.classList.contains('performance-mode')) {
                return;
            }
            const rect = element.getBoundingClientRect ?
                element.getBoundingClientRect() :
                { left: element.offsetLeft, top: element.offsetTop };

            for (let i = 0; i < 3; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = emoji;
                particle.style.left = rect.left + 'px';
                particle.style.top = rect.top + 'px';
                particle.style.setProperty('--x', (Math.random() - 0.5) * 100 + 'px');
                particle.style.setProperty('--y', (Math.random() - 0.5) * 100 + 'px');

                document.body.appendChild(particle);

                setTimeout(() => particle.remove(), 1000);
            }
        }

        function createFlyingImpVisual(gargantuarElement) {
            if (!gargantuarElement) return;

            const rect = gargantuarElement.getBoundingClientRect();
            const flyingImp = document.createElement('div');
            flyingImp.className = 'flying-imp';
            flyingImp.textContent = 'ðŸ‘¿';

            flyingImp.style.left = rect.left + 'px';
            flyingImp.style.top = rect.top + 'px';

            document.getElementById('gameContainer').appendChild(flyingImp);

            const animationDuration = 700;
            createTimer(animationDuration, () => {
                flyingImp.remove();
            }, false, 'remove_flying_imp_visual');
        }

        function createFireBreathEffect(cell) {
            if (!cell) return;
            const fireEffect = document.createElement('div');
            fireEffect.className = 'instant-effect';
            fireEffect.textContent = 'ðŸ”¥';
            fireEffect.style.cssText = `
                position: absolute;
                font-size: 3em;
                z-index: 5;
                opacity: 0.8;
                transform: scale(0.5);
                filter: drop-shadow(0 0 10px orange);
                transition: transform calc(0.3s / var(--game-speed)) ease-out, opacity calc(0.3s / var(--game-speed)) ease-out;
                pointer-events: none;
            `;
            cell.appendChild(fireEffect);
            setTimeout(() => {
                fireEffect.style.transform = 'scale(1.2)';
            }, 10);
            createTimer(300, () => {
                fireEffect.style.opacity = '0';
                fireEffect.style.transform = 'scale(0)';
                createTimer(100, () => fireEffect.remove(), false, 'remove_fireEffect'); // Inner timer
            }, false, 'fadeout_fireEffect'); // Outer timer
        }

        function createGloomFumeEffect(cell) {
            if (!cell) return;
            const fumeEffect = document.createElement('div');
            fumeEffect.className = 'instant-effect';
            fumeEffect.textContent = 'ðŸŸ£';
            fumeEffect.style.cssText = `
                position: absolute;
                font-size: 2.5em;
                z-index: 5;
                opacity: 0;
                transform: scale(0.5);
                filter: drop-shadow(0 0 8px purple);
                transition: transform calc(0.2s / var(--game-speed)) ease-out, opacity calc(0.3s / var(--game-speed)) ease-out;
                pointer-events: none;
            `;
            cell.appendChild(fumeEffect);

            // Animate the effect
            setTimeout(() => {
                fumeEffect.style.opacity = '0.8';
                fumeEffect.style.transform = 'scale(1)';
            }, 10);

            // Timers for cleanup
            createTimer(200, () => {
                fumeEffect.style.opacity = '0';
                fumeEffect.style.transform = 'scale(0)';
                createTimer(100, () => fumeEffect.remove(), false, 'remove_fumeEffect');
            }, false, 'fadeout_fumeEffect');
        }

        function updateCooldownVisuals() {
            document.querySelectorAll('#plantSelection .plantCard').forEach(card => {
                const overlay = card.querySelector('.cooldown-overlay');
                if (!overlay) return;

                // If the card IS on cooldown...
                if (card.classList.contains('on-cooldown')) {
                    const timerId = card.dataset.cooldownTimerId;
                    if (timerId && gameState.timers[timerId]) {
                        const timer = gameState.timers[timerId];
                        const percent = Math.max(0, timer.remaining / timer.delay);
                        overlay.style.height = `${percent * 100}%`;
                    } else {
                        overlay.style.height = '0%';
                    }
                } else {
                    // Force reset if the card is NOT on cooldown.
                    overlay.style.height = '0%';
                }
            });
        }

        // --- Centralized function for handling zombie defeat ---
        function handleZombieDefeat(zombie, particleEmoji = 'ðŸ’€') {
            if (!zombie || !zombie.element || zombie.health > 0) return;

            // Clear any explosion timer if the zombie is defeated by other means
            if (zombie.explosionTimerId) {
                clearTimer(zombie.explosionTimerId);
            }

            // Check for victory condition.
            if (gameState.wave === gameState.maxWaves && gameState.isSpawningComplete && !gameState.victoryTriggered) {
                // Check if this kill results in zero *living* zombies on the board.
                const livingZombiesCount = gameState.zombies.filter(z => z.health > 0).length;

                if (livingZombiesCount === 0) {
                    // This is the last zombie (or part of the last batch).
                    gameState.victoryTriggered = true; // Set flag immediately to prevent multiple trophies
                    dropVictoryTrophy(zombie);

                    // Award points for the final kill
                    addScore(zombieTypes[zombie.type].points);
                    gameState.zombiesDefeated++;

                    // Remove the element and mark for filtering
                    zombie.element.remove();
                    zombie.element = null;
                    return; // Stop further processing for this zombie
                }
            }

            // Normal death logic
            const points = zombieTypes[zombie.type].points;
            showPointsPopup(zombie.element, points);
            addScore(points);
            createParticleEffect(zombie.element, particleEmoji);
            zombie.element.remove();
            zombie.element = null;
            gameState.zombiesDefeated++;
        }

        // --- VICTORY TROPHY LOGIC ---
        function dropVictoryTrophy(zombie) {
            const trophy = document.createElement('div');
            trophy.textContent = 'ðŸ†';
            trophy.style.cssText = `
                position: fixed;
                font-size: 3em;
                z-index: 100;
                cursor: pointer;
                filter: drop-shadow(0 0 15px gold);
                transition: transform calc(0.2s / var(--game-speed) ease-out;
            `;

            const zombieRect = zombie.element.getBoundingClientRect();
            trophy.style.left = zombieRect.left + 'px';
            trophy.style.top = zombieRect.top + 'px';

            trophy.addEventListener('mouseover', () => {
                trophy.style.transform = 'scale(1.2)';
            });
            trophy.addEventListener('mouseout', () => {
                trophy.style.transform = 'scale(1)';
            });

            trophy.addEventListener('click', () => animateAndTriggerVictory(trophy));

            document.getElementById('gameContainer').appendChild(trophy);
        }

        function animateAndTriggerVictory(trophyElement) {
            trophyElement.style.pointerEvents = 'none'; // Prevent double clicks

            const gameContainer = document.getElementById('gameContainer');
            const containerRect = gameContainer.getBoundingClientRect();

            const endLeft = containerRect.left + containerRect.width / 2;
            const endTop = containerRect.top + containerRect.height / 2;

            trophyElement.style.transition = 'left 0.75s ease-in-out, top 0.75s ease-in-out, transform 0.75s ease-in-out, filter 0.75s ease-in-out';

            // Start animation
            trophyElement.style.left = endLeft + 'px';
            trophyElement.style.top = endTop + 'px';
            trophyElement.style.transform = 'translate(-50%, -50%) scale(5)';
            trophyElement.style.filter = 'drop-shadow(0 0 30px gold) brightness(1.5)';

            // When animation is done, call victory
            createTimer(1200, () => {
                trophyElement.remove();
                victory();
            });
        }

        function moveFlyingOctopuses(deltaTime) {
            const adjustedDelta = deltaTime * gameState.gameSpeed;
            const speed = 300; // Pixels per second

            gameState.flyingOctopuses = gameState.flyingOctopuses.filter(octopus => {
                if (!octopus.element || !octopus.element.parentElement) return false;

                const targetPlant = gameState.plants.find(p => p.id === octopus.targetPlantId && p.element);

                // If the target plant is gone, the octopus just disappears
                if (!targetPlant) {
                    octopus.element.remove();
                    return false;
                }

                const targetRect = targetPlant.element.getBoundingClientRect();
                const targetX = targetRect.left + (targetRect.width / 2);
                const targetY = targetRect.top + (targetRect.height / 2);

                const dx = targetX - octopus.x;
                const dy = targetY - octopus.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const travelDistance = speed * adjustedDelta / 1000;

                // Check for collision
                if (distance <= travelDistance) {
                    octopus.element.remove(); // Remove the flying octopus

                    // Apply the wrap effect to the plant
                    plantToWrap = gameState.plants.find(p => p.id === octopus.targetPlantId && p.element);
                    if (plantToWrap && !plantToWrap.isWrapped) {
                        plantToWrap.isWrapped = true;
                        plantToWrap.wrapTimer = 10000;

                        const octopusOverlay = document.createElement('div');
                        octopusOverlay.className = 'plant-octopus-overlay';
                        octopusOverlay.textContent = 'ðŸ™';
                        plantToWrap.element.appendChild(octopusOverlay);
                        plantToWrap.octopusElement = octopusOverlay;
                    }
                    return false; // Remove from the array
                }

                // Move the octopus
                octopus.x += (dx / distance) * travelDistance;
                octopus.y += (dy / distance) * travelDistance;

                octopus.element.style.left = octopus.x + 'px';
                octopus.element.style.top = octopus.y + 'px';

                return true; // Keep in the array
            });
        }

        function togglePerformanceMode() {
            document.body.classList.toggle('performance-mode');

            // Save preference
            const isEnabled = document.body.classList.contains('performance-mode');
            localStorage.setItem('pvz_perf_mode', isEnabled);

            // Optional: Visual feedback on the button
            const btn = document.querySelector('#pauseMenu button[onclick="togglePerformanceMode()"]');
            if (btn) btn.textContent = isEnabled ? "ðŸš€ Perf. Mode: ON" : "ðŸš€ Perf. Mode: OFF";

            // Re-render board dimensions in case CSS changes affected layout
            setTimeout(updateBoardDimensions, 100);
        }

        // Checks if the user had it enabled previously
        if (localStorage.getItem('pvz_perf_mode') === 'true') {
            togglePerformanceMode(); // Activates it on startup
        }

        // Game Loop
        function startGameLoop() {
            function gameLoop() {
                const now = Date.now();
                const deltaTime = now - gameState.lastUpdate;
                gameState.lastUpdate = now;

                if (!gameState.isPaused && !gameState.isGameOver) {
                    const adjustedDelta = deltaTime * gameState.gameSpeed;

                    updateTimers(deltaTime);
                    updateCooldownVisuals();
                    moveZombies(deltaTime);
                    moveProjectiles(deltaTime);
                    updateLawnmowers(deltaTime);
                    moveFlyingOctopuses(deltaTime);

                    // --- ZOMBIE SHOOTING LOGIC ---
                    gameState.zombies.forEach(zombie => {
                        if (!zombie.element || zombie.isStunned || zombie.isFrozen) return;

                        const zombieType = zombieTypes[zombie.type];
                        if (!zombieType.shoots) return;

                        if (zombie.shootCooldown === undefined) zombie.shootCooldown = zombieType.shootInterval;
                        zombie.shootCooldown -= adjustedDelta;

                        const hasTarget = gameState.plants.some(p => p.row === zombie.row && !plantTypes[p.type].isSpike);

                        if (zombie.shootCooldown <= 0 && hasTarget) {
                            zombie.shootCooldown = zombieType.shootInterval;
                            zombie.attacking = true; // Stop the zombie to shoot

                            // Fire the first shot
                            fireZombieProjectile(zombie);

                            // If it's a quad shooter, schedule the next 3 shots
                            if (zombieType.quad) {
                                createTimer(133, () => fireZombieProjectile(zombie), false, 'zombieBurstShot', zombie.id);
                                createTimer(266, () => fireZombieProjectile(zombie), false, 'zombieBurstShot', zombie.id);
                                createTimer(399, () => fireZombieProjectile(zombie), false, 'zombieBurstShot', zombie.id);
                                // After the burst, allow the zombie to move again
                                createTimer(500, () => { if (zombie) zombie.attacking = false; }, false, 'zombieEndAttack', zombie.id);
                            } else {
                                // For single shooters, let them move again sooner
                                createTimer(500, () => { if (zombie) zombie.attacking = false; }, false, 'zombieEndAttack', zombie.id);
                            }
                        }
                    });

                    // --- OCTO ZOMBIE THROWING LOGIC ---
                    gameState.zombies.forEach(zombie => {
                        if (!zombie.element || zombie.isStunned || zombie.isFrozen || zombie.attacking) return;

                        const zombieType = zombieTypes[zombie.type];
                        if (!zombieType.isThrower) return;

                        if (zombie.throwCooldown === undefined) zombie.throwCooldown = zombieType.throwInterval;
                        zombie.throwCooldown -= adjustedDelta;

                        let targetPlant = null;

                        // Priority 1: Find the best target in the same row (front-most)
                        const sameLaneTargets = gameState.plants.filter(p => p.row === zombie.row && !p.isWrapped);

                        if (sameLaneTargets.length > 0) {
                            targetPlant = sameLaneTargets.reduce((closest, current) => (current.col > closest.col ? current : closest));
                        } else {
                            // Priority 2: If no valid target in the same lane, find the best target in ANY lane
                            const allAvailableTargets = gameState.plants.filter(p => !p.isWrapped);

                            if (allAvailableTargets.length > 0) {
                                // First, find the furthest column that any available plant is in
                                const maxCol = Math.max(...allAvailableTargets.map(p => p.col));

                                // Get all plants in that furthest column
                                const frontmostTargets = allAvailableTargets.filter(p => p.col === maxCol);

                                // From those front-most plants, find the one that is vertically closest to the zombie
                                targetPlant = frontmostTargets.reduce((closest, current) => {
                                    const closestDist = Math.abs(closest.row - zombie.row);
                                    const currentDist = Math.abs(current.row - zombie.row);
                                    return currentDist < closestDist ? current : closest;
                                });
                            }
                        }

                        if (zombie.throwCooldown <= 0 && targetPlant) {
                            zombie.throwCooldown = zombieType.throwInterval;
                            zombie.attacking = true;
                            zombie.isThrowing = true;

                            if (zombie.element) {
                                zombie.element.classList.add('zombie-throwing');
                            }

                            // A short delay to sync the projectile spawn with the animation
                            createTimer(500, () => {
                                if (!zombie.element) return; // Zombie might have died mid-animation

                                const zombieRect = zombie.element.getBoundingClientRect();
                                const startX = zombieRect.left + (zombieRect.width / 4);
                                const startY = zombieRect.top;

                                const octopusElement = document.createElement('div');
                                octopusElement.className = 'flying-octopus';
                                octopusElement.textContent = 'ðŸ™';
                                octopusElement.style.left = startX + 'px';
                                octopusElement.style.top = startY + 'px';
                                document.getElementById('gameContainer').appendChild(octopusElement);

                                gameState.flyingOctopuses.push({
                                    element: octopusElement,
                                    x: startX,
                                    y: startY,
                                    targetPlantId: targetPlant.id,
                                });

                            }, false, 'octoLaunch', zombie.id);


                            createTimer(1000, () => { if (zombie && zombie.element) zombie.element.classList.remove('zombie-throwing'); }, false, 'zombieEndThrowAnim', zombie.id);
                            createTimer(1500, () => {
                                if (zombie) {
                                    zombie.attacking = false;
                                    zombie.isThrowing = false;
                                }
                            }, false, 'zombieEndAttack', zombie.id);
                        }
                    });

                    // --- POTATO MINE EXPLOSION LOGIC ---
                    const minesToExplode = [];
                    gameState.plants.forEach(plant => {
                        if (plant.type === 'potatomine' && plant.isArmed && !plant.isArming) {
                            const triggeringZombie = gameState.zombies.find(zombie =>
                                !zombie.isFlying &&
                                zombie.row === plant.row &&
                                Math.floor(zombie.x / gameState.cellSize.width) === plant.col
                            );
                            if (triggeringZombie) {
                                minesToExplode.push(plant);
                            }
                        }
                    });

                    if (minesToExplode.length > 0) {
                        minesToExplode.forEach(mine => {
                            const zombiesToDamage = gameState.zombies.filter(zombie =>
                                zombie.row === mine.row && Math.floor(zombie.x / gameState.cellSize.width) === mine.col
                            );

                            if (mine.element) {
                                const cell = mine.element.parentElement;
                                if (cell) {
                                    const explosionElement = document.createElement('div');
                                    explosionElement.className = 'instant-effect';
                                    explosionElement.textContent = 'ðŸ’¥';
                                    if (mobileDevice) {
                                        explosionElement.style.cssText = `position: absolute; font-size: 6em; z-index: 10; filter: drop-shadow(0 0 10px orange); transform: translate(-50%, -50%); top: 50%; left: 50%; pointer-events: none;`;
                                    } else {
                                        explosionElement.style.cssText = `position: absolute; font-size: 9em; z-index: 10; filter: drop-shadow(0 0 10px orange); transform: translate(-50%, -50%); top: 50%; left: 50%; pointer-events: none;`;
                                    }
                                    cell.appendChild(explosionElement);
                                    createTimer(600, () => explosionElement.remove(), false, 'remove_explosionElement');
                                }
                            }

                            zombiesToDamage.forEach(zombie => {
                                zombie.health -= plantTypes.potatomine.damage;
                                checkZombieStateChange(zombie);
                                updateZombieHealth(zombie);
                                if (zombie.element) {
                                    zombie.element.classList.add('damage-effect');
                                    createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); }, false, 'remove_damage-effect');
                                }
                                if (zombie.health <= 0) {
                                    handleZombieDefeat(zombie);
                                }
                            });

                            if (mine.element) mine.element.remove();
                            mine.element = null;
                        });

                        gameState.plants = gameState.plants.filter(p => p.element);
                        gameState.zombies = gameState.zombies.filter(z => z.element);
                    }

                    // Logic to advance to the next wave
                    if (gameState.isSpawningComplete && gameState.zombies.length === 0 && !gameState.victoryTriggered) {
                        if (gameState.wave < gameState.maxWaves) {
                            gameState.isSpawningComplete = false;

                            clearTimer(gameState.waveTimerId);

                            createTimer(2000, () => {
                                if (!gameState.isGameOver && !gameState.isVictory) {
                                    gameState.wave++;
                                    gameState.zombieDamageMultiplier = 1 + (gameState.wave - 1) * 0.02;
                                    updateWaveDisplay();
                                    updateDamageDisplay();
                                    addScore(100 * gameState.wave);
                                    saveGameState();
                                    spawnZombieWave();
                                }
                            }, false, 'nextWave');
                        }
                    }

                    gameState.plants.forEach(plant => {
                        // Handle octopus wrap timer
                        if (plant.isWrapped) {
                            plant.wrapTimer -= adjustedDelta;
                            if (plant.wrapTimer <= 0) {
                                plant.isWrapped = false;
                                if (plant.octopusElement) {
                                    plant.octopusElement.remove();
                                    delete plant.octopusElement;
                                }
                            }
                        }

                        if (!plant.element || plant.isSleeping || plant.isWrapped) return;
                        const plantType = plantTypes[plant.type];

                        // Sun Production
                        if (plantType.produces === 'sun' || plantType.produces === 'coin') {
                            plant.sunCooldown -= adjustedDelta;
                            if (plant.sunCooldown <= 0) {
                                produceSun(plant);
                                const baseInterval = plantType.baseInterval || 24000;
                                plant.sunCooldown = (baseInterval - 2000) + (Math.random() * 4000);
                            }
                        }

                        // Shooting
                        if (plantType.shoots) {
                            plant.shootCooldown -= adjustedDelta;
                            if (plant.shootCooldown <= 0) {
                                shoot(plant);
                            }
                        }

                        // Chomper Logic
                        if (plant.type === 'chomper') {
                            if (plant.isChewing) {
                                plant.chewTimer -= adjustedDelta;
                                if (plant.chewTimer <= 0) {
                                    plant.isChewing = false;
                                    if (plant.element) {
                                        plant.element.classList.remove('chewing');
                                    }
                                }
                            } else {
                                const targetZombie = gameState.zombies.find(zombie =>
                                    zombie.row === plant.row &&
                                    !zombie.isFlying &&
                                    zombie.element &&
                                    zombie.x < (plant.col + 2) * gameState.cellSize.width &&
                                    zombie.x > (plant.col - 0.5) * gameState.cellSize.width
                                );

                                if (targetZombie) {
                                    const zombieType = zombieTypes[targetZombie.type];
                                    if (zombieType.uneatable) {
                                        if (now - plant.lastChomp > plantType.attackInterval / gameState.gameSpeed) {
                                            plant.lastChomp = now;
                                            targetZombie.health -= plantType.damage;

                                            if (plant.element) {
                                                plant.element.classList.add('shooting');
                                                createTimer(300, () => { if (plant.element) plant.element.classList.remove('shooting'); }, false, 'remove_shooting');
                                            }

                                            if (targetZombie.element) {
                                                targetZombie.element.classList.add('damage-effect');
                                                createTimer(300, () => {
                                                    if (targetZombie.element) targetZombie.element.classList.remove('damage-effect');
                                                }, false, 'remove_damage-effect');
                                            }
                                            updateZombieHealth(targetZombie);
                                            if (targetZombie.health <= 0) {
                                                handleZombieDefeat(targetZombie);
                                            }
                                        }
                                    } else {
                                        targetZombie.health = 0; // Mark for defeat
                                        handleZombieDefeat(targetZombie, 'ðŸ˜‹');

                                        plant.isChewing = true;
                                        plant.chewTimer = plantType.chewTime;
                                        if (plant.element) {
                                            plant.element.classList.add('shooting');
                                            createTimer(300, () => { if (plant.element) plant.element.classList.remove('shooting'); }, false, 'remove_shooting');

                                            createTimer(750, () => {
                                                if (plant.element && plant.isChewing) {
                                                    plant.element.classList.add('chewing');
                                                }
                                            }, false, 'add_chewing');
                                        }
                                    }
                                }
                            }
                        }

                        // Spikeweed/Spikerock Damage Logic
                        if (plantType.isSpike) {
                            if (!plant.lastAttack) plant.lastAttack = 0;
                            if (now - plant.lastAttack > plantType.attackInterval / gameState.gameSpeed) {
                                const zombiesOnTile = gameState.zombies.filter(z =>
                                    !z.isFlying &&
                                    z.row === plant.row &&
                                    Math.abs(z.x / gameState.cellSize.width - (plant.col + 0.5)) <= 0.525
                                );

                                if (zombiesOnTile.length > 0) {
                                    plant.lastAttack = now;
                                    if (plant.element) {
                                        plant.element.classList.add('shooting');
                                        createTimer(300, () => { if (plant.element) plant.element.classList.remove('shooting'); }, false, 'remove_shooting');
                                    }

                                    zombiesOnTile.forEach(zombie => {
                                        zombie.health -= plantType.damage;
                                        checkZombieStateChange(zombie);
                                        updateZombieHealth(zombie);
                                        if (zombie.element) {
                                            zombie.element.classList.add('damage-effect');
                                            createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); }, false, 'remove_damage-effect');
                                        }
                                        if (zombie.health <= 0) {
                                            handleZombieDefeat(zombie);
                                        }
                                    });
                                    gameState.zombies = gameState.zombies.filter(z => z.element);
                                }
                            }
                        }
                    });

                    // --- SNAPDRAGON LOGIC ---
                    gameState.plants.forEach(plant => {
                        if (plant.type === 'snapdragon' && !plant.isWrapped) {
                            if (!plant.shootCooldown) plant.shootCooldown = 0;
                            plant.shootCooldown -= adjustedDelta;
                            if (plant.shootCooldown <= 0) {
                                const attackRows = [plant.row - 1, plant.row, plant.row + 1];

                                const startBoundaryX = (plant.col + 2 / 3) * gameState.cellSize.width;
                                const endBoundaryX = (plant.col + 3) * gameState.cellSize.width;

                                const zombiesToAttack = gameState.zombies.filter(zombie => {
                                    if (!zombie.element) return false;

                                    const isInYRange = attackRows.includes(zombie.row);
                                    const isInXRange = zombie.x >= startBoundaryX && zombie.x < endBoundaryX;

                                    return isInYRange && isInXRange && !zombie.isFlying;
                                });

                                if (zombiesToAttack.length > 0) {
                                    plant.shootCooldown = plantTypes.snapdragon.shootInterval;
                                    if (plant.element) {
                                        plant.element.classList.add('shooting');
                                        createTimer(300, () => { if (plant.element) plant.element.classList.remove('shooting'); }, false, 'remove_shooting');
                                    }

                                    attackRows.forEach(r => {
                                        if (r >= 0 && r < 5) {
                                            const cell1 = document.querySelector(`.cell[data-row='${r}'][data-col='${plant.col + 1}']`);
                                            const cell2 = document.querySelector(`.cell[data-row='${r}'][data-col='${plant.col + 2}']`);

                                            if (cell1) createFireBreathEffect(cell1);
                                            if (cell2) createFireBreathEffect(cell2);
                                        }
                                    });

                                    zombiesToAttack.forEach(zombie => {
                                        zombie.health -= plantTypes.snapdragon.damage;
                                        checkZombieStateChange(zombie);
                                        updateZombieHealth(zombie);

                                        if (zombie.isFrozen) {
                                            zombie.isFrozen = false;
                                            zombie.freezeTimer = 0;
                                            zombie.element.classList.remove('frozen');
                                        } else if (zombie.slowed) {
                                            zombie.slowed = false;
                                            zombie.slowTimer = 0;
                                            zombie.element.classList.remove('slowed');
                                        }

                                        if (zombie.element) {
                                            zombie.element.classList.add('damage-effect');
                                            createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); }, false, 'remove_damage-effect');
                                        }

                                        if (zombie.health <= 0) {
                                            handleZombieDefeat(zombie);
                                        }
                                    });
                                }
                            }
                        }
                    });

                    // --- GLOOM-SHROOM LOGIC ---
                    gameState.plants.forEach(plant => {
                        if (plant.type === 'gloomshroom' && !plant.isSleeping && !plant.isWrapped) {
                            if (!plant.shootCooldown) plant.shootCooldown = 0;
                            plant.shootCooldown -= adjustedDelta;

                            if (plant.shootCooldown <= 0) {
                                const plantType = plantTypes.gloomshroom;
                                // Define the 3x3 attack area
                                const minRow = plant.row - 1;
                                const maxRow = plant.row + 1;
                                const minCol = plant.col - 1;
                                const maxCol = plant.col + 1;

                                // Find all zombies within that 3x3 grid
                                const zombiesToAttack = gameState.zombies.filter(zombie =>
                                    zombie.element &&
                                    !zombie.isFlying &&
                                    zombie.row >= minRow && zombie.row <= maxRow &&
                                    Math.floor(zombie.x / gameState.cellSize.width) >= minCol &&
                                    Math.floor(zombie.x / gameState.cellSize.width) <= maxCol
                                );

                                if (zombiesToAttack.length > 0) {
                                    plant.shootCooldown = plantType.attackInterval;
                                    if (plant.element) {
                                        plant.element.classList.add('shooting');
                                        createTimer(300, () => { if (plant.element) plant.element.classList.remove('shooting'); }, false, 'remove_shooting');
                                    }

                                    // Create a visual effect on all 9 tiles
                                    for (let r = minRow; r <= maxRow; r++) {
                                        for (let c = minCol; c <= maxCol; c++) {
                                            if (r >= 0 && r < 5 && c >= 0 && c < 9) {
                                                const cell = document.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
                                                if (cell) createGloomFumeEffect(cell);
                                            }
                                        }
                                    }

                                    // Damage all zombies in the area
                                    zombiesToAttack.forEach(zombie => {
                                        zombie.health -= plantType.damage;
                                        checkZombieStateChange(zombie);
                                        updateZombieHealth(zombie);

                                        if (zombie.element) {
                                            zombie.element.classList.add('damage-effect');
                                            createTimer(300, () => { if (zombie.element) zombie.element.classList.remove('damage-effect'); }, false, 'remove_damage-effect');
                                        }

                                        if (zombie.health <= 0) {
                                            handleZombieDefeat(zombie);
                                        }
                                    });
                                }
                            }
                        }
                    });

                    gameState.plants = gameState.plants.filter(p => p.element);

                    const debugInfo = document.getElementById('debugInfo');
                    const fps = Math.round(1000 / deltaTime);

                    if (isRecordingFPS) {
                        fpsRecordingData.push({
                            time: Date.now() - recordingStartTime,
                            fps: fps
                        });
                    }

                    if (debugInfo.style.display === 'block') {
                        let avgFps = 0, minFps = 0, maxFps = 0;
                        if (fpsHistory.length > 0) {
                            avgFps = Math.round(fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length);
                            minFps = Math.min(...fpsHistory);
                            maxFps = Math.max(...fpsHistory);
                        }

                        let nextWaveIn = 'N/A';
                        const waveTimer = Object.values(gameState.timers).find(t => t.type === 'waveTimer' || t.type === 'nextWave');
                        if (waveTimer) {
                            nextWaveIn = (waveTimer.remaining / 1000).toFixed(1) + 's';
                        }

                        let recordingStatus = isRecordingFPS ? '<span style="color:red; animation: pulse 1s infinite">â— REC</span>' : 'OFF';

                        document.getElementById('debugText').innerHTML = `
                            <strong>FPS: ${fps}</strong> <small>(Avg:${avgFps} Min:${minFps} Max:${maxFps})</small><br>
                            <div style="height:1px; background: #555; margin: 3px 0;"></div>
                            Zombies: ${gameState.zombies.length}<br>
                            Plants: ${gameState.plants.length}<br>
                            Projectiles: ${gameState.projectiles.length}<br>
                            Graves: ${gameState.graves.length} | Ice: ${gameState.iceTrails.length}<br>
                            Timers: ${Object.keys(gameState.timers).length}<br>
                            <div style="height:1px; background: #555; margin: 3px 0;"></div>
                            Wave: ${gameState.wave}/${gameState.maxWaves} (Next: ${nextWaveIn})<br>
                            Points Budget: ${wavePointsForCurrentWave}<br>
                            Spawning Complete: ${gameState.isSpawningComplete}<br>
                            Damage Mult: ${gameState.zombieDamageMultiplier.toFixed(2)}x<br>
                            <div style="height:1px; background: #555; margin: 3px 0;"></div>
                            Recorder: ${recordingStatus}
                        `;

                        updateFpsGraph(fps);
                    }
                }

                gameState.gameLoopId = requestAnimationFrame(gameLoop);
            }

            gameState.gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Toggle Pause
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                // Actions on pause
                // Deselect zombie when pausing
                if (gameState.isZombieSpawnMode) {
                    gameState.selectedZombie = null;
                    document.getElementById('gameBoard').classList.remove('zombie-spawn-mode');
                    document.querySelectorAll('.zombieCard.selected').forEach(c => c.classList.remove('selected'));
                }
            } else {
                // Actions on resume
                gameState.lastUpdate = Date.now(); // Prevents a large deltaTime jump
            }
            document.getElementById('pauseMenu').style.display =
                gameState.isPaused ? 'block' : 'none';
            document.getElementById('pauseBtn').textContent = gameState.isPaused ? 'â–¶ï¸ Play' : 'â¸ï¸ Pause';
        }

        // Resume Game
        function resumeGame() {
            gameState.isPaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('pauseBtn').textContent = 'â¸ï¸ Pause';
            gameState.lastUpdate = Date.now();
        }

        // Game Over - AUTO SAVE SCORE
        function gameOver() {
            if (gameState.isGameOver) return;

            gameState.isGameOver = true;
            togglePause();

            // Auto-save score
            saveToLeaderboard(gameState.score, gameState.wave, gameState.zombiesDefeated);

            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = gameState.score.toLocaleString();
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('finalZombies').textContent = gameState.zombiesDefeated;
        }

        // Custom Dialog System
        function showCustomDialog(title, message, buttons) {
            const dialog = document.getElementById('customDialog');
            const titleEl = document.getElementById('dialogTitle');
            const messageEl = document.getElementById('dialogMessage');
            const buttonsEl = document.getElementById('dialogButtons');

            titleEl.textContent = title;
            messageEl.innerHTML = message;
            buttonsEl.innerHTML = '';

            buttons.forEach(buttonInfo => {
                const button = document.createElement('button');
                button.textContent = buttonInfo.text;
                button.className = 'btn';
                if (buttonInfo.class) {
                    button.classList.add(buttonInfo.class);
                }

                button.addEventListener('click', () => {
                    hideCustomDialog();
                    if (buttonInfo.callback) {
                        buttonInfo.callback();
                    }
                });

                buttonsEl.appendChild(button);
            });

            dialog.style.display = 'flex';
        }

        function hideCustomDialog() {
            document.getElementById('customDialog').style.display = 'none';
        }

        function confirmRestart() {
            showCustomDialog(
                'Confirm Restart',
                'Are you sure you want to start a new game? Your current progress will be lost.',
                [
                    { text: 'No, Cancel' },
                    { text: 'Yes, Restart', class: 'secondary', callback: restartGame }
                ]
            );
        }

        // Restart Game
        function restartGame() {
            if (gameState.gameLoopId) {
                cancelAnimationFrame(gameState.gameLoopId);
            }
            resetGame();
            resetChallenges();
            createBoard();

            // Only need to re-attach listeners to the newly created cells.
            setupGameBoardListeners();

            setupZombieSpawner();

            selectedPlantDeck = [];
            document.getElementById('selectedPlantCount').textContent = '0';
            showPlantSelectionScreen();
            togglePause();
        }

        // Toggle Fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                enterFullscreen();
            } else {
                const exitFS = document.exitFullscreen ||
                    document.webkitExitFullscreen ||
                    document.mozCancelFullScreen ||
                    document.msExitFullscreen;

                if (exitFS) {
                    exitFS.call(document).then(() => {
                        gameState.wasFullscreen = false;
                        localStorage.removeItem('pvz_fullscreen');
                        setTimeout(updateBoardDimensions, 100);
                    });
                }
            }
        }

        // Save Game State
        function saveGameState() {
            const saveData = {
                sun: gameState.sun,
                score: gameState.score,
                wave: gameState.wave,
                zombiesDefeated: gameState.zombiesDefeated,
                zombieDamageMultiplier: gameState.zombieDamageMultiplier
            };
            localStorage.setItem('pvz_gameState', JSON.stringify(saveData));
        }

        // Load Game State
        function loadGameState() {
            // Check if should restore fullscreen
            const shouldBeFullscreen = localStorage.getItem('pvz_fullscreen') === 'true';
            if (shouldBeFullscreen) {
                setTimeout(() => {
                    enterFullscreen();
                }, 100);
            }

            updateSunDisplay();
        }

        // Initialize game when page loads
        window.addEventListener('load', init);

        // Handle visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && !gameState.isPaused && !gameState.isGameOver) {
                togglePause();
            } else if (!document.hidden && gameState.isPaused) {
                // When coming back, ensure lastUpdate is reset to avoid a time jump
                gameState.lastUpdate = Date.now();
            }
        });
    </script>

    <script src="cheats_light.js"></script>
</body>

</html>
